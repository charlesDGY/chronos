!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACCESS	cache.h	/^enum ACCESS {$/;"	g
ACCESS_T	cache.h	/^typedef enum ACCESS ACCESS_T;$/;"	t	typeref:enum:ACCESS
ACS_IDENTICAL	scp_cache.h	13;"	d
ACS_NOT_IDENTICAL	scp_cache.h	14;"	d
ADD_ASSIGN	symexec.c	770;"	d	file:
AGED	scp_cache.h	56;"	d
ALL_HIT	cache.h	/^	ALL_HIT = 0,$/;"	e	enum:ACCESS
ALL_MISS	cache.h	/^	ALL_MISS,$/;"	e	enum:ACCESS
ALL_X	cache.h	/^	ALL_X, \/* Not accessed *\/	$/;"	e	enum:ACCESS
ANALYSIS	cache.h	/^enum ANALYSIS {$/;"	g
ANALYSIS_T	cache.h	/^typedef enum ANALYSIS ANALYSIS_T;$/;"	t	typeref:enum:ANALYSIS
ANSI_SYMCAT	ss/host.h	72;"	d
ANSI_SYMCAT	ss/host.h	78;"	d
AVOID_ONE_ACCESS_MULTIPLE_AGING	scp_cache.h	54;"	d
B	main.c	/^int X, Y, B, l1, l2;$/;"	v
B	unicache.c	/^int X, Y, B;$/;"	v
BAD_RANGE	common.h	32;"	d
BA_conflict_list	infeasible.h	/^  BA_conflict_t *BA_conflict_list;$/;"	m	struct:branch_t	access:public
BA_conflict_t	infeasible.h	/^} BA_conflict_t;$/;"	t	typeref:struct:__anon10
BB_conflict_list	infeasible.h	/^  BB_conflict_t *BB_conflict_list;$/;"	m	struct:branch_t	access:public
BB_conflict_t	infeasible.h	/^} BB_conflict_t;$/;"	t	typeref:struct:__anon11
BCODE	ss/machine.h	326;"	d
BETWEEN	common.h	49;"	d
BHR	bpred.c	/^int		    BHR, BHR_PWR, BHR_MSK;$/;"	v
BHR_MSK	bpred.c	/^int		    BHR, BHR_PWR, BHR_MSK;$/;"	v
BHR_PWR	bpred.c	/^int		    BHR, BHR_PWR, BHR_MSK;$/;"	v
BHT	bpred.c	/^int		    BHT_SIZE, BHT, BHT_MSK;$/;"	v
BHT_MSK	bpred.c	/^int		    BHT_SIZE, BHT, BHT_MSK;$/;"	v
BHT_SIZE	bpred.c	/^int		    BHT_SIZE, BHT, BHT_MSK;$/;"	v
BIV	symexec.h	/^struct BIV {$/;"	s
BIV::flag	symexec.h	/^	int flag;$/;"	m	struct:BIV	access:public
BIV::initVal	symexec.h	/^	reg_t initVal;$/;"	m	struct:BIV	access:public
BIV::insn	symexec.h	/^	void *insn; \/\/instruction performs inductive operation$/;"	m	struct:BIV	access:public
BIV::opr	symexec.h	/^	char opr[8]; \/\/inductive operation, e.g + - * \/ >>$/;"	m	struct:BIV	access:public
BIV::regName	symexec.h	/^	char regName[10];$/;"	m	struct:BIV	access:public
BIV::stride	symexec.h	/^	int stride;$/;"	m	struct:BIV	access:public
BIV_INST	infeasible.h	93;"	d
BIV_SAVED	symexec.h	91;"	d
BI_DELAY	exegraph.h	/^enum { BI_DELAY, UNI_DELAY, NO_DELAY };$/;"	e	enum:__anon30
BMP	ilp.c	83;"	d	file:
BODY_CODE	pipeline.h	27;"	d
BOTH_BRANCHES	cfg.h	32;"	d
BPRED_H	bpred.h	27;"	d
BP_CPRED	bpred.h	33;"	d
BP_MPRED	bpred.h	34;"	d
BP_NONE	bpred.h	32;"	d
BP_UNCLEAR	bpred.h	35;"	d
BS	ss/machine.h	332;"	d
CACHE_H	cache.h	23;"	d
CACHE_LINE	cache.h	34;"	d
CACHE_LINE_L2	cache.h	46;"	d
CACHE_SET_SIZE	cache.h	140;"	d
CACHE_SIZE	cache.h	139;"	d
CC	Makefile	/^CC=gcc$/;"	m
CFG_H	cfg.h	23;"	d
CFLAGS	Makefile	/^CFLAGS=-g -DMEM_FREE$/;"	m
CHECK_MEM	common.h	41;"	d
CINFTY	unicache.c	12;"	d	file:
CLEAR_LSB	cache.h	42;"	d
COMMON_H	common.h	23;"	d
CONNECT	ss/machine.c	115;"	d	file:
CONNECT	ss/machine.c	72;"	d	file:
CONNECT	ss/machine.c	81;"	d	file:
CONNECT	ss/machine.c	90;"	d	file:
CONNECT	ss/machine.h	236;"	d
CONNECT	ss/ss_isa.c	49;"	d	file:
CONNECT	ss/ss_isa.c	60;"	d	file:
CONST	infeasible.h	45;"	d
CPU_MHZ	common.h	60;"	d
CTRL_CALL	cfg.h	/^typedef enum {CTRL_SEQ, CTRL_COND, CTRL_UNCOND, CTRL_CALL, CTRL_RET} bb_type_t;$/;"	e	enum:__anon2
CTRL_COND	cfg.h	/^typedef enum {CTRL_SEQ, CTRL_COND, CTRL_UNCOND, CTRL_CALL, CTRL_RET} bb_type_t;$/;"	e	enum:__anon2
CTRL_RET	cfg.h	/^typedef enum {CTRL_SEQ, CTRL_COND, CTRL_UNCOND, CTRL_CALL, CTRL_RET} bb_type_t;$/;"	e	enum:__anon2
CTRL_SEQ	cfg.h	/^typedef enum {CTRL_SEQ, CTRL_COND, CTRL_UNCOND, CTRL_CALL, CTRL_RET} bb_type_t;$/;"	e	enum:__anon2
CTRL_UNCOND	cfg.h	/^typedef enum {CTRL_SEQ, CTRL_COND, CTRL_UNCOND, CTRL_CALL, CTRL_RET} bb_type_t;$/;"	e	enum:__anon2
DATA_MISS_PENALTY	cache.h	143;"	d
DC_HIT	cache.h	56;"	d
DC_MISS	cache.h	57;"	d
DC_STORE	cache.h	59;"	d
DC_UNCLEAR	cache.h	58;"	d
DEBUG_INFEAS	main.c	/^char DEBUG_INFEAS = 0;$/;"	v
DECODE_CFG_H	ss/decode_cfg.h	24;"	d
DEFINST	ss/machine.c	113;"	d	file:
DEFINST	ss/machine.c	565;"	d	file:
DEFINST	ss/machine.c	70;"	d	file:
DEFINST	ss/machine.c	79;"	d	file:
DEFINST	ss/machine.c	88;"	d	file:
DEFINST	ss/machine.h	234;"	d
DEFINST	ss/ss_isa.c	192;"	d	file:
DEFINST	ss/ss_isa.c	198;"	d	file:
DEFINST	ss/ss_isa.c	47;"	d	file:
DEFINST	ss/ss_isa.c	58;"	d	file:
DEFLINK	ss/machine.c	114;"	d	file:
DEFLINK	ss/machine.c	71;"	d	file:
DEFLINK	ss/machine.c	80;"	d	file:
DEFLINK	ss/machine.c	89;"	d	file:
DEFLINK	ss/machine.h	235;"	d
DEFLINK	ss/ss_isa.c	48;"	d	file:
DEFLINK	ss/ss_isa.c	59;"	d	file:
DEF_DERI	infeasible.h	48;"	d
DEF_VAL	infeasible.h	47;"	d
DERI_LEN	infeasible.h	52;"	d
DERI_LEN	symexec.h	39;"	d
DFCC	ss/decode_cfg.h	47;"	d
DFCC	ss/ss_isa.h	45;"	d
DFPCR	ss/decode_cfg.h	59;"	d
DFPCR	ss/ss_isa.h	57;"	d
DFPR	ss/decode_cfg.h	56;"	d
DFPR	ss/ss_isa.h	54;"	d
DFPR_D	ss/decode_cfg.h	42;"	d
DFPR_D	ss/ss_isa.h	40;"	d
DFPR_F	ss/decode_cfg.h	41;"	d
DFPR_F	ss/ss_isa.h	39;"	d
DFPR_L	ss/decode_cfg.h	40;"	d
DFPR_L	ss/ss_isa.h	38;"	d
DGPR	ss/decode_cfg.h	36;"	d
DGPR	ss/decode_cfg.h	53;"	d
DGPR	ss/ss_isa.h	34;"	d
DGPR	ss/ss_isa.h	51;"	d
DGPR_D	ss/decode_cfg.h	37;"	d
DGPR_D	ss/ss_isa.h	35;"	d
DHI	ss/decode_cfg.h	45;"	d
DHI	ss/ss_isa.h	43;"	d
DLO	ss/decode_cfg.h	46;"	d
DLO	ss/ss_isa.h	44;"	d
DNA	ss/decode_cfg.h	31;"	d
DNA	ss/ss_isa.h	31;"	d
DOTSEEN	ss/misc.c	448;"	d	file:
DTMP	ss/decode_cfg.h	48;"	d
DTMP	ss/decode_cfg.h	61;"	d
DTMP	ss/ss_isa.h	46;"	d
DTMP	ss/ss_isa.h	59;"	d
DUNIQ	ss/decode_cfg.h	60;"	d
DUNIQ	ss/ss_isa.h	58;"	d
Difference	unicache.c	/^static acs_p Difference(acs_p acs, mem_blk_set_t* mem_blk) {$/;"	f	file:	signature:(acs_p acs, mem_blk_set_t* mem_blk)
Difference	unicache.c	/^static acs_p Difference(acs_p acs, mem_blk_set_t* mem_blk);$/;"	p	file:	signature:(acs_p acs, mem_blk_set_t* mem_blk)
EARLY	estimate.c	30;"	d	file:
ECOFF_EB_MAGIC	ss/ecoff.h	104;"	d
ECOFF_EL_MAGIC	ss/ecoff.h	105;"	d
ECOFF_H	ss/ecoff.h	102;"	d
ECOFF_R_SN_BSS	ss/ecoff.h	238;"	d
ECOFF_R_SN_DATA	ss/ecoff.h	235;"	d
ECOFF_R_SN_RDATA	ss/ecoff.h	234;"	d
ECOFF_R_SN_SBSS	ss/ecoff.h	237;"	d
ECOFF_R_SN_SDATA	ss/ecoff.h	236;"	d
ECOFF_R_SN_TEXT	ss/ecoff.h	233;"	d
ECOFF_STYP_BSS	ss/ecoff.h	245;"	d
ECOFF_STYP_DATA	ss/ecoff.h	242;"	d
ECOFF_STYP_RDATA	ss/ecoff.h	241;"	d
ECOFF_STYP_SBSS	ss/ecoff.h	244;"	d
ECOFF_STYP_SDATA	ss/ecoff.h	243;"	d
ECOFF_STYP_TEXT	ss/ecoff.h	240;"	d
ECOFF_magicSym	ss/ecoff.h	173;"	d
ECOFF_stBlock	ss/ecoff.h	254;"	d
ECOFF_stConstant	ss/ecoff.h	262;"	d
ECOFF_stEnd	ss/ecoff.h	255;"	d
ECOFF_stFile	ss/ecoff.h	258;"	d
ECOFF_stForward	ss/ecoff.h	260;"	d
ECOFF_stGlobal	ss/ecoff.h	248;"	d
ECOFF_stLabel	ss/ecoff.h	252;"	d
ECOFF_stLocal	ss/ecoff.h	251;"	d
ECOFF_stMember	ss/ecoff.h	256;"	d
ECOFF_stNil	ss/ecoff.h	247;"	d
ECOFF_stParam	ss/ecoff.h	250;"	d
ECOFF_stProc	ss/ecoff.h	253;"	d
ECOFF_stRegReloc	ss/ecoff.h	259;"	d
ECOFF_stStatic	ss/ecoff.h	249;"	d
ECOFF_stStaticProc	ss/ecoff.h	261;"	d
ECOFF_stTypedef	ss/ecoff.h	257;"	d
EG_COND_EDGE	exegraph.h	/^enum { EG_NORM_EDGE, EG_COND_EDGE };$/;"	e	enum:__anon29
EG_DEP_COND	exegraph.h	/^enum { EG_DEP_NONE, EG_DEP_NORM, EG_DEP_COND };$/;"	e	enum:__anon31
EG_DEP_NONE	exegraph.h	/^enum { EG_DEP_NONE, EG_DEP_NORM, EG_DEP_COND };$/;"	e	enum:__anon31
EG_DEP_NORM	exegraph.h	/^enum { EG_DEP_NONE, EG_DEP_NORM, EG_DEP_COND };$/;"	e	enum:__anon31
EG_NORM_EDGE	exegraph.h	/^enum { EG_NORM_EDGE, EG_COND_EDGE };$/;"	e	enum:__anon29
ELOG_CODE	pipeline.h	29;"	d
END_BBB_ID	bpred.h	38;"	d
EPILOG_SIZE	ss/my_opt.c	/^int PROLOG_SIZE, EPILOG_SIZE;$/;"	v
EQ	infeasible.h	69;"	d
EQL_LB	loops.h	42;"	d
EQUAL	address.c	1618;"	d	file:
EQUAL_TS	scp_address.h	22;"	d
ERR_BADCONST	ss/eval.h	/^  ERR_BADCONST,			\/* badly formed constant *\/$/;"	e	enum:eval_err_t
ERR_BADEXPR	ss/eval.h	/^  ERR_BADEXPR,			\/* badly formed constant *\/$/;"	e	enum:eval_err_t
ERR_DIV0	ss/eval.h	/^  ERR_DIV0,			\/* divide by zero *\/$/;"	e	enum:eval_err_t
ERR_EXTRA	ss/eval.h	/^  ERR_EXTRA,			\/* extra characters at end of expression *\/$/;"	e	enum:eval_err_t
ERR_NOERR	ss/eval.h	/^  ERR_NOERR,			\/* no error *\/$/;"	e	enum:eval_err_t
ERR_NOTERM	ss/eval.h	/^  ERR_NOTERM,			\/* expression term is missing *\/$/;"	e	enum:eval_err_t
ERR_NUM	ss/eval.h	/^  ERR_NUM$/;"	e	enum:eval_err_t
ERR_UNDEFVAR	ss/eval.h	/^  ERR_UNDEFVAR,			\/* variable is undefined *\/$/;"	e	enum:eval_err_t
ERR_UPAREN	ss/eval.h	/^  ERR_UPAREN,			\/* unmatched parenthesis *\/$/;"	e	enum:eval_err_t
EVAL_H	ss/eval.h	53;"	d
EVAL_INTEGRAL	ss/eval.h	131;"	d
EVAL_INTEGRAL	ss/eval.h	135;"	d
EVICTED	scp_cache.h	18;"	d
EXE_GRAPH_H	exegraph.h	23;"	d
FALL	infeasible.h	57;"	d
FALSE	ss/misc.h	68;"	d
FD	ss/machine.h	314;"	d
FF	infeasible.h	62;"	d
FJ	infeasible.h	61;"	d
FLAG_HIT	pipeline.h	33;"	d
FLAG_L2HIT	pipeline.h	34;"	d
FLAG_NC	pipeline.h	35;"	d
FS	ss/machine.h	312;"	d
FT	ss/machine.h	313;"	d
FUClass_NA	ss/machine.h	/^  FUClass_NA = 0,	\/* inst does not use a functional unit *\/$/;"	e	enum:md_fu_class
FU_FPALU_INDEX	ss/my_opt.c	175;"	d	file:
FU_FPMULT_INDEX	ss/my_opt.c	176;"	d	file:
FU_IALU_INDEX	ss/my_opt.c	172;"	d	file:
FU_IMULT_INDEX	ss/my_opt.c	173;"	d	file:
FU_MEMPORT_INDEX	ss/my_opt.c	174;"	d	file:
F_CALL	ss/machine.h	294;"	d
F_COND	ss/machine.h	283;"	d
F_CTRL	ss/machine.h	281;"	d
F_DIRECT	ss/machine.h	289;"	d
F_DIRJMP	ss/machine.h	292;"	d
F_DISP	ss/machine.h	287;"	d
F_FCOMP	ss/machine.h	280;"	d
F_FPCOND	ss/machine.h	295;"	d
F_ICOMP	ss/machine.h	279;"	d
F_IMM	ss/machine.h	296;"	d
F_INDIRJMP	ss/machine.h	293;"	d
F_LOAD	ss/machine.h	285;"	d
F_LONGLAT	ss/machine.h	291;"	d
F_MEM	ss/machine.h	284;"	d
F_RR	ss/machine.h	288;"	d
F_STORE	ss/machine.h	286;"	d
F_TRAP	ss/machine.h	290;"	d
F_UNCOND	ss/machine.h	282;"	d
FloatADD	ss/machine.h	/^  FloatADD,		\/* floating point adder\/subtractor *\/$/;"	e	enum:md_fu_class
FloatCMP	ss/machine.h	/^  FloatCMP,		\/* floating point comparator *\/$/;"	e	enum:md_fu_class
FloatCVT	ss/machine.h	/^  FloatCVT,		\/* floating point<->integer converter *\/$/;"	e	enum:md_fu_class
FloatDIV	ss/machine.h	/^  FloatDIV,		\/* floating point divider *\/$/;"	e	enum:md_fu_class
FloatMULT	ss/machine.h	/^  FloatMULT,		\/* floating point multiplier *\/$/;"	e	enum:md_fu_class
FloatSQRT	ss/machine.h	/^  FloatSQRT,		\/* floating point square root *\/$/;"	e	enum:md_fu_class
GAG	bpred.h	/^enum bpred_scheme_t	{ NO_BPRED, GAG, GSHARE, LOCAL };$/;"	e	enum:bpred_scheme_t
GE	infeasible.h	66;"	d
GET_MEM	address.h	19;"	d
GET_SET	cache.h	146;"	d
GLOBAL_START	address.h	10;"	d
GOOD_RANGE	common.h	33;"	d
GSHARE	bpred.h	/^enum bpred_scheme_t	{ NO_BPRED, GAG, GSHARE, LOCAL };$/;"	e	enum:bpred_scheme_t
GT	infeasible.h	65;"	d
HEAP_ELEMS	common.h	38;"	d
HI	address.h	7;"	d
HIBITL	ss/misc.c	395;"	d	file:
HIBITL	ss/misc.c	399;"	d	file:
HOST_H	ss/host.h	53;"	d
HOST_HAS_QWORD	ss/host.h	106;"	d
HOST_HAS_QWORD	ss/host.h	117;"	d
HOST_HAS_QWORD	ss/host.h	123;"	d
HOST_HAS_QWORD	ss/host.h	95;"	d
IC_CATEGORIZE	cache.h	/^enum { IC_ILP, IC_CATEGORIZE };$/;"	e	enum:__anon25
IC_HIT	cache.h	51;"	d
IC_ILP	cache.h	/^enum { IC_ILP, IC_CATEGORIZE };$/;"	e	enum:__anon25
IC_MISS	cache.h	52;"	d
IC_NONE	ilp.c	85;"	d	file:
IC_UNCLEAR	cache.h	53;"	d
IMM	ss/machine.h	317;"	d
INFINITY	address.h	17;"	d
INFTY	common.h	39;"	d
INLINE	ss/host.h	61;"	d
INLINE	ss/host.h	63;"	d
INLINE	ss/host.h	65;"	d
INNER_MOST	loops.h	63;"	d
INSIDE	common.h	50;"	d
INSN_LEN	infeasible.h	53;"	d
INST_CALL	isa.h	/^    INST_CALL,$/;"	e	enum:inst_type_t
INST_COND	isa.h	/^    INST_COND,$/;"	e	enum:inst_type_t
INST_FCOMP	isa.h	/^    INST_FCOMP,	    \/\/ floating-point arithmetic instr.$/;"	e	enum:inst_type_t
INST_ICOMP	isa.h	/^    INST_ICOMP,	    \/\/ integer arithmetic instr.$/;"	e	enum:inst_type_t
INST_LOAD	isa.h	/^    INST_LOAD,$/;"	e	enum:inst_type_t
INST_NOP	isa.h	/^    INST_NOP = 0,   \/\/ instr. doing nothing$/;"	e	enum:inst_type_t
INST_RET	isa.h	/^    INST_RET,$/;"	e	enum:inst_type_t
INST_STORE	isa.h	/^    INST_STORE,$/;"	e	enum:inst_type_t
INST_TRAP	isa.h	/^    INST_TRAP$/;"	e	enum:inst_type_t
INST_UNCOND	isa.h	/^    INST_UNCOND,$/;"	e	enum:inst_type_t
INVALID	infeasible.h	43;"	d
INV_LB	loops.h	43;"	d
ISA_H	isa.h	23;"	d
ISA_SS_H	ss/ss_isa.h	23;"	d
IntALU	ss/machine.h	/^  IntALU,		\/* integer ALU *\/$/;"	e	enum:md_fu_class
IntDIV	ss/machine.h	/^  IntDIV,		\/* integer divider *\/$/;"	e	enum:md_fu_class
IntMULT	ss/machine.h	/^  IntMULT,		\/* integer multiplier *\/$/;"	e	enum:md_fu_class
Intersect	unicache.c	/^static acs_p Intersect(acs_p acs1, acs_p acs2) {$/;"	f	file:	signature:(acs_p acs1, acs_p acs2)
JF	infeasible.h	60;"	d
JJ	infeasible.h	59;"	d
JUMP	infeasible.h	56;"	d
JoinCacheState	unicache.c	/^static void JoinCacheState(tcfg_node_t* pred, tcfg_node_t* bbi, int type) {$/;"	f	file:	signature:(tcfg_node_t* pred, tcfg_node_t* bbi, int type)
JoinPredAloc	address.c	/^static void JoinPredAloc(tcfg_node_t* succ, tcfg_node_t* bbi, int* change_flag)$/;"	f	file:	signature:(tcfg_node_t* succ, tcfg_node_t* bbi, int* change_flag)
KO	infeasible.h	75;"	d
L1_DCACHE_ANALYSIS	scp_cache.h	7;"	d
L1_MISS_PENALTY	cache.h	144;"	d
L2_DCACHE_ANALYSIS	scp_cache.h	8;"	d
L2_MISS_PENALTY	cache.h	145;"	d
LATE	estimate.c	29;"	d	file:
LE	infeasible.h	68;"	d
LENGTH	ss/misc.c	449;"	d	file:
LL	ss/host.h	100;"	d
LL	ss/host.h	103;"	d
LL	ss/host.h	111;"	d
LL	ss/host.h	114;"	d
LL	ss/host.h	121;"	d
LLHIGH	ss/misc.h	80;"	d
LLLOW	ss/misc.h	81;"	d
LL_MAX	ss/misc.c	787;"	d	file:
LL_MIN	ss/misc.c	788;"	d	file:
LO	address.h	8;"	d
LOADER_H	ss/loader.h	53;"	d
LOCAL	bpred.h	/^enum bpred_scheme_t	{ NO_BPRED, GAG, GSHARE, LOCAL };$/;"	e	enum:bpred_scheme_t
LOOPS_H	loops.h	25;"	d
LOOP_ANALYZED	loops.h	37;"	d
LOOP_ENTRY	loops.h	33;"	d
LOOP_EXIT	loops.h	34;"	d
LOOP_HEAD	cfg.h	33;"	d
LOOP_TAIL	cfg.h	34;"	d
LSB_OFF	cache.h	39;"	d
LSB_ON	cache.h	40;"	d
LSQ_size	ss/my_opt.c	/^int LSQ_size = 8;$/;"	v
LT	infeasible.h	67;"	d
LZERO	ss/misc.c	447;"	d	file:
MAX	ss/misc.h	73;"	d
MAXDIGS	ss/misc.c	453;"	d	file:
MAXINT_VAL	ss/machine.h	335;"	d
MAX_A	scp_cache.h	19;"	d
MAX_BB	common.h	35;"	d
MAX_CACHE_SET	cache.h	141;"	d
MAX_CACHE_SETS	cache.h	25;"	d
MAX_EG_EDGES	exegraph.h	32;"	d
MAX_EG_LEN	exegraph.h	31;"	d
MAX_EXPR_LEN	symexec.h	113;"	d
MAX_FILENAME_LEN	ss/options.c	1197;"	d	file:
MAX_INST	common.h	34;"	d
MAX_INSTS_PER_CLASS	ss/resource.h	61;"	d
MAX_ITERS	estimate.c	33;"	d	file:
MAX_LINE_ARGS	ss/options.c	1196;"	d	file:
MAX_LOOP_NEST	loops.h	31;"	d
MAX_NO_REGISTERS	address.h	6;"	d
MAX_OVRL_NODES	cfg.h	122;"	d
MAX_REGS	pipeline.c	108;"	d	file:
MAX_RES_CLASSES	ss/resource.h	58;"	d
MAX_SSCALAR	pipeline.h	31;"	d
MAX_TAG_BITS	cache.h	31;"	d
MAX_VARS	ss/options.c	1715;"	d	file:
MAY	cache.h	/^	MAY,$/;"	e	enum:ANALYSIS
MBLK_ID	cache.h	43;"	d
MBLK_ID_L2	cache.h	49;"	d
MC_INC_SIZE	cache.h	54;"	d
MD_AGEN_OP	ss/machine.h	645;"	d
MD_AMODE_POSTPROBE	ss/machine.h	477;"	d
MD_AMODE_PREPROBE	ss/machine.h	451;"	d
MD_AMODE_PROBE	ss/machine.h	455;"	d
MD_BR_SHIFT	ss/machine.h	663;"	d
MD_CROSS_ENDIAN	ss/machine.h	82;"	d
MD_CROSS_ENDIAN	ss/machine.h	85;"	d
MD_DATA_BASE	ss/machine.h	212;"	d
MD_EIO_FILE_FORMAT	ss/machine.h	486;"	d
MD_EXIT_SYSCALL	ss/machine.h	416;"	d
MD_EXO_CMP_IREG	ss/machine.h	539;"	d
MD_EXO_TO_FREG	ss/machine.h	536;"	d
MD_EXO_TO_IREG	ss/machine.h	533;"	d
MD_EXO_TO_MISC_REGS	ss/machine.h	504;"	d
MD_FETCH_INST	ss/machine.h	202;"	d
MD_FIRST_IN_REG	ss/machine.h	542;"	d
MD_FIRST_OUT_REG	ss/machine.h	545;"	d
MD_FREG_TO_EXO	ss/machine.h	501;"	d
MD_FU_NAME	ss/machine.h	275;"	d
MD_INST_SIZE	infeasible.c	37;"	d	file:
MD_IREG_TO_EXO	ss/machine.h	498;"	d
MD_IS_CALL	ss/machine.h	429;"	d
MD_IS_INDIR	ss/machine.h	436;"	d
MD_IS_RETURN	ss/machine.h	433;"	d
MD_LAST_IN_REG	ss/machine.h	543;"	d
MD_LAST_OUT_REG	ss/machine.h	546;"	d
MD_LOG_PAGE_SIZE	ss/machine.h	108;"	d
MD_MAX_ENVIRON	ss/machine.h	216;"	d
MD_MAX_MASK	ss/machine.h	229;"	d
MD_MISC_REGS_TO_EXO	ss/machine.h	488;"	d
MD_NOP_INST	ss/machine.c	/^md_inst_t MD_NOP_INST = { NOP, 0 };$/;"	v
MD_NOP_OP	ss/machine.h	648;"	d
MD_NUM_CREGS	ss/machine.h	138;"	d
MD_NUM_FREGS	ss/machine.h	135;"	d
MD_NUM_IREGS	ss/machine.h	132;"	d
MD_OPFIELD	ss/machine.h	224;"	d
MD_OP_ENUM	ss/machine.h	242;"	d
MD_OP_FLAGS	ss/machine.h	299;"	d
MD_OP_FORMAT	ss/machine.h	250;"	d
MD_OP_FUCLASS	ss/machine.h	271;"	d
MD_OP_NAME	ss/machine.h	246;"	d
MD_OUTPUT_SYSCALL	ss/machine.h	420;"	d
MD_PAGE_SIZE	ss/machine.h	107;"	d
MD_QWORD_ADDRS	ss/machine.h	96;"	d
MD_REG_FP	ss/machine.h	/^  MD_REG_FP = 30	\/* frame pointer *\/$/;"	e	enum:md_reg_names
MD_REG_GP	ss/machine.h	/^  MD_REG_GP = 28,	\/* global data section pointer *\/$/;"	e	enum:md_reg_names
MD_REG_SP	ss/machine.h	/^  MD_REG_SP = 29,	\/* stack pointer *\/$/;"	e	enum:md_reg_names
MD_REG_ZERO	ss/machine.h	/^  MD_REG_ZERO = 0,	\/* zero register *\/$/;"	e	enum:md_reg_names
MD_SET_OPCODE	ss/machine.h	225;"	d
MD_STACK_BASE	ss/machine.h	213;"	d
MD_STREAM_FILENO	ss/machine.h	426;"	d
MD_SWAPD	ss/machine.h	196;"	d
MD_SWAPH	ss/machine.h	185;"	d
MD_SWAPH	ss/machine.h	193;"	d
MD_SWAPI	ss/machine.h	188;"	d
MD_SWAPI	ss/machine.h	197;"	d
MD_SWAPQ	ss/machine.h	187;"	d
MD_SWAPQ	ss/machine.h	195;"	d
MD_SWAPW	ss/machine.h	186;"	d
MD_SWAPW	ss/machine.h	194;"	d
MD_TEXT_BASE	ss/machine.h	211;"	d
MD_TOTAL_REGS	ss/machine.h	141;"	d
MD_VALID_ADDR	ss/machine.h	652;"	d
MIN	ss/misc.h	76;"	d
MINUS	ilp.c	2358;"	d	file:
MINUS	ilp.c	80;"	d	file:
MIN_VAL	symexec.c	42;"	d	file:
MISC_H	ss/misc.h	53;"	d
MUST	cache.h	/^	MUST = 0,$/;"	e	enum:ANALYSIS
NA	infeasible.h	71;"	d
NA	ss/machine.h	89;"	d
NE	infeasible.h	70;"	d
NIL	infeasible.h	76;"	d
NONE	infeasible.h	55;"	d
NOSIGN	ilp.c	78;"	d	file:
NOT_CLASSIFIED	cache.h	/^	NOT_CLASSIFIED$/;"	e	enum:ACCESS
NOT_TAKEN	cfg.h	30;"	d
NO_BPRED	bpred.h	/^enum bpred_scheme_t	{ NO_BPRED, GAG, GSHARE, LOCAL };$/;"	e	enum:bpred_scheme_t
NO_DELAY	exegraph.h	/^enum { BI_DELAY, UNI_DELAY, NO_DELAY };$/;"	e	enum:__anon30
NO_PREFIX	ilp.c	81;"	d	file:
NO_REG	symexec.h	36;"	d
NO_SUFFIX	ilp.c	82;"	d	file:
NUM_FLAGS	ss/options.c	606;"	d	file:
NUM_FU_CLASSES	ss/machine.h	/^  NUM_FU_CLASSES	\/* total functional unit classes *\/$/;"	e	enum:md_fu_class
NUM_PFU_CLASSES	ss/ss_machine.h	/^    NUM_PFU_CLASSES$/;"	e	enum:ss_pfu_class
NUM_VAR_GRP	ilp.c	126;"	d	file:
N_ELT	ss/misc.h	84;"	d
OBJ	Makefile	/^OBJ=$(SRC:.c=.o)$/;"	m
OFS	ss/machine.h	329;"	d
OLAP_TS	scp_address.h	23;"	d
OPT	cfg.h	123;"	d
OPTIONS_H	ss/options.h	53;"	d
OP_LEN	infeasible.h	51;"	d
OP_MAX	ss/machine.h	/^  OP_MAX	\/* number of opcodes + NA *\/$/;"	e	enum:md_opcode
OP_NA	ss/machine.h	/^  OP_NA = 0,	\/* NA *\/$/;"	e	enum:md_opcode
OVER	ss/machine.h	338;"	d
Olap	dump.c	/^int Olap(sblk_p acsBlk, worklist_p acsSet, loop_t *lp) {$/;"	f	signature:(sblk_p acsBlk, worklist_p acsSet, loop_t *lp)
PAD	ss/misc.c	385;"	d	file:
PADZERO	ss/misc.c	445;"	d	file:
PEERS_WIN	estimate.c	202;"	d	file:
PENALTY	cache.h	147;"	d
PERSISTENCE	cache.h	/^	PERSISTENCE	  $/;"	e	enum:ANALYSIS
PIPE_LINE_H	pipeline.h	23;"	d
PISA_H	ss/machine.h	53;"	d
PLOG_CODE	pipeline.h	28;"	d
PLUS	ilp.c	2357;"	d	file:
PLUS	ilp.c	79;"	d	file:
POLYNOMIAL	ss/misc.c	1148;"	d	file:
PRIORITY_QUEUE	common.h	112;"	d
PROCESS_LOAD	symexec.c	738;"	d	file:
PROCESS_SLT	symexec.c	761;"	d	file:
PROCESS_SLTI	symexec.c	752;"	d	file:
PROCESS_STORE	symexec.c	725;"	d	file:
PROGRESS_STEP	main.c	/^int PROGRESS_STEP = 10000;$/;"	v
PROLOG_SIZE	ss/my_opt.c	/^int PROLOG_SIZE, EPILOG_SIZE;$/;"	v
PS	cache.h	/^	PS,$/;"	e	enum:ACCESS
PSEUDO	cache.h	142;"	d
PS_join_Old	dump.c	/^int PS_join_Old(scp_acs src, scp_acs dst ) {$/;"	f	signature:(scp_acs src, scp_acs dst )
PS_update_Old	dump.c	/^void PS_update_Old(scp_acs acs_out, worklist_p addr_set,  loop_t *curLoop) {$/;"	f	signature:(scp_acs acs_out, worklist_p addr_set, loop_t *curLoop)
PUT	ss/misc.c	374;"	d	file:
P_FP_Adder	ss/ss_machine.h	/^    P_FP_Adder,$/;"	e	enum:ss_pfu_class
P_FP_Mult_Div	ss/ss_machine.h	/^    P_FP_Mult_Div,$/;"	e	enum:ss_pfu_class
P_FUClass_NA	ss/ss_machine.h	/^    P_FUClass_NA = 0,$/;"	e	enum:ss_pfu_class
P_IntALU	ss/ss_machine.h	/^    P_IntALU,$/;"	e	enum:ss_pfu_class
P_Int_Mult_Div	ss/ss_machine.h	/^    P_Int_Mult_Div,$/;"	e	enum:ss_pfu_class
P_Mem_Port	ss/ss_machine.h	/^    P_Mem_Port,$/;"	e	enum:ss_pfu_class
P_Queue	common.h	/^} P_Queue;$/;"	t	typeref:struct:priority_queue_t
QUEUE	common.h	102;"	d
QUEUE_ELEMS	common.h	37;"	d
Queue	common.h	/^} Queue;$/;"	t	typeref:struct:queue_t
RD	ss/machine.h	306;"	d
REGS_H	ss/regs.h	53;"	d
REG_ADDRESS_H	scp_address.h	2;"	d
REG_END	address.h	21;"	d
REG_GLOBAL	address.h	23;"	d
REG_RETURN	infeasible.h	36;"	d
REG_STACK	address.h	22;"	d
REG_START	address.h	20;"	d
RELEVANT_SCOPE	ss/symbol.c	201;"	d	file:
RENEWABLE	scp_address.h	38;"	d
RESET_FLAG	common.h	54;"	d
RESOURCE_H	ss/resource.h	53;"	d
RETURN_ADDRESS	address.h	11;"	d
ROOT_BBB_ID	bpred.h	37;"	d
ROUND_DOWN	ss/misc.h	88;"	d
ROUND_UP	ss/misc.h	87;"	d
RS	ss/machine.h	303;"	d
RS	ss/machine.h	304;"	d
RT	ss/machine.h	305;"	d
RUU_size	ss/my_opt.c	/^int RUU_size = 8;$/;"	v
RZERO	ss/misc.c	446;"	d	file:
RdPort	ss/machine.h	/^  RdPort,		\/* memory read port *\/$/;"	e	enum:md_fu_class
SBLK_DONE	scp_cache.h	12;"	d
SBLK_FREE	scp_cache.h	11;"	d
SELF_CONFLICT	scp_address.h	37;"	d
SEP_TS	scp_address.h	24;"	d
SET	cache.h	35;"	d
SET_FLAG	common.h	53;"	d
SET_L2	cache.h	47;"	d
SET_TPC	ss/machine.h	349;"	d
SHADED	estimate.c	34;"	d	file:
SHAMT	ss/machine.h	309;"	d
SHOW_PROGRESS	common.h	30;"	d
SIZE_OF_BLOCK	address.h	16;"	d
SIZE_OF_BYTE	address.h	13;"	d
SIZE_OF_HALF_WORD	address.h	15;"	d
SIZE_OF_WORD	address.h	14;"	d
SLT	infeasible.h	78;"	d
SLTI	infeasible.h	77;"	d
SRC	Makefile	/^SRC=main.c common.c isa.c readfile.c cfg.c tcfg.c loops.c options.c \\$/;"	m
SS_MaCHINE_H	ss/ss_machine.h	23;"	d
SS_SRC	Makefile	/^SS_SRC=$(wildcard ss\/*.c)$/;"	m
SS_SYS_exit	ss/machine.h	415;"	d
SS_SYS_write	ss/machine.h	419;"	d
STACK_ELEMS	common.h	36;"	d
STACK_START	address.h	9;"	d
STAGE_CM	ss/ss_machine.h	/^enum { STAGE_IF, STAGE_ID, STAGE_EX, STAGE_WB, STAGE_CM };$/;"	e	enum:__anon20
STAGE_EX	ss/ss_machine.h	/^enum { STAGE_IF, STAGE_ID, STAGE_EX, STAGE_WB, STAGE_CM };$/;"	e	enum:__anon20
STAGE_ID	ss/ss_machine.h	/^enum { STAGE_IF, STAGE_ID, STAGE_EX, STAGE_WB, STAGE_CM };$/;"	e	enum:__anon20
STAGE_IF	ss/ss_machine.h	/^enum { STAGE_IF, STAGE_ID, STAGE_EX, STAGE_WB, STAGE_CM };$/;"	e	enum:__anon20
STAGE_WB	ss/ss_machine.h	/^enum { STAGE_IF, STAGE_ID, STAGE_EX, STAGE_WB, STAGE_CM };$/;"	e	enum:__anon20
STEP_EST	estimate.c	32;"	d	file:
STEP_SEP	estimate.c	31;"	d	file:
SYMBOL_H	ss/symbol.h	53;"	d
SYMCAT	ss/host.h	71;"	d
SYMCAT	ss/host.h	75;"	d
SYMCAT	ss/host.h	77;"	d
SYM_EXEC_H	symexec.h	33;"	d
Stack	common.h	/^} Stack;$/;"	t	typeref:struct:stack_t
TAG	cache.h	36;"	d
TAGSET	cache.h	37;"	d
TAGSET2	cache.h	38;"	d
TAGSET_L2	cache.h	45;"	d
TAG_L2	cache.h	48;"	d
TAKEN	cfg.h	31;"	d
TARG	ss/machine.h	323;"	d
TARGET_PISA	ss/machine.h	67;"	d
TARGET_PISA_BIG	ss/machine.h	73;"	d
TARGET_PISA_LITTLE	ss/machine.h	75;"	d
TARGET_SS	common.h	28;"	d
TCFG_H	tcfg.h	26;"	d
TCFG_STEP_SIZE	tcfg.h	36;"	d
TEST_FLAG	common.h	55;"	d
TEXT_TAIL_PADDING	ss/loader.c	63;"	d	file:
TEXT_TAIL_PADDING	ss/ss_readfile.c	37;"	d	file:
TRUE	ss/misc.h	65;"	d
UIMM	ss/machine.h	320;"	d
ULL	ss/host.h	102;"	d
ULL	ss/host.h	110;"	d
ULL	ss/host.h	113;"	d
ULL	ss/host.h	120;"	d
ULL	ss/host.h	99;"	d
ULL_MAX	ss/misc.c	789;"	d	file:
UNDER	ss/machine.h	343;"	d
UNIFIED_CACHE_ANALYSIS	scp_cache.h	9;"	d
UNI_DELAY	exegraph.h	/^enum { BI_DELAY, UNI_DELAY, NO_DELAY };$/;"	e	enum:__anon30
UNKNOWN_ADDR	scp_address.h	39;"	d
UNKNOWN_AGE	scp_cache.h	15;"	d
Union	unicache.c	/^static acs_p Union(acs_p acs1, acs_p acs2) {$/;"	f	file:	signature:(acs_p acs1, acs_p acs2)
UnionCacheMem	unicache.c	/^static acs_p UnionCacheMem(acs_p acs1, mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(acs_p acs1, mem_blk_set_t* mem_blk_set)
VALID	infeasible.h	44;"	d
VALUE_BIV	symexec.h	44;"	d
VALUE_CONST	symexec.h	41;"	d
VALUE_EXPR	symexec.h	43;"	d
VALUE_PARA	symexec.h	42;"	d
VALUE_UNDEF	symexec.h	40;"	d
VALUE_UNPRED	symexec.h	45;"	d
VAR	infeasible.h	46;"	d
VAR_GRP_SIZE	ilp.c	127;"	d	file:
V_END_ID	tcfg.h	35;"	d
V_START_ID	tcfg.h	34;"	d
WIDENING_POINT	address.h	18;"	d
WL_BASE	ss/machine.h	355;"	d
WL_BASE	ss/machine.h	369;"	d
WL_PROT_MASK	ss/machine.h	356;"	d
WL_PROT_MASK	ss/machine.h	370;"	d
WL_PROT_MASK1	ss/machine.h	357;"	d
WL_PROT_MASK1	ss/machine.h	371;"	d
WL_PROT_MASK2	ss/machine.h	358;"	d
WL_PROT_MASK2	ss/machine.h	372;"	d
WL_SIZE	ss/machine.h	354;"	d
WL_SIZE	ss/machine.h	368;"	d
WRITE_THRU	scp_cache.h	53;"	d
WR_BASE	ss/machine.h	362;"	d
WR_BASE	ss/machine.h	376;"	d
WR_PROT_MASK	ss/machine.h	363;"	d
WR_PROT_MASK	ss/machine.h	377;"	d
WR_PROT_MASK1	ss/machine.h	364;"	d
WR_PROT_MASK1	ss/machine.h	378;"	d
WR_PROT_MASK2	ss/machine.h	365;"	d
WR_PROT_MASK2	ss/machine.h	379;"	d
WR_SIZE	ss/machine.h	361;"	d
WR_SIZE	ss/machine.h	375;"	d
WrPort	ss/machine.h	/^  WrPort,		\/* memory write port *\/$/;"	e	enum:md_fu_class
X	main.c	/^int X, Y, B, l1, l2;$/;"	v
X	unicache.c	/^int X, Y, B;$/;"	v
Y	main.c	/^int X, Y, B, l1, l2;$/;"	v
Y	unicache.c	/^int X, Y, B;$/;"	v
__ADDRESS_H_	address.h	2;"	d
__INFEASIBLE	infeasible.h	23;"	d
__MPA_CACHE_H_	scp_cache.h	2;"	d
__anon10::conflict_dir	infeasible.h	/^  char     conflict_dir;        \/\/ branch direction in the BA conflict: JUMP or FALL$/;"	m	struct:__anon10	access:public
__anon10::conflict_src	infeasible.h	/^  assign_t *conflict_src;$/;"	m	struct:__anon10	access:public
__anon10::nullifier_list	infeasible.h	/^  assign_t **nullifier_list;$/;"	m	struct:__anon10	access:public
__anon10::num_nullifiers	infeasible.h	/^  int      num_nullifiers;$/;"	m	struct:__anon10	access:public
__anon11::conflict_dir	infeasible.h	/^  char     conflict_dir;        \/\/ combination of branch directions in the BB conflict: JJ, JF, FJ, or JJ$/;"	m	struct:__anon11	access:public
__anon11::conflict_src	infeasible.h	/^  branch_t *conflict_src;$/;"	m	struct:__anon11	access:public
__anon11::nullifier_list	infeasible.h	/^  assign_t **nullifier_list;$/;"	m	struct:__anon11	access:public
__anon11::num_nullifiers	infeasible.h	/^  int      num_nullifiers;$/;"	m	struct:__anon11	access:public
__anon12::assignlist	infeasible.h	/^  assign_t   **assignlist;    \/\/ list of assign effects (ptr) in this node$/;"	m	struct:__anon12	access:public
__anon12::bb	infeasible.h	/^  cfg_node_t *bb;$/;"	m	struct:__anon12	access:public
__anon12::branch	infeasible.h	/^  branch_t   *branch;         \/\/ ptr to branch effect associated with this node; NULL if not a branch$/;"	m	struct:__anon12	access:public
__anon12::exec_count	infeasible.h	/^  int        exec_count;      \/\/ constraint for execution count as determined from DFA (-1 if undetermined)$/;"	m	struct:__anon12	access:public
__anon12::insnlist	infeasible.h	/^  insn_t     *insnlist;$/;"	m	struct:__anon12	access:public
__anon12::loop_id	infeasible.h	/^  int        loop_id;$/;"	m	struct:__anon12	access:public
__anon12::loop_role	infeasible.h	/^  int		 loop_role;$/;"	m	struct:__anon12	access:public
__anon12::memListIn	infeasible.h	/^  worklist_p    memListIn;$/;"	m	struct:__anon12	access:public
__anon12::memListOut	infeasible.h	/^  worklist_p    memListOut;$/;"	m	struct:__anon12	access:public
__anon12::num_assign	infeasible.h	/^  int        num_assign;      \/\/ #assign effects in this node$/;"	m	struct:__anon12	access:public
__anon12::num_insn	infeasible.h	/^  int        num_insn;$/;"	m	struct:__anon12	access:public
__anon12::regListIn	infeasible.h	/^  void         *regListIn;  $/;"	m	struct:__anon12	access:public
__anon12::regListOut	infeasible.h	/^  void         *regListOut;$/;"	m	struct:__anon12	access:public
__anon13::inf_cfg	infeasible.h	/^  inf_node_t *inf_cfg;$/;"	m	struct:__anon13	access:public
__anon13::num_bb	infeasible.h	/^  int num_bb;$/;"	m	struct:__anon13	access:public
__anon13::proc	infeasible.h	/^  proc_t *proc;$/;"	m	struct:__anon13	access:public
__anon14::bound	infeasible.h	/^  int bound;              \/\/ constraint for execution count by user-specified loopbound$/;"	m	struct:__anon14	access:public
__anon14::entry	infeasible.h	/^  int entry;              \/\/ block id of loop entry$/;"	m	struct:__anon14	access:public
__anon14::loop_id	infeasible.h	/^  int loop_id;            \/*HBK: id of corresponding loop_t*\/$/;"	m	struct:__anon14	access:public
__anon14::pid	infeasible.h	/^  int pid;                \/\/ procedure id$/;"	m	struct:__anon14	access:public
__anon15::name	isa.h	/^    char    *name;	\/\/ inst name$/;"	m	struct:__anon15	access:public
__anon15::opcode	isa.h	/^    int	    opcode;	\/\/ inst opcode$/;"	m	struct:__anon15	access:public
__anon15::type	isa.h	/^    int	    type;	\/\/ inst type$/;"	m	struct:__anon15	access:public
__anon16::abs_reg	isa.h	/^	 ric_p* 	abs_reg;				\/* Abstract register value at entry point $/;"	m	struct:__anon16	access:public
__anon16::acs_in	isa.h	/^	 acs_p** 	acs_in;		\/* abstract data cache state at the entry $/;"	m	struct:__anon16	access:public
__anon16::acs_out	isa.h	/^	 acs_p** 	acs_out;		\/* abstract data cache state at the exit $/;"	m	struct:__anon16	access:public
__anon16::addr	isa.h	/^    addr_t  addr;$/;"	m	struct:__anon16	access:public
__anon16::data_access	isa.h	/^	 ACCESS_T data_access;		\/* data access classification(hit\/not known) $/;"	m	struct:__anon16	access:public
__anon16::imm	isa.h	/^	 int 		 imm;					\/* Immediate integer value. For base $/;"	m	struct:__anon16	access:public
__anon16::in	isa.h	/^    int	    *in, *out;		   \/* input\/output operands (registers) *\/$/;"	m	struct:__anon16	access:public
__anon16::inst_access	isa.h	/^	 ACCESS_T inst_access;		\/* Instruction access classification *\/$/;"	m	struct:__anon16	access:public
__anon16::l2_inst_access	isa.h	/^	 ACCESS_T l2_inst_access;	\/* L2 Instruction access classification *\/$/;"	m	struct:__anon16	access:public
__anon16::mod_addr	isa.h	/^	 ric_p mod_addr;$/;"	m	struct:__anon16	access:public
__anon16::num_in	isa.h	/^    int	    num_in, num_out;	\/* number of input\/output operands *\/$/;"	m	struct:__anon16	access:public
__anon16::num_out	isa.h	/^    int	    num_in, num_out;	\/* number of input\/output operands *\/$/;"	m	struct:__anon16	access:public
__anon16::op_enum	isa.h	/^    int	    op_enum;	    	\/* continuous numbered opcode $/;"	m	struct:__anon16	access:public
__anon16::out	isa.h	/^    int	    *in, *out;		   \/* input\/output operands (registers) *\/$/;"	m	struct:__anon16	access:public
__anon16::r_addr	isa.h	/^    addr_t  r_addr;$/;"	m	struct:__anon16	access:public
__anon16::size	isa.h	/^    int	    size;$/;"	m	struct:__anon16	access:public
__anon16::target	isa.h	/^    addr_t  target;				\/* target addr for control transfer inst *\/$/;"	m	struct:__anon16	access:public
__anon16::u1_data_access	isa.h	/^	 ACCESS_T u1_data_access;	\/* unified D\/I cache access classification *\/$/;"	m	struct:__anon16	access:public
__anon17::biv	symexec.h	/^	biv_p biv;$/;"	m	struct:__anon17	access:public
__anon17::expr	symexec.h	/^	expr_p expr;$/;"	m	struct:__anon17	access:public
__anon17::flag	symexec.h	/^	int flag;$/;"	m	struct:__anon17	access:public
__anon17::name	symexec.h	/^	char name[4];$/;"	m	struct:__anon17	access:public
__anon17::para	symexec.h	/^	char para[4];$/;"	m	struct:__anon17	access:public
__anon17::t	symexec.h	/^	char t; \/\/ value type: expression, const, induction, parameter$/;"	m	struct:__anon17	access:public
__anon17::val	symexec.h	/^	int val;$/;"	m	struct:__anon17	access:public
__anon18::addrExpr	symexec.h	/^	expr_s addrExpr; \/*Address expression *\/$/;"	m	struct:__anon18	access:public
__anon18::addr_set	symexec.h	/^	worklist_p addr_set; \/*ScopeMem accessed in increasing order*\/$/;"	m	struct:__anon18	access:public
__anon18::insn	symexec.h	/^	void *insn;$/;"	m	struct:__anon18	access:public
__anon18::max_exec	symexec.h	/^	int max_exec; \/*Maximum number of executions*\/$/;"	m	struct:__anon18	access:public
__anon18::max_miss	symexec.h	/^	int max_miss; \/*Maximum estimate cache misses*\/$/;"	m	struct:__anon18	access:public
__anon18::resideLpId	symexec.h	/^	int resideLpId; \/*Loop where this data reference reside*\/$/;"	m	struct:__anon18	access:public
__anon1::bbi	bpred.h	/^    tcfg_node_t	*bbi;$/;"	m	struct:__anon1	access:public
__anon1::bhr	bpred.h	/^    short	bhr;	\/\/ BHR: branch history register$/;"	m	struct:__anon1	access:public
__anon1::flags	bpred.h	/^    int		flags;$/;"	m	struct:__anon1	access:public
__anon1::id	bpred.h	/^    int		id;$/;"	m	struct:__anon1	access:public
__anon1::in	bpred.h	/^    bfg_edge_t	*in;	\/\/ in edges$/;"	m	struct:__anon1	access:public
__anon1::out	bpred.h	/^    bfg_edge_t	*out;	\/\/ out edges$/;"	m	struct:__anon1	access:public
__anon1::pi	bpred.h	/^    short	pi;	\/\/ branch context (bhr manipulated with branch address)$/;"	m	struct:__anon1	access:public
__anon21::cmd	ss/misc.c	/^  char *cmd;$/;"	m	struct:__anon21	file:	access:public
__anon21::ext	ss/misc.c	/^  char *ext;$/;"	m	struct:__anon21	file:	access:public
__anon21::type	ss/misc.c	/^  char *type;$/;"	m	struct:__anon21	file:	access:public
__anon22::d	ss/machine.h	/^  dfloat_t d[MD_NUM_FREGS\/2];	\/* double-prediction floating point view *\/$/;"	m	union:__anon22	access:public
__anon22::f	ss/machine.h	/^  sfloat_t f[MD_NUM_FREGS];	\/* single-precision floating point view *\/$/;"	m	union:__anon22	access:public
__anon22::l	ss/machine.h	/^  sword_t l[MD_NUM_FREGS];	\/* integer word view *\/$/;"	m	union:__anon22	access:public
__anon23::fcc	ss/machine.h	/^  int fcc;			\/* floating point condition codes *\/$/;"	m	struct:__anon23	access:public
__anon23::hi	ss/machine.h	/^  sword_t hi, lo;		\/* multiplier HI\/LO result registers *\/$/;"	m	struct:__anon23	access:public
__anon23::lo	ss/machine.h	/^  sword_t hi, lo;		\/* multiplier HI\/LO result registers *\/$/;"	m	struct:__anon23	access:public
__anon24::a	ss/machine.h	/^  word_t a;		\/* simplescalar opcode (must be unsigned) *\/$/;"	m	struct:__anon24	access:public
__anon24::b	ss/machine.h	/^  word_t b;		\/* simplescalar unsigned immediate fields *\/$/;"	m	struct:__anon24	access:public
__anon26::cmp	cache.h	/^    int		cmp;    \/\/ cache miss penalty$/;"	m	struct:__anon26	access:public
__anon26::l_msk	cache.h	/^    unsigned	l_msk;	\/\/ block mask$/;"	m	struct:__anon26	access:public
__anon26::ls	cache.h	/^    int		ls;	\/\/ cache line size$/;"	m	struct:__anon26	access:public
__anon26::lsb	cache.h	/^    int		lsb;    \/\/ lsb = log(ls)$/;"	m	struct:__anon26	access:public
__anon26::na	cache.h	/^    int		na;$/;"	m	struct:__anon26	access:public
__anon26::ns	cache.h	/^    int		ns;	\/\/ #sets$/;"	m	struct:__anon26	access:public
__anon26::nsb	cache.h	/^    int		nsb;    \/\/ nsb = log(ns)$/;"	m	struct:__anon26	access:public
__anon26::nt	cache.h	/^    int		nt;	\/\/ #tags$/;"	m	struct:__anon26	access:public
__anon26::nt_s	cache.h	/^    int		nt_s;	\/\/ # of tag + set$/;"	m	struct:__anon26	access:public
__anon26::ntb	cache.h	/^    int		ntb;	\/\/ tag bits = log(nt)$/;"	m	struct:__anon26	access:public
__anon26::s_lb	cache.h	/^    int		s_lb;	\/\/ set + line bits$/;"	m	struct:__anon26	access:public
__anon26::s_msk	cache.h	/^    unsigned	s_msk;	\/\/ set mask$/;"	m	struct:__anon26	access:public
__anon26::t_msk	cache.h	/^    unsigned	t_msk;	\/\/ tag mask$/;"	m	struct:__anon26	access:public
__anon26::t_s_msk	cache.h	/^    unsigned	t_s_msk;\/\/ set+tag mask$/;"	m	struct:__anon26	access:public
__anon26::t_sb	cache.h	/^    int		t_sb;	\/\/ tag + set bits$/;"	m	struct:__anon26	access:public
__anon27::set	cache.h	/^    unsigned short  set;    \/\/ cache line$/;"	m	struct:__anon27	access:public
__anon27::tag	cache.h	/^    unsigned short  tag;    \/\/ valid tag$/;"	m	struct:__anon27	access:public
__anon28::tag	cache.h	/^    unsigned short  tag;    \/\/ memory block tag$/;"	m	struct:__anon28	access:public
__anon28::valid	cache.h	/^    unsigned short  valid;  \/\/ valid == 0 means empty mempry block$/;"	m	struct:__anon28	access:public
__anon32::bp_type	exegraph.h	/^    char	    bp_type;		\/\/ BP_CPRED, BP_MPRED, BP_UNCLEAR$/;"	m	struct:__anon32	access:public
__anon32::e_contd	exegraph.h	/^    egraph_edge_t   *e_contd, *l_contd;$/;"	m	struct:__anon32	access:public
__anon32::fin	exegraph.h	/^    range_t	    rdy, str, fin;	\/\/ ready, start, finish$/;"	m	struct:__anon32	access:public
__anon32::flag	exegraph.h	/^    char	    flag;$/;"	m	struct:__anon32	access:public
__anon32::fu	exegraph.h	/^    char	    fu, num_fu;		\/\/ applicable to EX nodes$/;"	m	struct:__anon32	access:public
__anon32::in	exegraph.h	/^    egraph_edge_t   *in, *out;$/;"	m	struct:__anon32	access:public
__anon32::inst	exegraph.h	/^    short	    inst, stage;   $/;"	m	struct:__anon32	access:public
__anon32::l_contd	exegraph.h	/^    egraph_edge_t   *e_contd, *l_contd;$/;"	m	struct:__anon32	access:public
__anon32::lat	exegraph.h	/^    range16_t	    lat;		\/\/ execution latency of EX nodes$/;"	m	struct:__anon32	access:public
__anon32::num_fu	exegraph.h	/^    char	    fu, num_fu;		\/\/ applicable to EX nodes$/;"	m	struct:__anon32	access:public
__anon32::out	exegraph.h	/^    egraph_edge_t   *in, *out;$/;"	m	struct:__anon32	access:public
__anon32::rdy	exegraph.h	/^    range_t	    rdy, str, fin;	\/\/ ready, start, finish$/;"	m	struct:__anon32	access:public
__anon32::stage	exegraph.h	/^    short	    inst, stage;   $/;"	m	struct:__anon32	access:public
__anon32::str	exegraph.h	/^    range_t	    rdy, str, fin;	\/\/ ready, start, finish$/;"	m	struct:__anon32	access:public
__anon33::pred	exegraph.h	/^    short   pred;$/;"	m	struct:__anon33	access:public
__anon33::succ	exegraph.h	/^    short   succ;$/;"	m	struct:__anon33	access:public
__anon34::bbi_id	pipeline.h	/^	short bbi_id;$/;"	m	struct:__anon34	access:public
__anon34::bp_flag	pipeline.h	/^	short bp_flag;$/;"	m	struct:__anon34	access:public
__anon34::dc_flag	pipeline.h	/^	short dc_flag;$/;"	m	struct:__anon34	access:public
__anon34::dc_flag_l2	pipeline.h	/^	short dc_flag_l2;$/;"	m	struct:__anon34	access:public
__anon34::ic_flag	pipeline.h	/^	short ic_flag;$/;"	m	struct:__anon34	access:public
__anon34::ic_flag_l2	pipeline.h	/^	short ic_flag_l2;$/;"	m	struct:__anon34	access:public
__anon34::inst	pipeline.h	/^	de_inst_t *inst;$/;"	m	struct:__anon34	access:public
__anon34::mblk_id	pipeline.h	/^	short mblk_id;$/;"	m	struct:__anon34	access:public
__anon34::mblk_id_l2	pipeline.h	/^	short mblk_id_l2;$/;"	m	struct:__anon34	access:public
__anon35::hi	common.h	/^    int	    lo, hi;$/;"	m	struct:__anon35	access:public
__anon35::lo	common.h	/^    int	    lo, hi;$/;"	m	struct:__anon35	access:public
__anon36::hi	common.h	/^    short int	lo, hi;$/;"	m	struct:__anon36	access:public
__anon36::lo	common.h	/^    short int	lo, hi;$/;"	m	struct:__anon36	access:public
__anon37::hi	common.h	/^    char lo, hi;$/;"	m	struct:__anon37	access:public
__anon37::lo	common.h	/^    char lo, hi;$/;"	m	struct:__anon37	access:public
__anon38::acs_in	tcfg.h	/^	acs_p** acs_in;$/;"	m	struct:__anon38	access:public
__anon38::acs_out	tcfg.h	/^	acs_p** acs_out;$/;"	m	struct:__anon38	access:public
__anon38::address_set	tcfg.h	/^	worklist_p* address_set;$/;"	m	struct:__anon38	access:public
__anon38::addrset_l1	tcfg.h	/^	worklist_p* addrset_l1;$/;"	m	struct:__anon38	access:public
__anon38::addrset_l2	tcfg.h	/^	worklist_p* addrset_l2;$/;"	m	struct:__anon38	access:public
__anon38::anal_count	tcfg.h	/^	int anal_count;$/;"	m	struct:__anon38	access:public
__anon38::bb	tcfg.h	/^	cfg_node_t *bb; \/\/ pointer to the physical basic block$/;"	m	struct:__anon38	access:public
__anon38::dcache_delay	tcfg.h	/^	int dcache_delay; \/* For data cache analysis *\/$/;"	m	struct:__anon38	access:public
__anon38::exec_count	tcfg.h	/^	int exec_count; \/\/ vivy: for infeasible path constraints$/;"	m	struct:__anon38	access:public
__anon38::flags	tcfg.h	/^	unsigned flags;$/;"	m	struct:__anon38	access:public
__anon38::id	tcfg.h	/^	int id; \/\/ global id in tcfg (has nothing to do with its bb id)$/;"	m	struct:__anon38	access:public
__anon38::in	tcfg.h	/^	tcfg_edge_t *in, *out; \/\/ incoming and outgoing edges$/;"	m	struct:__anon38	access:public
__anon38::inst_cache_delay	tcfg.h	/^	int inst_cache_delay; \/* For instruction cache analysis using abstract$/;"	m	struct:__anon38	access:public
__anon38::is_unconditional	tcfg.h	/^	char is_unconditional;$/;"	m	struct:__anon38	access:public
__anon38::loop_id	tcfg.h	/^	int loop_id; \/\/ vivy: for infeasible path constraints$/;"	m	struct:__anon38	access:public
__anon38::max_miss	tcfg.h	/^	int max_miss;$/;"	m	struct:__anon38	access:public
__anon38::mpa_acs_in	tcfg.h	/^	worklist_p* mpa_acs_in;$/;"	m	struct:__anon38	access:public
__anon38::mpa_acs_out	tcfg.h	/^	worklist_p* mpa_acs_out;$/;"	m	struct:__anon38	access:public
__anon38::n_data_persistence	tcfg.h	/^	int n_data_persistence; \/* Number of persistence data blocks *\/$/;"	m	struct:__anon38	access:public
__anon38::n_l2_persistence	tcfg.h	/^	int n_l2_persistence; \/* Number of instruction in l2 instruction cache *\/$/;"	m	struct:__anon38	access:public
__anon38::n_persistence	tcfg.h	/^	int n_persistence; \/* Number of persistence instruction *\/$/;"	m	struct:__anon38	access:public
__anon38::n_u1_data_persistence	tcfg.h	/^	int n_u1_data_persistence; \/* Number of persistence data blocks in unified cache *\/$/;"	m	struct:__anon38	access:public
__anon38::n_u1_persistence	tcfg.h	/^	int n_u1_persistence; \/* Number of persistence instruction in Unified cache*\/$/;"	m	struct:__anon38	access:public
__anon38::out	tcfg.h	/^	tcfg_edge_t *in, *out; \/\/ incoming and outgoing edges$/;"	m	struct:__anon38	access:public
__anon3::callee	cfg.h	/^    proc_t	*callee;	\/\/ points to a callee if callee_addr not NULL$/;"	m	struct:__anon3	access:public
__anon3::code	cfg.h	/^    de_inst_t   *code;		\/\/ pointer to the first instruction$/;"	m	struct:__anon3	access:public
__anon3::d_instlist	cfg.h	/^     void   *d_instlist;$/;"	m	struct:__anon3	access:public
__anon3::flags	cfg.h	/^    int		flags;		\/\/ for traverse usage$/;"	m	struct:__anon3	access:public
__anon3::id	cfg.h	/^    int		id;		\/\/ basic block id (per procedure)$/;"	m	struct:__anon3	access:public
__anon3::in	cfg.h	/^    cfg_edge_t	**in;		\/\/ incoming edges$/;"	m	struct:__anon3	access:public
__anon3::in_abs_mem_value	cfg.h	/^	 abs_mem_p in_abs_mem_value;  \/* A data structure holding value in abstract *\/$/;"	m	struct:__anon3	access:public
__anon3::in_abs_reg_value	cfg.h	/^	 ric_p* in_abs_reg_value;	\/* values. Register numbers can directly be *\/$/;"	m	struct:__anon3	access:public
__anon3::loop_role	cfg.h	/^    int		loop_role;	\/\/ whether it is a loop head, tail, or neither$/;"	m	struct:__anon3	access:public
__anon3::num_d_inst	cfg.h	/^     int    num_d_inst;$/;"	m	struct:__anon3	access:public
__anon3::num_in	cfg.h	/^    int		num_in;		\/\/ number of incoming edges$/;"	m	struct:__anon3	access:public
__anon3::num_inst	cfg.h	/^    int		num_inst;	\/\/ number of instructions$/;"	m	struct:__anon3	access:public
__anon3::out_abs_mem_value	cfg.h	/^	 abs_mem_p out_abs_mem_value; \/*  memory locations *\/$/;"	m	struct:__anon3	access:public
__anon3::out_abs_reg_value	cfg.h	/^	 ric_p* out_abs_reg_value; \/* indexed in this structure *\/$/;"	m	struct:__anon3	access:public
__anon3::out_n	cfg.h	/^    cfg_edge_t	*out_n, *out_t;	\/\/ outgoing edges (non-taken\/taken) $/;"	m	struct:__anon3	access:public
__anon3::out_t	cfg.h	/^    cfg_edge_t	*out_n, *out_t;	\/\/ outgoing edges (non-taken\/taken) $/;"	m	struct:__anon3	access:public
__anon3::proc	cfg.h	/^    proc_t  	*proc;		\/\/ up-link to the procedure containing it$/;"	m	struct:__anon3	access:public
__anon3::sa	cfg.h	/^    addr_t	sa;		\/\/ block start addr$/;"	m	struct:__anon3	access:public
__anon3::size	cfg.h	/^    int		size;		\/\/ size (in bytes)$/;"	m	struct:__anon3	access:public
__anon3::type	cfg.h	/^    bb_type_t	type;		$/;"	m	struct:__anon3	access:public
__anon4::addr	cfg.h	/^    addr_t addr;$/;"	m	struct:__anon4	access:public
__anon4::name	cfg.h	/^    char* name;$/;"	m	struct:__anon4	access:public
__anon4::size	cfg.h	/^    int size;$/;"	m	struct:__anon4	access:public
__anon5::code	cfg.h	/^    de_inst_t	*code;		\/\/ decoded program text$/;"	m	struct:__anon5	access:public
__anon5::code_size	cfg.h	/^    int		    code_size;	\/\/ code size (in bytes)$/;"	m	struct:__anon5	access:public
__anon5::end_addr	cfg.h	/^    addr_t	    start_addr, end_addr, main_addr;$/;"	m	struct:__anon5	access:public
__anon5::main_addr	cfg.h	/^    addr_t	    start_addr, end_addr, main_addr;$/;"	m	struct:__anon5	access:public
__anon5::main_proc	cfg.h	/^    int		    main_proc;	\/\/ index of the main proc$/;"	m	struct:__anon5	access:public
__anon5::num_inst	cfg.h	/^    int		    num_inst;	\/\/ number of instructions$/;"	m	struct:__anon5	access:public
__anon5::num_procs	cfg.h	/^    int		    num_procs;	\/\/ number of procedures$/;"	m	struct:__anon5	access:public
__anon5::num_vars	cfg.h	/^    int         num_vars;   \/\/ number of global variables$/;"	m	struct:__anon5	access:public
__anon5::p_info	cfg.h	/^    symbol_i    *p_info;    \/\/ procedure symbol info$/;"	m	struct:__anon5	access:public
__anon5::procs	cfg.h	/^    proc_t	    *procs;		\/\/ procedures$/;"	m	struct:__anon5	access:public
__anon5::start_addr	cfg.h	/^    addr_t	    start_addr, end_addr, main_addr;$/;"	m	struct:__anon5	access:public
__anon5::v_info	cfg.h	/^    symbol_i    *v_info;    \/\/ global variable symbol info$/;"	m	struct:__anon5	access:public
__anon8::addr	infeasible.h	/^  char  addr[OP_LEN];$/;"	m	struct:__anon8	access:public
__anon8::flag	infeasible.h	/^  int   flag; \/\/mark special opr, e.g. induction operation$/;"	m	struct:__anon8	access:public
__anon8::op	infeasible.h	/^  char  op[OP_LEN];$/;"	m	struct:__anon8	access:public
__anon8::r1	infeasible.h	/^  char  r1[OP_LEN];$/;"	m	struct:__anon8	access:public
__anon8::r2	infeasible.h	/^  char  r2[OP_LEN];$/;"	m	struct:__anon8	access:public
__anon8::r3	infeasible.h	/^  char  r3[OP_LEN];$/;"	m	struct:__anon8	access:public
__anon9::bb	infeasible.h	/^  cfg_node_t *bb;               \/\/ associated block$/;"	m	struct:__anon9	access:public
__anon9::deritree	infeasible.h	/^  char deritree[DERI_LEN];      \/\/ derivation tree of affected variable$/;"	m	struct:__anon9	access:public
__anon9::lineno	infeasible.h	/^  int  lineno;                  \/\/ line number in bb$/;"	m	struct:__anon9	access:public
__anon9::rhs	infeasible.h	/^  int  rhs;                     \/\/ the rhs constant$/;"	m	struct:__anon9	access:public
__anon9::rhs_var	infeasible.h	/^  char rhs_var;                 \/\/ 1 if rhs is a variable$/;"	m	struct:__anon9	access:public
__opt_process_options	ss/options.c	/^__opt_process_options(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	file:	signature:(struct opt_odb_t *odb, int argc, char **argv, int depth)
_debug	ss/misc.c	/^_debug(char *file, char *func, int line, char *fmt, ...)$/;"	f	signature:(char *file, char *func, int line, char *fmt, ...)
_debug	ss/misc.h	/^_debug(char *file, char *func, int line, char *fmt, ...);$/;"	p	signature:(char *file, char *func, int line, char *fmt, ...)
_info	ss/misc.c	/^_info(char *file, char *func, int line, char *fmt, ...)$/;"	f	signature:(char *file, char *func, int line, char *fmt, ...)
_info	ss/misc.h	/^_info(char *file, char *func, int line, char *fmt, ...);$/;"	p	signature:(char *file, char *func, int line, char *fmt, ...)
_lowdigit	ss/misc.c	/^_lowdigit(slargeint_t *valptr)$/;"	f	file:	signature:(slargeint_t *valptr)
_warn	ss/misc.c	/^_warn(char *file, char *func, int line, char *fmt, ...)$/;"	f	signature:(char *file, char *func, int line, char *fmt, ...)
_warn	ss/misc.h	/^_warn(char *file, char *func, int line, char *fmt, ...);$/;"	p	signature:(char *file, char *func, int line, char *fmt, ...)
a	ss/machine.h	/^  word_t a;		\/* simplescalar opcode (must be unsigned) *\/$/;"	m	struct:__anon24	access:public
aFile	address.c	/^FILE* aFile;$/;"	v
a_double	ss/eval.c	/^static struct eval_value_t a_double;$/;"	v	typeref:struct:eval_value_t	file:
a_float	ss/eval.c	/^static struct eval_value_t a_float;$/;"	v	typeref:struct:eval_value_t	file:
a_symbol	ss/eval.c	/^static struct eval_value_t a_symbol;$/;"	v	typeref:struct:eval_value_t	file:
a_uint	ss/eval.c	/^static struct eval_value_t a_uint;$/;"	v	typeref:struct:eval_value_t	file:
abs_mem	address.h	/^struct abs_mem {$/;"	s
abs_mem::addr	address.h	/^	ric_p addr;$/;"	m	struct:abs_mem	access:public
abs_mem::inst_addr	address.h	/^	int inst_addr;$/;"	m	struct:abs_mem	access:public
abs_mem::next	address.h	/^	struct abs_mem* next;$/;"	m	struct:abs_mem	typeref:struct:abs_mem::abs_mem	access:public
abs_mem::valid	address.h	/^	int valid;	  $/;"	m	struct:abs_mem	access:public
abs_mem::value	address.h	/^	ric_p value;$/;"	m	struct:abs_mem	access:public
abs_mem_p	address.h	/^typedef struct abs_mem* abs_mem_p;$/;"	t	typeref:struct:abs_mem
abs_mem_s	address.h	/^typedef struct abs_mem abs_mem_s;$/;"	t	typeref:struct:abs_mem
abs_reg	isa.h	/^	 ric_p* 	abs_reg;				\/* Abstract register value at entry point $/;"	m	struct:__anon16	access:public
accrue	ss/options.h	/^  int accrue;			\/* accrue list across uses *\/$/;"	m	struct:opt_opt_t	access:public
acmp	ss/symbol.c	/^acmp(struct sym_sym_t **sym1, struct sym_sym_t **sym2)$/;"	f	file:	signature:(struct sym_sym_t **sym1, struct sym_sym_t **sym2)
acs_in	isa.h	/^	 acs_p** 	acs_in;		\/* abstract data cache state at the entry $/;"	m	struct:__anon16	access:public
acs_in	tcfg.h	/^	acs_p** acs_in;$/;"	m	struct:__anon38	access:public
acs_out	isa.h	/^	 acs_p** 	acs_out;		\/* abstract data cache state at the exit $/;"	m	struct:__anon16	access:public
acs_out	tcfg.h	/^	acs_p** acs_out;$/;"	m	struct:__anon38	access:public
acs_p	cache.h	/^typedef struct cache_block* acs_p;$/;"	t	typeref:struct:cache_block
acs_s	cache.h	/^typedef struct cache_block acs_s;$/;"	t	typeref:struct:cache_block
addAfterNode	common.c	/^void addAfterNode(void *data, worklist_p *prvNode, worklist_p *headNode) {$/;"	f	signature:(void *data, worklist_p *prvNode, worklist_p *headNode)
addAfterNode	common.h	/^void addAfterNode(void *data, worklist_p *prvNode, worklist_p *headNode);$/;"	p	signature:(void *data, worklist_p *prvNode, worklist_p *headNode)
addMapping	unicache.c	/^static int addMapping(mem_blk_set_t* arg, unsigned int naddr);$/;"	p	file:	signature:(mem_blk_set_t* arg, unsigned int naddr)
addNullifier	conflicts.c	/^int addNullifier( assign_t *as, assign_t ***nullifier_list, int *num_nullifiers ) {$/;"	f	signature:( assign_t *as, assign_t ***nullifier_list, int *num_nullifiers )
addToIncSet	scp_cache.h	/^void addToIncSet(saddr_p m, worklist_p *prvNode, worklist_p *strNode,$/;"	p	signature:(saddr_p m, worklist_p *prvNode, worklist_p *strNode, loop_t *lp)
addToWorkList	common.c	/^void addToWorkList(worklist_p* Wlist, void* data)$/;"	f	signature:(worklist_p* Wlist, void* data)
addToWorkList	common.h	/^void addToWorkList(worklist_p* Wlist, void* data);$/;"	p	signature:(worklist_p* Wlist, void* data)
addToYS	scp_cache.h	/^int addToYS(sblk_p acsBlk, saddr_p mAcc);$/;"	p	signature:(sblk_p acsBlk, saddr_p mAcc)
add_inst	ss/ss_exegraph.c	/^static void add_inst(int inst) {$/;"	f	file:	signature:(int inst)
add_option	ss/options.c	/^add_option(struct opt_odb_t *odb,	\/* option database *\/$/;"	f	file:	signature:(struct opt_odb_t *odb, struct opt_opt_t *opt)
add_tag	cache.c	/^add_tag(int lp_id, unsigned short set, unsigned short tag)$/;"	f	file:	signature:(int lp_id, unsigned short set, unsigned short tag)
add_var	ilp.c	/^void add_var(char *var) {$/;"	f	signature:(char *var)
added	symexec.h	/^	int added[MAX_EXPR_LEN]; \/\/added=0: not processed, added=1: added$/;"	m	struct:linear_expr	access:public
addr	address.h	/^	ric_p addr;$/;"	m	struct:abs_mem	access:public
addr	cfg.h	/^    addr_t addr;$/;"	m	struct:__anon4	access:public
addr	infeasible.h	/^  char  addr[OP_LEN];$/;"	m	struct:__anon8	access:public
addr	isa.h	/^    addr_t  addr;$/;"	m	struct:__anon16	access:public
addr	ss/symbol.h	/^  md_addr_t addr;		\/* symbol address value *\/$/;"	m	struct:sym_sym_t	access:public
addrExpr	symexec.h	/^	expr_s addrExpr; \/*Address expression *\/$/;"	m	struct:__anon18	access:public
addr_set	symexec.h	/^	worklist_p addr_set; \/*ScopeMem accessed in increasing order*\/$/;"	m	struct:__anon18	access:public
addr_t	address.h	/^typedef unsigned addr_t;$/;"	t
address_set	tcfg.h	/^	worklist_p* address_set;$/;"	m	struct:__anon38	access:public
addrset_l1	tcfg.h	/^	worklist_p* addrset_l1;$/;"	m	struct:__anon38	access:public
addrset_l2	tcfg.h	/^	worklist_p* addrset_l2;$/;"	m	struct:__anon38	access:public
adr	main.c	/^	addr_t adr;$/;"	m	struct:jptb	file:	access:public
adr	ss/ecoff.h	/^  unsigned int adr;$/;"	m	struct:ecoff_fdr	access:public
adr	ss/ecoff.h	/^  unsigned int adr;$/;"	m	struct:ecoff_pdr	access:public
all_predecessors_visited	tcfg.c	/^int all_predecessors_visited(tcfg_node_t* bbi, char* visited) {$/;"	f	signature:(tcfg_node_t* bbi, char* visited)
alloc_dep_mem	ss/ss_exegraph.c	/^static void alloc_dep_mem() {$/;"	f	file:
alloc_est_units	pipeline.c	/^static void alloc_est_units() {$/;"	f	file:
alloc_mem	exegraph.c	/^alloc_mem()$/;"	f	file:
allocated	unicache.c	/^static int allocated(mem_blk_set_t* arg);$/;"	p	file:	signature:(mem_blk_set_t* arg)
an_int	ss/eval.c	/^static struct eval_value_t an_int;$/;"	v	typeref:struct:eval_value_t	file:
anal_count	tcfg.h	/^	int anal_count;$/;"	m	struct:__anon38	access:public
analysis	unicache.c	/^int analysis = 0;$/;"	v
analyze	address.c	/^static void analyze(tcfg_node_t* bbi)$/;"	f	file:	signature:(tcfg_node_t* bbi)
analyze	address.c	/^static void analyze(tcfg_node_t* bbi);$/;"	p	file:	signature:(tcfg_node_t* bbi)
analyzeBlock	symexec.c	/^static void analyzeBlock(inf_node_t *ib) {$/;"	f	file:	signature:(inf_node_t *ib)
analyzeBlock	symexec.c	/^static void analyzeBlock(inf_node_t *ib);$/;"	p	file:	signature:(inf_node_t *ib)
analyze_abs_instr_cache	unicache.c	/^static void analyze_abs_instr_cache(int type) {$/;"	f	file:	signature:(int type)
analyze_abs_instr_cache_all	cache.h	/^void analyze_abs_instr_cache_all();$/;"	p	signature:()
analyze_abs_instr_cache_all	unicache.c	/^void analyze_abs_instr_cache_all() {$/;"	f
analyze_abs_l2_instr_cache	unicache.c	/^static void analyze_abs_l2_instr_cache(int type) {$/;"	f	file:	signature:(int type)
analyze_address	address.c	/^void analyze_address()$/;"	f
analyze_address	address.h	/^void analyze_address();$/;"	p	signature:()
analyze_cache_hierarchy	main.c	/^static void analyze_cache_hierarchy() {$/;"	f	file:
analyze_data_cache	cache.h	/^void analyze_data_cache();$/;"	p	signature:()
analyze_half_regular_access	scp_tscope.c	/^int analyze_half_regular_access(dat_inst_t *d_inst, inf_node_t *ib) {$/;"	f	signature:(dat_inst_t *d_inst, inf_node_t *ib)
analyze_loop	address.c	/^static void analyze_loop(tcfg_node_t* bbi, int loop_id);$/;"	p	file:	signature:(tcfg_node_t* bbi, int loop_id)
analyze_loop	address.c	/^static void analyze_loop(tcfg_node_t* iter, int loop_id)$/;"	f	file:	signature:(tcfg_node_t* iter, int loop_id)
analyze_loop_top	address.c	/^static slist_p analyze_loop_top(loop_t* loop, int loop_id)$/;"	f	file:	signature:(loop_t* loop, int loop_id)
analyze_loop_top	address.c	/^static slist_p analyze_loop_top(loop_t* loop, int loop_id);$/;"	p	file:	signature:(loop_t* loop, int loop_id)
analyze_regular_access	scp_address.h	/^int analyze_regular_access(dat_inst_t *d_inst, inf_node_t* ib);$/;"	p	signature:(dat_inst_t *d_inst, inf_node_t* ib)
analyze_regular_access	scp_tscope.c	/^int analyze_regular_access(dat_inst_t *d_inst, inf_node_t *ib) {$/;"	f	signature:(dat_inst_t *d_inst, inf_node_t *ib)
analyze_scalar_access	scp_address.h	/^int analyze_scalar_access(dat_inst_t *d_inst, inf_node_t* ib);$/;"	p	signature:(dat_inst_t *d_inst, inf_node_t* ib)
analyze_scalar_access	scp_tscope.c	/^int analyze_scalar_access(dat_inst_t *d_inst, inf_node_t* ib) {$/;"	f	signature:(dat_inst_t *d_inst, inf_node_t* ib)
analyze_top	address.c	/^static void analyze_top()$/;"	f	file:
analyze_top	address.c	/^static void analyze_top();$/;"	p	file:
analyze_unified_cache	cache.h	/^void analyze_unified_cache();$/;"	p	signature:()
analyze_unpred_access	scp_address.h	/^int analyze_unpred_access(dat_inst_t *d_inst, inf_node_t* ib);$/;"	p	signature:(dat_inst_t *d_inst, inf_node_t* ib)
analyze_unpred_access	scp_tscope.c	/^int analyze_unpred_access(dat_inst_t *d_inst, inf_node_t* ib) {$/;"	f	signature:(dat_inst_t *d_inst, inf_node_t* ib)
analyzed	address.c	/^static int* analyzed;$/;"	v	file:
analyzed_loop	address.c	/^static int* analyzed_loop;$/;"	v	file:
arraySizeCons	scp_tscope.c	/^worklist_p arraySizeCons; \/*constraint on array size*\/$/;"	v
as_addr	ss/eval.h	/^    md_addr_t as_addr;			\/* value for type == et_addr *\/$/;"	m	union:eval_value_t::__anon19	access:public
as_double	ss/eval.h	/^    double as_double;			\/* value for type == et_double *\/$/;"	m	union:eval_value_t::__anon19	access:public
as_float	ss/eval.h	/^    float as_float;			\/* value for type == et_float *\/$/;"	m	union:eval_value_t::__anon19	access:public
as_int	ss/eval.h	/^    int as_int;				\/* value for type == et_int *\/$/;"	m	union:eval_value_t::__anon19	access:public
as_qword	ss/eval.h	/^    qword_t as_qword;			\/* value for type == ec_qword *\/$/;"	m	union:eval_value_t::__anon19	access:public
as_sqword	ss/eval.h	/^    sqword_t as_sqword;			\/* value for type == ec_sqword *\/$/;"	m	union:eval_value_t::__anon19	access:public
as_symbol	ss/eval.h	/^    char *as_symbol;			\/* value for type == et_symbol *\/$/;"	m	union:eval_value_t::__anon19	access:public
as_uint	ss/eval.h	/^    unsigned int as_uint;		\/* value for type == et_uint *\/$/;"	m	union:eval_value_t::__anon19	access:public
assign_t	infeasible.h	/^} assign_t;$/;"	t	typeref:struct:__anon9
assignlist	infeasible.h	/^  assign_t   **assignlist;    \/\/ list of assign effects (ptr) in this node$/;"	m	struct:__anon12	access:public
assoc	ss/my_opt.c	/^int nsets, bsize, assoc;$/;"	v
assoc_dl1	ss/my_opt.c	/^int nsets_dl1, bsize_dl1, assoc_dl1;$/;"	v
assoc_dl2	ss/my_opt.c	/^int nsets_dl2, bsize_dl2, assoc_dl2;$/;"	v
assoc_l2	ss/my_opt.c	/^int nsets_l2, bsize_l2, assoc_l2;$/;"	v
asym	ss/ecoff.h	/^  ecoff_SYMR asym;$/;"	m	struct:ecoff_EXTR	access:public
b	ss/machine.h	/^  word_t b;		\/* simplescalar unsigned immediate fields *\/$/;"	m	struct:__anon24	access:public
base	common.h	/^    void    *base;$/;"	m	struct:queue_t	access:public
base	common.h	/^    void    *base;$/;"	m	struct:stack_t	access:public
bb	infeasible.h	/^  cfg_node_t *bb;               \/\/ associated block$/;"	m	struct:__anon9	access:public
bb	infeasible.h	/^  cfg_node_t *bb;               \/\/ associated block$/;"	m	struct:branch_t	access:public
bb	infeasible.h	/^  cfg_node_t *bb;$/;"	m	struct:__anon12	access:public
bb	tcfg.h	/^	cfg_node_t *bb; \/\/ pointer to the physical basic block$/;"	m	struct:__anon38	access:public
bb_is_loop_head	cfg.c	/^bb_is_loop_head(cfg_node_t *bb)$/;"	f	signature:(cfg_node_t *bb)
bb_is_loop_tail	cfg.c	/^bb_is_loop_tail(cfg_node_t *bb)$/;"	f	signature:(cfg_node_t *bb)
bb_type_t	cfg.h	/^typedef enum {CTRL_SEQ, CTRL_COND, CTRL_UNCOND, CTRL_CALL, CTRL_RET} bb_type_t;$/;"	t	typeref:enum:__anon2
bbb_inst_num	bpred.h	/^bbb_inst_num(bfg_node_t *bbb);$/;"	p	signature:(bfg_node_t *bbb)
bbi	bpred.h	/^    tcfg_node_t	*bbi;$/;"	m	struct:__anon1	access:public
bbi	tcfg.h	/^	tcfg_node_t *bbi;$/;"	m	struct:tcfg_nlink_t	access:public
bbi_backedge	tcfg.c	/^bbi_backedge(tcfg_edge_t *edge)$/;"	f	signature:(tcfg_edge_t *edge)
bbi_bid	tcfg.c	/^bbi_bid(tcfg_node_t *bbi)$/;"	f	signature:(tcfg_node_t *bbi)
bbi_categorize	cache.c	/^bbi_categorize(tcfg_node_t *bbi, loop_t **bbi_hit_loops, int len)$/;"	f	file:	signature:(tcfg_node_t *bbi, loop_t **bbi_hit_loops, int len)
bbi_hm_list	cache.c	/^loop_t		***bbi_hm_list;$/;"	v
bbi_id	pipeline.h	/^	short bbi_id;$/;"	m	struct:__anon34	access:public
bbi_is_loopback	tcfg.c	/^bbi_is_loopback(tcfg_edge_t *edge, int head, int tail)$/;"	f	signature:(tcfg_edge_t *edge, int head, int tail)
bbi_is_return	tcfg.c	/^bbi_is_return(tcfg_node_t *bbi)$/;"	f	signature:(tcfg_node_t *bbi)
bbi_lp	scp_cache.c	/^loop_t* bbi_lp(tcfg_node_t *bbi) {$/;"	f	signature:(tcfg_node_t *bbi)
bbi_lpId	scp_cache.c	/^int bbi_lpId(tcfg_node_t *bbi) {$/;"	f	signature:(tcfg_node_t *bbi)
bbi_map	tcfg.c	/^tcfg_nlink_t ***bbi_map;$/;"	v
bbi_pid	tcfg.c	/^bbi_pid(tcfg_node_t *bbi)$/;"	f	signature:(tcfg_node_t *bbi)
bbi_type	tcfg.c	/^bbi_type(tcfg_node_t *bbi)$/;"	f	signature:(tcfg_node_t *bbi)
bbi_type	tcfg.h	/^bbi_type();$/;"	p	signature:()
bdepth	main.c	/^int bdepth = 0;$/;"	v
bfg	bpred.c	/^bfg_node_t	    ***bfg;$/;"	v
bfg_cons	ilp.c	/^static void bfg_cons() {$/;"	f	file:
bfg_edge_str	ilp.c	/^static void bfg_edge_str(bfg_edge_t *e, int bpred) {$/;"	f	file:	signature:(bfg_edge_t *e, int bpred)
bfg_edge_t	bpred.h	/^struct bfg_edge_t {$/;"	s
bfg_edge_t	bpred.h	/^typedef struct bfg_edge_t    bfg_edge_t;$/;"	t	typeref:struct:bfg_edge_t
bfg_edge_t::branch	bpred.h	/^    int		branch;$/;"	m	struct:bfg_edge_t	access:public
bfg_edge_t::dst	bpred.h	/^    bfg_node_t	*src, *dst;	\/\/ block s -> t$/;"	m	struct:bfg_edge_t	access:public
bfg_edge_t::next_in	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
bfg_edge_t::next_out	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
bfg_edge_t::prev_in	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
bfg_edge_t::prev_out	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
bfg_edge_t::src	bpred.h	/^    bfg_node_t	*src, *dst;	\/\/ block s -> t$/;"	m	struct:bfg_edge_t	access:public
bfg_edge_term	ilp.c	/^static void bfg_edge_term(FILE *fp, bfg_edge_t *e, int bpred, char *prefix,$/;"	f	file:	signature:(FILE *fp, bfg_edge_t *e, int bpred, char *prefix, char *suffix)
bfg_node_str	ilp.c	/^static void bfg_node_str(bfg_node_t *bbb) {$/;"	f	file:	signature:(bfg_node_t *bbb)
bfg_node_t	bpred.h	/^} bfg_node_t;$/;"	t	typeref:struct:__anon1
bfg_node_term	ilp.c	/^static void bfg_node_term(FILE *fp, bfg_node_t *bbb, char *prefix, char *suffix) {$/;"	f	file:	signature:(FILE *fp, bfg_node_t *bbb, char *prefix, char *suffix)
bhr	bpred.h	/^    short	bhr;	\/\/ BHR: branch history register$/;"	m	struct:__anon1	access:public
bhr_to_pi	bpred.c	/^bhr_to_pi(tcfg_node_t *bbi, unsigned bhr)$/;"	f	file:	signature:(tcfg_node_t *bbi, unsigned bhr)
bhr_update	bpred.c	/^bhr_update(unsigned bhr, int branch)$/;"	f	file:	signature:(unsigned bhr, int branch)
bimod_config	ss/my_opt.c	/^int bimod_config[1] = { \/* bimod tbl size *\/4 };$/;"	v
bimod_nelt	ss/my_opt.c	/^int bimod_nelt = 1;$/;"	v
bind_to_enum	ss/options.c	/^bind_to_enum(char *str,			\/* string to bind to an enum *\/$/;"	f	file:	signature:(char *str, char **emap, int *eval, int emap_sz, int *res)
bind_to_str	ss/options.c	/^bind_to_str(int val,			\/* enumeration value *\/$/;"	f	file:	signature:(int val, char **emap, int *eval, int emap_sz)
bits	common.c	/^bits(unsigned x)$/;"	f	signature:(unsigned x)
bits	common.h	/^bits(unsigned x);$/;"	p	signature:(unsigned x)
biv	symexec.h	/^	biv_p biv;$/;"	m	struct:__anon17	access:public
biv2LoopId	symexec.c	/^int  biv2LoopId(biv_p biv) {$/;"	f	signature:(biv_p biv)
biv2LoopId	symexec.h	/^int biv2LoopId(biv_p biv);$/;"	p	signature:(biv_p biv)
bivEq	reg.c	/^int bivEq(biv_p inVar1, biv_p inVar2) {$/;"	f	signature:(biv_p inVar1, biv_p inVar2)
bivEq	symexec.h	/^int bivEq(biv_p inVar1, biv_p inVar2);$/;"	p	signature:(biv_p inVar1, biv_p inVar2)
biv_list	loops.h	/^    void*           biv_list;   \/\/list of BIV in this loop$/;"	m	struct:loop_t	access:public
biv_p	symexec.h	/^typedef struct BIV * biv_p;$/;"	t	typeref:struct:BIV
biv_s	symexec.h	/^typedef struct BIV biv_s;$/;"	t	typeref:struct:BIV
bjptb	main.c	/^int bjptb = 0;$/;"	v
blkAddr	scp_address.h	/^    int                 blkAddr;    \/*Memory block*\/$/;"	m	struct:scoped_address	access:public
block	cache.h	/^	unsigned block;	  $/;"	m	struct:mem_blk_set	access:public
bodies	pipeline.c	/^mas_inst_t **bodies, *start_body;$/;"	v
body_len	exegraph.c	/^int		eg_len = 0, plog_len = 0, elog_len = 0, body_len = 0;$/;"	v
body_loop	exegraph.c	/^loop_t		*body_loop;$/;"	v
bool_t	ss/host.h	/^typedef int bool_t;			\/* generic boolean type *\/$/;"	t
bound	infeasible.h	/^  int bound;              \/\/ constraint for execution count by user-specified loopbound$/;"	m	struct:__anon14	access:public
bound	loops.h	/^    int             bound;      \/\/maximum lb        $/;"	m	struct:loop_t	access:public
bound_elog_len	pipeline.c	/^static void bound_elog_len() {$/;"	f	file:
bp_flag	pipeline.h	/^	short bp_flag;$/;"	m	struct:__anon34	access:public
bp_type	exegraph.h	/^    char	    bp_type;		\/\/ BP_CPRED, BP_MPRED, BP_UNCLEAR$/;"	m	struct:__anon32	access:public
bpred_analys	bpred.h	/^bpred_analys();$/;"	p	signature:()
bpred_analysis	bpred.c	/^bpred_analysis()$/;"	f
bpred_misses	ilp.c	/^static void bpred_misses() {$/;"	f	file:
bpred_scheme	main.c	/^int bpred_scheme;$/;"	v
bpred_scheme_t	bpred.h	/^enum bpred_scheme_t	{ NO_BPRED, GAG, GSHARE, LOCAL };$/;"	g
bpred_type	exegraph.c	/^int		bpred_type;$/;"	v
branch	bpred.h	/^    int		branch;$/;"	m	struct:bfg_edge_t	access:public
branch	bpred.h	/^    int		branch;$/;"	m	struct:btg_edge_t	access:public
branch	infeasible.h	/^  branch_t   *branch;         \/\/ ptr to branch effect associated with this node; NULL if not a branch$/;"	m	struct:__anon12	access:public
branch	tcfg.h	/^	int branch; \/\/ TAKEN or NOT_TAKEN$/;"	m	struct:tcfg_edge_t	access:public
branch_t	infeasible.h	/^struct branch_t {$/;"	s
branch_t	infeasible.h	/^typedef struct branch_t branch_t;$/;"	t	typeref:struct:branch_t
branch_t::BA_conflict_list	infeasible.h	/^  BA_conflict_t *BA_conflict_list;$/;"	m	struct:branch_t	access:public
branch_t::BB_conflict_list	infeasible.h	/^  BB_conflict_t *BB_conflict_list;$/;"	m	struct:branch_t	access:public
branch_t::bb	infeasible.h	/^  cfg_node_t *bb;               \/\/ associated block$/;"	m	struct:branch_t	access:public
branch_t::deritree	infeasible.h	/^  char deritree[DERI_LEN];      \/\/ derivation tree of tested variable$/;"	m	struct:branch_t	access:public
branch_t::jump_cond	infeasible.h	/^  char jump_cond;               \/\/ condition that makes a branch instruction jump$/;"	m	struct:branch_t	access:public
branch_t::num_BA_conflicts	infeasible.h	/^  int  num_BA_conflicts;$/;"	m	struct:branch_t	access:public
branch_t::num_BB_conflicts	infeasible.h	/^  int  num_BB_conflicts;$/;"	m	struct:branch_t	access:public
branch_t::rhs	infeasible.h	/^  int  rhs;                     \/\/ the rhs constant$/;"	m	struct:branch_t	access:public
branch_t::rhs_var	infeasible.h	/^  char rhs_var;                 \/\/ 1 if rhs is a variable$/;"	m	struct:branch_t	access:public
bsize	ss/ecoff.h	/^  int bsize;$/;"	m	struct:ecoff_aouthdr	access:public
bsize	ss/my_opt.c	/^int nsets, bsize, assoc;$/;"	v
bsize_dl1	ss/my_opt.c	/^int nsets_dl1, bsize_dl1, assoc_dl1;$/;"	v
bsize_dl2	ss/my_opt.c	/^int nsets_dl2, bsize_dl2, assoc_dl2;$/;"	v
bsize_l2	ss/my_opt.c	/^int nsets_l2, bsize_l2, assoc_l2;$/;"	v
bss_start	ss/ecoff.h	/^  int bss_start;$/;"	m	struct:ecoff_aouthdr	access:public
btb_config	ss/my_opt.c	/^int btb_config[2] = { \/* nsets *\/4, \/* assoc *\/1 };$/;"	v
btb_nelt	ss/my_opt.c	/^int btb_nelt = 2;$/;"	v
btg_cons	ilp.c	/^static void btg_cons() {$/;"	f	file:
btg_edge_str	ilp.c	/^static void btg_edge_str(btg_edge_t *e) {$/;"	f	file:	signature:(btg_edge_t *e)
btg_edge_t	bpred.h	/^struct btg_edge_t {$/;"	s
btg_edge_t	bpred.h	/^typedef struct btg_edge_t   btg_edge_t;$/;"	t	typeref:struct:btg_edge_t
btg_edge_t::branch	bpred.h	/^    int		branch;$/;"	m	struct:btg_edge_t	access:public
btg_edge_t::dst	bpred.h	/^    bfg_node_t	*src, *dst;$/;"	m	struct:btg_edge_t	access:public
btg_edge_t::next_in	bpred.h	/^    btg_edge_t	*next_in, *next_out;$/;"	m	struct:btg_edge_t	access:public
btg_edge_t::next_out	bpred.h	/^    btg_edge_t	*next_in, *next_out;$/;"	m	struct:btg_edge_t	access:public
btg_edge_t::src	bpred.h	/^    bfg_node_t	*src, *dst;$/;"	m	struct:btg_edge_t	access:public
btg_edge_term	ilp.c	/^static void btg_edge_term(FILE *fp, btg_edge_t *e, char *prefix, char *suffix) {$/;"	f	file:	signature:(FILE *fp, btg_edge_t *e, char *prefix, char *suffix)
btg_in	bpred.c	/^btg_edge_t	**btg_in, **btg_out;$/;"	v
btg_out	bpred.c	/^btg_edge_t	**btg_in, **btg_out;$/;"	v
build_bbi_map	tcfg.c	/^build_bbi_map()$/;"	f
build_bfg	bpred.c	/^build_bfg()$/;"	f	file:
build_btg	bpred.c	/^build_btg()$/;"	f	file:
build_cfgs	cfg.c	/^build_cfgs()$/;"	f
build_contends	ss/ss_exegraph.c	/^static void build_contends() {$/;"	f	file:
build_depends	ss/ss_exegraph.c	/^static void build_depends() {$/;"	f	file:
build_graph	unicache.c	/^static void build_graph(proc_t* proc);$/;"	p	file:	signature:(proc_t* proc)
builtin_options	ss/options.c	/^static struct opt_opt_t *builtin_options = &config_opt;$/;"	v	typeref:struct:opt_opt_t	file:
busy	ss/resource.h	/^  int busy;				\/* non-zero if this unit is busy *\/$/;"	m	struct:res_desc	access:public
byte_t	ss/host.h	/^typedef unsigned char byte_t;		\/* byte - 8 bits *\/$/;"	t
cache	cache.c	/^cache_t		    cache;$/;"	v
cache_analysis	cache.c	/^cache_analysis()$/;"	f
cache_block	cache.h	/^struct cache_block {$/;"	s
cache_block::mem_blk_h	cache.h	/^	mem_blk_set_t* mem_blk_h;$/;"	m	struct:cache_block	access:public
cache_cons	ilp.c	/^static void cache_cons() {$/;"	f	file:
cache_dl1_lat	ss/my_opt.c	/^int cache_dl1_lat;$/;"	v
cache_dl1_opt	ss/my_opt.c	/^char *cache_dl1_opt;$/;"	v
cache_dl2_lat	ss/my_opt.c	/^int cache_dl2_lat;$/;"	v
cache_dl2_opt	ss/my_opt.c	/^char *cache_dl2_opt;$/;"	v
cache_il1_lat	ss/my_opt.c	/^int cache_il1_lat;$/;"	v
cache_il1_opt	ss/my_opt.c	/^char *cache_il1_opt;$/;"	v
cache_il2_lat	ss/my_opt.c	/^int cache_il2_lat;$/;"	v
cache_il2_opt	ss/my_opt.c	/^char *cache_il2_opt;$/;"	v
cache_l2	cache.c	/^cache_t			 cache_l2;	$/;"	v
cache_misses	ilp.c	/^static void cache_misses() {$/;"	f	file:
cache_t	cache.h	/^} cache_t;$/;"	t	typeref:struct:__anon26
cachedNode	scp_tscope.c	/^static int cachedNode(int blkAddr) {$/;"	f	file:	signature:(int blkAddr)
calc_gen	cache.c	/^calc_gen()$/;"	f	file:
calc_num_mblks	cache.c	/^calc_num_mblks()$/;"	f	file:
callee	cfg.h	/^    proc_t	*callee;	\/\/ points to a callee if callee_addr not NULL$/;"	m	struct:__anon3	access:public
callgraph	infeasible.h	/^int *callgraph;$/;"	v
capt	common.h	/^    int	    capt;	    \/* capacity *\/$/;"	m	struct:queue_t	access:public
capt	common.h	/^    int	    capt;	\/* capacity *\/$/;"	m	struct:stack_t	access:public
categorize	cache.c	/^categorize()$/;"	f	file:
categorize_L1	unicache.c	/^static void categorize_L1(int type) {$/;"	f	file:	signature:(int type)
categorize_L2	unicache.c	/^static void categorize_L2(int type) {$/;"	f	file:	signature:(int type)
categorize_inst_AH_NC	unicache.c	/^static void categorize_inst_AH_NC(tcfg_node_t* bbi, de_inst_t* inst,$/;"	f	file:	signature:(tcfg_node_t* bbi, de_inst_t* inst, int inst_id)
categorize_inst_AM_NC	unicache.c	/^static void categorize_inst_AM_NC(tcfg_node_t* bbi, de_inst_t* inst,$/;"	f	file:	signature:(tcfg_node_t* bbi, de_inst_t* inst, int inst_id)
categorize_inst_PS_NC	unicache.c	/^static void categorize_inst_PS_NC(tcfg_node_t* bbi, de_inst_t* inst,$/;"	f	file:	signature:(tcfg_node_t* bbi, de_inst_t* inst, int inst_id)
categorize_l2_inst_X_AH_NC	unicache.c	/^static void categorize_l2_inst_X_AH_NC(tcfg_node_t* bbi, de_inst_t* inst,$/;"	f	file:	signature:(tcfg_node_t* bbi, de_inst_t* inst, int inst_id)
categorize_l2_inst_X_AM_NC	unicache.c	/^static void categorize_l2_inst_X_AM_NC(tcfg_node_t* bbi, de_inst_t* inst,$/;"	f	file:	signature:(tcfg_node_t* bbi, de_inst_t* inst, int inst_id)
categorize_l2_inst_X_PS_NC	unicache.c	/^static void categorize_l2_inst_X_PS_NC(tcfg_node_t* bbi, de_inst_t* inst,$/;"	f	file:	signature:(tcfg_node_t* bbi, de_inst_t* inst, int inst_id)
categorize_ul2_inst_PS_NC	scp_cache.c	/^void categorize_ul2_inst_PS_NC(int bbi_id, scp_acs mpa_acs_in, int inst_id,$/;"	f	signature:(int bbi_id, scp_acs mpa_acs_in, int inst_id, de_inst_t* inst, loop_t*lp)
categorize_ul2_inst_PS_NC	scp_cache.h	/^void categorize_ul2_inst_PS_NC(int bbi_id, scp_acs mpa_acs_in, int inst_id,$/;"	p	signature:(int bbi_id, scp_acs mpa_acs_in, int inst_id, de_inst_t* inst, loop_t*lp)
caux	ss/ecoff.h	/^  int caux;$/;"	m	struct:ecoff_fdr	access:public
cbAuxOffset	ss/ecoff.h	/^  int cbAuxOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbDnOffset	ss/ecoff.h	/^  int cbDnOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbExtOffset	ss/ecoff.h	/^  int cbExtOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbFdOffset	ss/ecoff.h	/^  int cbFdOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbLine	ss/ecoff.h	/^  int cbLine;$/;"	m	struct:ecoff_fdr	access:public
cbLine	ss/ecoff.h	/^  int cbLine;$/;"	m	struct:ecoff_symhdr_t	access:public
cbLineOffset	ss/ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_fdr	access:public
cbLineOffset	ss/ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_pdr	access:public
cbLineOffset	ss/ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbOptOffset	ss/ecoff.h	/^  int cbOptOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbPdOffset	ss/ecoff.h	/^  int cbPdOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbRfdOffset	ss/ecoff.h	/^  int cbRfdOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbSs	ss/ecoff.h	/^  int cbSs;$/;"	m	struct:ecoff_fdr	access:public
cbSsExtOffset	ss/ecoff.h	/^  int cbSsExtOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbSsOffset	ss/ecoff.h	/^  int cbSsOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cbSymOffset	ss/ecoff.h	/^  int cbSymOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
cfg	cfg.h	/^    cfg_node_t	*cfg;		\/\/ cfg nodes with num_bb nodes$/;"	m	struct:proc_t	access:public
cfg_edge_t	cfg.h	/^struct cfg_edge_t {$/;"	s
cfg_edge_t	cfg.h	/^typedef struct cfg_edge_t   cfg_edge_t;$/;"	t	typeref:struct:cfg_edge_t
cfg_edge_t::dst	cfg.h	/^    cfg_node_t  *src, *dst;	\/\/ src -> dst$/;"	m	struct:cfg_edge_t	access:public
cfg_edge_t::src	cfg.h	/^    cfg_node_t  *src, *dst;	\/\/ src -> dst$/;"	m	struct:cfg_edge_t	access:public
cfg_node_t	cfg.h	/^} cfg_node_t;$/;"	t	typeref:struct:__anon3
change_address	unicache.c	/^static void change_address();$/;"	p	file:
change_layout	unicache.c	/^static void change_layout();$/;"	p	file:
changed	estimate.c	/^int		changed;$/;"	v
chdir	ss/options.c	57;"	d	file:
checkBivStride	symexec.c	/^static int  checkBivStride(reg_t *regList, insn_t *insn);$/;"	p	file:	signature:(reg_t *regList, insn_t *insn)
checkBivStride	symexec.c	/^static int checkBivStride(reg_t *regList, insn_t* insn) {$/;"	f	file:	signature:(reg_t *regList, insn_t* insn)
checkEquality	address.c	/^static int checkEquality(ric_p arg1, ric_p arg2)$/;"	f	file:	signature:(ric_p arg1, ric_p arg2)
checkEquality	address.c	/^static int checkEquality(ric_p arg1, ric_p arg2);$/;"	p	file:	signature:(ric_p arg1, ric_p arg2)
checkEquality	unicache.c	/^static int checkEquality(acs_p* acs1, acs_p* acs2) {$/;"	f	file:	signature:(acs_p* acs1, acs_p* acs2)
checkForConflicts	unicache.c	/^static int checkForConflicts(tcfg_node_t* bbi, de_inst_t* cinst, int age,$/;"	f	file:	signature:(tcfg_node_t* bbi, de_inst_t* cinst, int age, char first_word, int *conflicts)
checkForInclusion	unicache.c	/^static int checkForInclusion(acs_p* acs_in, mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(acs_p* acs_in, mem_blk_set_t* mem_blk_set)
checkForInclusionSingle	unicache.c	/^static int checkForInclusionSingle(acs_p* acs_in, mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(acs_p* acs_in, mem_blk_set_t* mem_blk_set)
checkForOnePresence	unicache.c	/^static int checkForOnePresence(acs_p** acs_in, mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(acs_p** acs_in, mem_blk_set_t* mem_blk_set)
checkForPresence	unicache.c	/^int checkForPresence(acs_p** acs_in, mem_blk_set_t* mem_blk_set) {$/;"	f	signature:(acs_p** acs_in, mem_blk_set_t* mem_blk_set)
checkForVictim	unicache.c	/^static int checkForVictim(acs_p** acs_in, mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(acs_p** acs_in, mem_blk_set_t* mem_blk_set)
check_fetch_times	estimate.c	/^check_fetch_times()$/;"	f
check_fetch_times	estimate.c	/^check_fetch_times();$/;"	p	file:
classified_address_analysis	scp_address.h	/^void classified_address_analysis();$/;"	p	signature:()
classified_address_analysis	scp_tscope.c	/^void classified_address_analysis(char *bin_fname) {$/;"	f	signature:(char *bin_fname)
cleanupCache	unicache.c	/^static void cleanupCache() {$/;"	f	file:
clearRegList	reg.c	/^int clearRegList(reg_t *regList) {$/;"	f	signature:(reg_t *regList)
clearRegList	symexec.h	/^int clearRegList(reg_t *regList);$/;"	p	signature:(reg_t *regList)
clearYS	scp_cache.h	/^int clearYS(sblk_p acsBlk);$/;"	p	signature:(sblk_p acsBlk)
clear_bbi_flags	tcfg.c	/^clear_bbi_flags()$/;"	f
clear_bbi_flags	tcfg.h	/^clear_bbi_flags();$/;"	p	signature:()
clear_queue	common.c	/^clear_queue(Queue *queue)$/;"	f	signature:(Queue *queue)
clear_stack	common.c	/^clear_stack(Stack *stack)$/;"	f	signature:(Stack *stack)
clear_tcfg_edge_flags	tcfg.c	/^clear_tcfg_edge_flags()$/;"	f
cline	ss/ecoff.h	/^  int cline;$/;"	m	struct:ecoff_fdr	access:public
clrExpr	reg.c	/^void clrExpr(expr_p expr) {$/;"	f	signature:(expr_p expr)
clrExpr	symexec.h	/^void clrExpr(expr_p expr);$/;"	p	signature:(expr_p expr)
clrMem	symexec.c	/^void    clrMem(worklist_p memList);$/;"	p	file:	signature:(worklist_p memList)
clrReg	reg.c	/^void clrReg(reg_t *reg) {$/;"	f	signature:(reg_t *reg)
clrReg	symexec.h	/^void clrReg(reg_t *reg);$/;"	p	signature:(reg_t *reg)
cmd	ss/misc.c	/^  char *cmd;$/;"	m	struct:__anon21	file:	access:public
cmp	cache.h	/^    int		cmp;    \/\/ cache miss penalty$/;"	m	struct:__anon26	access:public
cmpBIV	symexec_value.c	/^int cmpBIV(biv_p inVar1, biv_p inVar2) {$/;"	f	signature:(biv_p inVar1, biv_p inVar2)
cmpLpOrder	loops.c	/^int cmpLpOrder(int lpId1, int lpId2) {$/;"	f	signature:(int lpId1, int lpId2)
cmpLpOrder	loops.h	/^int cmpLpOrder(int lpId1, int lpId2);$/;"	p	signature:(int lpId1, int lpId2)
cmpSAddr	scp_address.c	/^int cmpSAddr(saddr_p m1, saddr_p m2, int lpId) {$/;"	f	signature:(saddr_p m1, saddr_p m2, int lpId)
cmpSAddr	scp_address.h	/^int         cmpSAddr(saddr_p smem1, saddr_p smem2, int lpId);$/;"	p	signature:(saddr_p smem1, saddr_p smem2, int lpId)
cmpSBlk	scp_cache.h	/^int cmpSBlk(sblk_p sblk1, sblk_p sblk2);$/;"	p	signature:(sblk_p sblk1, sblk_p sblk2)
cmpTS	scp_address.c	/^int cmpTS(ts_p as1, ts_p as2) {$/;"	f	signature:(ts_p as1, ts_p as2)
cmpTS	scp_address.h	/^int     cmpTS(ts_p ts1, ts_p ts2);$/;"	p	signature:(ts_p ts1, ts_p ts2)
cmpTSset	scp_address.c	/^int cmpTSset(worklist_p tsList1, worklist_p tsList2, int lpId) {$/;"	f	signature:(worklist_p tsList1, worklist_p tsList2, int lpId)
cmpTSset	scp_address.h	/^int     cmpTSset(worklist_p tsSet1, worklist_p tsSet2, int lpId);$/;"	p	signature:(worklist_p tsSet1, worklist_p tsSet2, int lpId)
cmp_general	common.h	/^cmp_general(range_t *x, range_t *y);$/;"	p	signature:(range_t *x, range_t *y)
cmp_mpaInst	dump.c	/^int cmp_mpaInst(sblk_p src, sblk_p dst) {$/;"	f	signature:(sblk_p src, sblk_p dst)
cntExec	symexec.c	/^int     cntExec;$/;"	v
code	cfg.h	/^    de_inst_t	*code;		\/\/ decoded program text$/;"	m	struct:__anon5	access:public
code	cfg.h	/^    de_inst_t   *code;		\/\/ instructions$/;"	m	struct:proc_t	access:public
code	cfg.h	/^    de_inst_t   *code;		\/\/ pointer to the first instruction$/;"	m	struct:__anon3	access:public
code	pipeline.h	/^	mas_inst_t *code;$/;"	m	struct:code_link_t	access:public
code_link_t	pipeline.h	/^struct code_link_t {$/;"	s
code_link_t	pipeline.h	/^typedef struct code_link_t code_link_t;$/;"	t	typeref:struct:code_link_t
code_link_t::code	pipeline.h	/^	mas_inst_t *code;$/;"	m	struct:code_link_t	access:public
code_link_t::next	pipeline.h	/^	code_link_t *next;$/;"	m	struct:code_link_t	access:public
code_link_t::num_inst	pipeline.h	/^	int num_inst;$/;"	m	struct:code_link_t	access:public
code_size	cfg.h	/^    int		    code_size;	\/\/ code size (in bytes)$/;"	m	struct:__anon5	access:public
code_size	est.sh	/^code_size()$/;"	f
code_size	sim.sh	/^code_size()$/;"	f
code_size	solve.sh	/^code_size()$/;"	f
code_size	solve_time.sh	/^code_size()$/;"	f
coef	symexec.h	/^	int coef[MAX_EXPR_LEN];$/;"	m	struct:linear_expr	access:public
coexist	exegraph.c	/^range16_t	*coexist;$/;"	v
col_data	cfg.h	/^struct col_data$/;"	s
col_data::__anon6::inst	cfg.h	/^		 de_inst_t* inst;$/;"	m	union:col_data::__anon6	access:public
col_data::__anon6::proc	cfg.h	/^		 proc_t* proc;$/;"	m	union:col_data::__anon6	access:public
col_data::next	cfg.h	/^	struct col_data* next;$/;"	m	struct:col_data	typeref:struct:col_data::col_data	access:public
col_data::type	cfg.h	/^	int type;$/;"	m	struct:col_data	access:public
col_data::u	cfg.h	/^	}u;$/;"	m	struct:col_data	typeref:union:col_data::__anon6	access:public
col_data_p	cfg.h	/^typedef struct col_data* col_data_p;$/;"	t	typeref:struct:col_data
col_data_s	cfg.h	/^typedef struct col_data col_data_s;$/;"	t	typeref:struct:col_data
collectOuterPS	dump.c	/^void collectOuterPS(loop_t *lp) {$/;"	f	signature:(loop_t *lp)
collect_affected_sets	pipeline.c	/^static void collect_affected_sets() {$/;"	f	file:
collect_bfg_nodes	bpred.c	/^collect_bfg_nodes()$/;"	f	file:
collect_bodies	pipeline.c	/^static void collect_bodies() {$/;"	f	file:
collect_epilogs	pipeline.c	/^static void collect_epilogs() {$/;"	f	file:
collect_mp_insts	bpred.c	/^collect_mp_insts()$/;"	f
collect_prologs	pipeline.c	/^static void collect_prologs() {$/;"	f	file:
collect_reachables	bpred.c	/^collect_reachables(bfg_node_t *bbb, int branch)$/;"	f	file:	signature:(bfg_node_t *bbb, int branch)
collect_root_reachable	bpred.c	/^collect_root_reachable(int pi)$/;"	f	file:	signature:(int pi)
collect_tcfg_edges	tcfg.c	/^collect_tcfg_edges()$/;"	f
comb_config	ss/my_opt.c	/^int comb_config[1] = { \/* meta_table_size *\/4 };$/;"	v
comb_nelt	ss/my_opt.c	/^int comb_nelt = 1;$/;"	v
commit_width_depends	ss/ss_exegraph.c	/^static void commit_width_depends(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
compress_icache_addrs	ss/my_opt.c	/^int compress_icache_addrs;$/;"	v
computeExpr	reg.c	/^int computeExpr(char *op, expr_p exprD, expr_p expr1, expr_p expr2) {$/;"	f	signature:(char *op, expr_p exprD, expr_p expr1, expr_p expr2)
computeExpr	symexec.h	/^int computeExpr(char *op, expr_p exprD, expr_p expr1, expr_p expr2);$/;"	p	signature:(char *op, expr_p exprD, expr_p expr1, expr_p expr2)
computeExpr	symexec_value.c	/^void computeExpr(char *opr, expr_p *expr1, expr_p *expr2) {$/;"	f	signature:(char *opr, expr_p *expr1, expr_p *expr2)
cond_bbi	tcfg.c	/^cond_bbi(tcfg_node_t *bbi)$/;"	f	signature:(tcfg_node_t *bbi)
config_opt	ss/options.c	/^static struct opt_opt_t config_opt =$/;"	v	typeref:struct:opt_opt_t	file:
conflictDetectFlag	symexec.c	/^int     conflictDetectFlag; \/*Global: if do conflicting pair detection*\/$/;"	v
conflict_dir	infeasible.h	/^  char     conflict_dir;        \/\/ branch direction in the BA conflict: JUMP or FALL$/;"	m	struct:__anon10	access:public
conflict_dir	infeasible.h	/^  char     conflict_dir;        \/\/ combination of branch directions in the BB conflict: JJ, JF, FJ, or JJ$/;"	m	struct:__anon11	access:public
conflict_src	infeasible.h	/^  assign_t *conflict_src;$/;"	m	struct:__anon10	access:public
conflict_src	infeasible.h	/^  branch_t *conflict_src;$/;"	m	struct:__anon11	access:public
constant	ss/eval.c	/^constant(struct eval_state_t *es)	\/* expression evaluator *\/$/;"	f	file:	signature:(struct eval_state_t *es)
constraints	ilp.c	/^void constraints() {$/;"	f
contd_type	exegraph.h	/^    char	    contd_type;$/;"	m	struct:egraph_edge_t	access:public
copt	ss/ecoff.h	/^  int copt;$/;"	m	struct:ecoff_fdr	access:public
copyInst	symexec.c	/^void copyInst(insn_t *dsrc, insn_t *ddes) {$/;"	f	signature:(insn_t *dsrc, insn_t *ddes)
copyMem	symexec.c	/^int     copyMem(mem_p dst, mem_p src);$/;"	p	file:	signature:(mem_p dst, mem_p src)
copyMem	symexec.c	/^int copyMem(mem_p dst, mem_p src) {$/;"	f	signature:(mem_p dst, mem_p src)
copyMemList	symexec.c	/^int     copyMemList(worklist_p *dstL, worklist_p srcL);$/;"	p	file:	signature:(worklist_p *dstL, worklist_p srcL)
copyMemList	symexec.c	/^int copyMemList(worklist_p *dstList, worklist_p srcList) {$/;"	f	signature:(worklist_p *dstList, worklist_p srcList)
copy_cache	unicache.c	/^static acs_p* copy_cache(acs_p* acs) {$/;"	f	file:	signature:(acs_p* acs)
copy_stack	common.c	/^copy_stack(Stack *y, Stack *x)$/;"	f	signature:(Stack *y, Stack *x)
cost_func	ilp.c	/^static void cost_func() {$/;"	f	file:
cost_term	ilp.c	/^static void cost_term(int edge_id, int bpred) {$/;"	f	file:	signature:(int edge_id, int bpred)
count	address.c	/^int count = 0;$/;"	v
count	unicache.c	/^static int count;$/;"	v	file:
counter_t	ss/host.h	/^typedef dfloat_t counter_t;$/;"	t
counter_t	ss/host.h	/^typedef sqword_t counter_t;$/;"	t
cpd	ss/ecoff.h	/^  unsigned short cpd;$/;"	m	struct:ecoff_fdr	access:public
cpred_times	pipeline.c	/^int **cpred_times, **mpred_times, start_time;$/;"	v
cprmask	ss/ecoff.h	/^  int cprmask[4];$/;"	m	struct:ecoff_aouthdr	access:public
cpyBIV	reg.c	/^int cpyBIV(biv_p varDst, biv_p varSrc) {$/;"	f	signature:(biv_p varDst, biv_p varSrc)
cpyBIV	symexec.h	/^int cpyBIV(biv_p varDst, biv_p varSrc);$/;"	p	signature:(biv_p varDst, biv_p varSrc)
cpyBIV	symexec_value.c	/^int cpyBIV(biv_p varDst, biv_p varSrc) {$/;"	f	signature:(biv_p varDst, biv_p varSrc)
cpyExpr	reg.c	/^int cpyExpr(expr_p dst, expr_p src) {$/;"	f	signature:(expr_p dst, expr_p src)
cpyExpr	symexec.h	/^int cpyExpr(expr_p exprDst, expr_p exprSrc);$/;"	p	signature:(expr_p exprDst, expr_p exprSrc)
cpyExpr	symexec_value.c	/^void cpyExpr(expr_p exprDst, expr_p exprSrc) {$/;"	f	signature:(expr_p exprDst, expr_p exprSrc)
cpyReg	reg.c	/^int cpyReg(reg_t *dst, reg_t src) {$/;"	f	signature:(reg_t *dst, reg_t src)
cpyReg	symexec.h	/^int cpyReg(reg_t *dst, reg_t src);$/;"	p	signature:(reg_t *dst, reg_t src)
cpySAddr	scp_address.c	/^void cpySAddr (saddr_p dst, saddr_p src) {$/;"	f	signature:(saddr_p dst, saddr_p src)
cpySAddr	scp_address.h	/^void    cpySAddr(saddr_p dst, saddr_p src);$/;"	p	signature:(saddr_p dst, saddr_p src)
cpySBlk	scp_cache.h	/^void cpySBlk(sblk_p dst, sblk_p src);$/;"	p	signature:(sblk_p dst, sblk_p src)
cpyTS	scp_address.c	/^void cpyTS(ts_p dst, ts_p src) {$/;"	f	signature:(ts_p dst, ts_p src)
cpyTS	scp_address.h	/^void    cpyTS(ts_p src, ts_p dst);$/;"	p	signature:(ts_p src, ts_p dst)
crc	ss/misc.c	/^crc(word_t crc_accum, word_t data)$/;"	f	signature:(word_t crc_accum, word_t data)
crc	ss/misc.h	/^word_t crc(word_t crc_accum, word_t data);$/;"	p	signature:(word_t crc_accum, word_t data)
crc_gentab	ss/misc.c	/^crc_gentab(void)$/;"	f	file:	signature:(void)
crc_init	ss/misc.c	/^static int crc_init = FALSE;$/;"	v	file:
crc_table	ss/misc.c	/^static unsigned long crc_table[256];$/;"	v	file:
createBIV	symexec.c	/^biv_p   createBIV(reg_t *regList, insn_t *insn);$/;"	p	file:	signature:(reg_t *regList, insn_t *insn)
createBIV	symexec.c	/^biv_p createBIV(reg_t *regList, insn_t *insn) {$/;"	f	signature:(reg_t *regList, insn_t *insn)
createExpr	reg.c	/^expr_p createExpr() {$/;"	f
createMem	symexec.c	/^mem_p   createMem(addr_t instAddr, reg_t writeAddr, reg_t regValue);$/;"	p	file:	signature:(addr_t instAddr, reg_t writeAddr, reg_t regValue)
createMem	symexec.c	/^mem_p createMem(addr_t instAddr, reg_t writeAddr, reg_t regValue) {$/;"	f	signature:(addr_t instAddr, reg_t writeAddr, reg_t regValue)
createMemoryAloc	address.c	/^static abs_mem_p createMemoryAloc(ric_s addr, ric_p value)$/;"	f	file:	signature:(ric_s addr, ric_p value)
createSAddr	scp_address.c	/^saddr_p createSAddr(int blkAddr, int instAddr, int flag, worklist_p orgTSset) {$/;"	f	signature:(int blkAddr, int instAddr, int flag, worklist_p orgTSset)
createSAddr	scp_address.h	/^saddr_p  createSAddr(int addrBlk, int instAddr, int flag, worklist_p orgTSset);$/;"	p	signature:(int addrBlk, int instAddr, int flag, worklist_p orgTSset)
createSBlk	scp_cache.h	/^sblk_p createSBlk(saddr_p blkAddr);$/;"	p	signature:(saddr_p blkAddr)
create_aloc	address.c	/^static void create_aloc()$/;"	f	file:
create_bpred_depend	ss/ss_exegraph.c	/^static void create_bpred_depend(int src_id, int dst_id, int normal) {$/;"	f	file:	signature:(int src_id, int dst_id, int normal)
create_cfg	cfg.c	/^create_cfg(proc_t *proc)$/;"	f	file:	signature:(proc_t *proc)
create_cfg_edges	cfg.c	/^create_cfg_edges(proc_t *proc)$/;"	f	file:	signature:(proc_t *proc)
create_data_depend	ss/ss_exegraph.c	/^static void create_data_depend(int src_id, int dst_id, int normal) {$/;"	f	file:	signature:(int src_id, int dst_id, int normal)
create_egraph	exegraph.c	/^create_egraph(mas_inst_t *plog, int np, mas_inst_t *elog, int ne,$/;"	f	signature:(mas_inst_t *plog, int np, mas_inst_t *elog, int ne, mas_inst_t *body, int nb, int bp, loop_t *lp)
create_egraph_ss	ss/ss_exegraph.c	/^void create_egraph_ss() {$/;"	f
crfd	ss/ecoff.h	/^  int crfd;$/;"	m	struct:ecoff_fdr	access:public
crfd	ss/ecoff.h	/^  int crfd;$/;"	m	struct:ecoff_symhdr_t	access:public
csym	ss/ecoff.h	/^  int csym;$/;"	m	struct:ecoff_fdr	access:public
ctx_mpmiss_time	pipeline.c	/^static void ctx_mpmiss_time(int edge_id, int hm_id, int set, int bp) {$/;"	f	file:	signature:(int edge_id, int hm_id, int set, int bp)
ctx_unit_time	pipeline.c	/^static void ctx_unit_time(int edge_id, int bp, int contextMask) {$/;"	f	file:	signature:(int edge_id, int bp, int contextMask)
curEnumBlk	scp_tscope.c	/^saddr_p curEnumBlk;$/;"	v
curr_grp	ilp.c	/^int curr_grp = 0, curr_idx = 0;$/;"	v
curr_idx	ilp.c	/^int curr_grp = 0, curr_idx = 0;$/;"	v
d	ss/machine.h	/^  dfloat_t d[MD_NUM_FREGS\/2];	\/* double-prediction floating point view *\/$/;"	m	union:__anon22	access:public
d_instlist	cfg.h	/^     void   *d_instlist;$/;"	m	struct:__anon3	access:public
dat_inst_t	symexec.h	/^} dat_inst_t;$/;"	t	typeref:struct:__anon18
data	common.h	/^	void* data;$/;"	m	struct:worklist	access:public
data_access	isa.h	/^	 ACCESS_T data_access;		\/* data access classification(hit\/not known) $/;"	m	struct:__anon16	access:public
data_dep	ss/ss_exegraph.c	/^char **data_dep;$/;"	v
data_depends	ss/ss_exegraph.c	/^static void data_depends() {$/;"	f	file:
data_start	ss/ecoff.h	/^  int data_start;$/;"	m	struct:ecoff_aouthdr	access:public
dbgAddr	scp_address.h	/^FILE *dbgAddr;$/;"	v
dbgAddr	scp_tscope.c	/^FILE *dbgAddr;$/;"	v
dbgExec	symexec.c	/^FILE* dbgExec; \/*to debug the convergence*\/$/;"	v
dbgF	reg.c	/^static FILE *dbgF;$/;"	v	file:
dbgF	symexec_value.c	/^FILE *dbgF;$/;"	v
dbgMpa	scp_cache.c	/^FILE *dbgMpa;$/;"	v
dcLatClassify	pipeline.h	/^int dcLatClassify(mas_inst_t*, int);$/;"	p	signature:(mas_inst_t*, int)
dc_flag	pipeline.h	/^	short dc_flag;$/;"	m	struct:__anon34	access:public
dc_flag_l2	pipeline.h	/^	short dc_flag_l2;$/;"	m	struct:__anon34	access:public
dcache_delay	tcfg.h	/^	int dcache_delay; \/* For data cache analysis *\/$/;"	m	struct:__anon38	access:public
de_inst_t	isa.h	/^} de_inst_t;$/;"	t	typeref:struct:__anon16
deal_exit_edge	loops.c	/^static void deal_exit_edge(tcfg_edge_t *e) {$/;"	f	file:	signature:(tcfg_edge_t *e)
deal_other_edge	loops.c	/^static void deal_other_edge(tcfg_edge_t *e) {$/;"	f	file:	signature:(tcfg_edge_t *e)
dealloc_dep_mem	ss/ss_exegraph.c	/^static void dealloc_dep_mem() {$/;"	f	file:
debug	ss/misc.h	/^debug(char *fmt, ...);$/;"	p	signature:(char *fmt, ...)
debug	ss/misc.h	/^static void debug(char *fmt, ...) {}$/;"	f	signature:(char *fmt, ...)
debug	ss/misc.h	158;"	d
debug	ss/misc.h	174;"	d
debugging	ss/misc.c	/^int debugging = FALSE;$/;"	v
decode_inst	ss/ss_isa.c	/^decode_inst(de_inst_t *de_inst, md_inst_t inst)$/;"	f	signature:(de_inst_t *de_inst, md_inst_t inst)
decode_width_depends	ss/ss_exegraph.c	/^static void decode_width_depends(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
decode_width_depends_m	ss/ss_exegraph.c	/^static void decode_width_depends_m(int inst) {$/;"	f	file:	signature:(int inst)
decode_width_depends_n	ss/ss_exegraph.c	/^static void decode_width_depends_n(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
delay_type	ss/ss_exegraph.c	/^static int delay_type(egraph_edge_t *ce) {$/;"	f	file:	signature:(egraph_edge_t *ce)
delete_tcfg_edge	tcfg.c	/^static void delete_tcfg_edge(tcfg_edge_t *edge)$/;"	f	file:	signature:(tcfg_edge_t *edge)
dep_regs	pipeline.c	/^int dep_regs[MAX_REGS];$/;"	v
dequeue	common.c	/^dequeue(Queue *queue)$/;"	f	signature:(Queue *queue)
deritree	infeasible.h	/^  char deritree[DERI_LEN];      \/\/ derivation tree of affected variable$/;"	m	struct:__anon9	access:public
deritree	infeasible.h	/^  char deritree[DERI_LEN];      \/\/ derivation tree of tested variable$/;"	m	struct:branch_t	access:public
deriveUnknown	symexec.c	/^int deriveUnknown(reg_t *regList, insn_t *insn) {$/;"	f	signature:(reg_t *regList, insn_t *insn)
desc	ss/options.h	/^  char *desc;			\/* option description *\/$/;"	m	struct:opt_opt_t	access:public
detectBIV	symexec.c	/^static void detectBIV() {$/;"	f	file:
detectBIV	symexec.c	/^static void detectBIV();$/;"	p	file:
detectConflicts	conflicts.c	/^int detectConflicts() {$/;"	f
dfloat_t	ss/host.h	/^typedef double dfloat_t;		\/* double-precision float - 64 bits *\/$/;"	t
distance	estimate.c	/^distance(egraph_node_t *v, egraph_node_t *u)$/;"	f	file:	signature:(egraph_node_t *v, egraph_node_t *u)
doSymExec	symexec.c	/^int doSymExec() {$/;"	f
doSymExec	symexec.c	/^static int  doSymExec();$/;"	p	file:
do_ilp	main.c	/^static void do_ilp(char *obj_file) {$/;"	f	file:	signature:(char *obj_file)
dsize	ss/ecoff.h	/^  int dsize;$/;"	m	struct:ecoff_aouthdr	access:public
dst	address.h	/^	void* dst;$/;"	m	struct:slist	access:public
dst	bpred.h	/^    bfg_node_t	*src, *dst;	\/\/ block s -> t$/;"	m	struct:bfg_edge_t	access:public
dst	bpred.h	/^    bfg_node_t	*src, *dst;$/;"	m	struct:btg_edge_t	access:public
dst	cfg.h	/^    cfg_node_t  *src, *dst;	\/\/ src -> dst$/;"	m	struct:cfg_edge_t	access:public
dst	exegraph.h	/^    egraph_node_t   *src, *dst;$/;"	m	struct:egraph_edge_t	access:public
dst	tcfg.h	/^	tcfg_node_t *src, *dst;$/;"	m	struct:tcfg_edge_t	access:public
dtlb_opt	ss/my_opt.c	/^char *dtlb_opt;$/;"	v
dump	address.c	/^static void dump(de_inst_t* inst, ric_p addr, FILE* fp)$/;"	f	file:	signature:(de_inst_t* inst, ric_p addr, FILE* fp)
dumpAddress	address.c	/^static void dumpAddress(tcfg_node_t* bb);$/;"	p	file:	signature:(tcfg_node_t* bb)
dumpAddress	address.c	/^static void dumpAddress(tcfg_node_t* bbi) $/;"	f	file:	signature:(tcfg_node_t* bbi)
dumpAlocStatus	address.c	/^static void dumpAlocStatus(tcfg_node_t* bbi, FILE* fp) $/;"	f	file:	signature:(tcfg_node_t* bbi, FILE* fp)
dumpCacheBB	unicache.c	/^static void dumpCacheBB(acs_p** acs, FILE* fp);$/;"	p	file:	signature:(acs_p** acs, FILE* fp)
dump_bfg	bpred.c	/^dump_bfg()$/;"	f
dump_bfg	bpred.h	/^dump_bfg();$/;"	p	signature:()
dump_btg	bpred.c	/^dump_btg()$/;"	f	file:
dump_cfg	cfg.c	/^dump_cfg(FILE *fp, proc_t *proc)$/;"	f	signature:(FILE *fp, proc_t *proc)
dump_cfg	cfg.h	/^dump_cfg(FILE *fp, proc_t *proc);$/;"	p	signature:(FILE *fp, proc_t *proc)
dump_code	readfile.c	/^dump_code()$/;"	f
dump_coexist	ss/ss_exegraph.c	/^void dump_coexist(int first, int last) {$/;"	f	signature:(int first, int last)
dump_config	ss/options.c	/^dump_config(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	file:	signature:(struct opt_odb_t *odb, char *fname)
dump_config	ss/options.c	/^static void dump_config(struct opt_odb_t *odb, char *fname);$/;"	p	file:	signature:(struct opt_odb_t *odb, char *fname)
dump_context_stats	pipeline.c	/^void dump_context_stats() {$/;"	f
dump_context_stats	pipeline.h	/^dump_context_stats();$/;"	p	signature:()
dump_data_address	address.c	/^static void dump_data_address()$/;"	f	file:
dump_data_dep	ss/ss_exegraph.c	/^dump_data_dep();$/;"	p	file:
dump_data_dep	ss/ss_exegraph.c	/^void dump_data_dep() {$/;"	f
dump_econtd	estimate.c	/^dump_econtd(egraph_node_t *v)$/;"	f	file:	signature:(egraph_node_t *v)
dump_edge_mp_times	pipeline.c	/^void dump_edge_mp_times(int edge_id, int hm) {$/;"	f	signature:(int edge_id, int hm)
dump_egraph	exegraph.c	/^dump_egraph()$/;"	f
dump_egraph	exegraph.c	/^dump_egraph();$/;"	p	file:
dump_egraph_contends	exegraph.c	/^dump_egraph_contends(int inst)$/;"	f	file:	signature:(int inst)
dump_egraph_depends	exegraph.c	/^dump_egraph_depends(int inst)$/;"	f	file:	signature:(int inst)
dump_egraph_earliest	estimate.c	/^dump_egraph_earliest(int start, int end)$/;"	f	signature:(int start, int end)
dump_egraph_times	estimate.c	/^dump_egraph_times(int start, int end)$/;"	f	signature:(int start, int end)
dump_egraph_times	estimate.c	/^dump_egraph_times(int start, int end);$/;"	p	file:	signature:(int start, int end)
dump_elog_len	pipeline.c	/^void dump_elog_len() {$/;"	f
dump_elog_len	pipeline.h	/^dump_elog_len();$/;"	p	signature:()
dump_elog_stats	pipeline.c	/^void dump_elog_stats() {$/;"	f
dump_elog_stats	pipeline.h	/^dump_elog_stats();$/;"	p	signature:()
dump_gen	cache.c	/^dump_gen()$/;"	f
dump_gen	cache.c	/^dump_gen();$/;"	p	file:
dump_hm_list	cache.c	/^dump_hm_list()$/;"	f
dump_hm_list	cache.c	/^dump_hm_list();$/;"	p	file:
dump_isa	isa.c	/^dump_isa()$/;"	f
dump_loop_comm_ances	loops.c	/^void dump_loop_comm_ances() {$/;"	f
dump_loop_tags	cache.c	/^dump_loop_tags()$/;"	f
dump_loop_tags	cache.c	/^dump_loop_tags();$/;"	p	file:
dump_loops	loops.c	/^static void dump_loops() {$/;"	f	file:
dump_mblk_hitloop	cache.c	/^dump_mblk_hitloop()$/;"	f
dump_mblk_hitloop	cache.c	/^dump_mblk_hitloop();$/;"	p	file:
dump_mlat_mpinst	pipeline.c	/^void dump_mlat_mpinst() {$/;"	f
dump_mlat_mpinst	pipeline.h	/^dump_mlat_mpinst();$/;"	p	signature:()
dump_mod_data_address	address.c	/^void dump_mod_data_address()$/;"	f
dump_mp_times	pipeline.c	/^void dump_mp_times() {$/;"	f
dump_mp_times	pipeline.h	/^dump_mp_times();$/;"	p	signature:()
dump_plog_stats	pipeline.c	/^void dump_plog_stats() {$/;"	f
dump_plog_stats	pipeline.h	/^dump_plog_stats();$/;"	p	signature:()
dump_tcfg	tcfg.c	/^dump_tcfg(FILE *fp)$/;"	f	signature:(FILE *fp)
dump_tcfg	tcfg.h	/^dump_tcfg(FILE *fp);$/;"	p	signature:(FILE *fp)
dump_unit_time	pipeline.c	/^void dump_unit_time(int edge_id, int hm, int bp) {$/;"	f	signature:(int edge_id, int hm, int bp)
dump_units_times	pipeline.c	/^void dump_units_times() {$/;"	f
dump_units_times	pipeline.h	/^dump_units_times();$/;"	p	signature:()
dump_xlogs	pipeline.c	/^static void dump_xlogs(code_link_t **xlogs) {$/;"	f	file:	signature:(code_link_t **xlogs)
dump_xlogs	pipeline.h	/^dump_xlogs();$/;"	p	signature:()
dumpconfig_opt	ss/options.c	/^static struct opt_opt_t dumpconfig_opt =$/;"	v	typeref:struct:opt_opt_t	file:
e_contd	exegraph.h	/^    egraph_edge_t   *e_contd, *l_contd;$/;"	m	struct:__anon32	access:public
earliest_time	estimate.c	/^earliest_time(egraph_node_t *v)$/;"	f	file:	signature:(egraph_node_t *v)
ecoff_EXTR	ss/ecoff.h	/^typedef struct ecoff_EXTR {$/;"	s
ecoff_EXTR	ss/ecoff.h	/^} ecoff_EXTR;$/;"	t	typeref:struct:ecoff_EXTR
ecoff_EXTR::asym	ss/ecoff.h	/^  ecoff_SYMR asym;$/;"	m	struct:ecoff_EXTR	access:public
ecoff_EXTR::ifd	ss/ecoff.h	/^  short ifd;$/;"	m	struct:ecoff_EXTR	access:public
ecoff_EXTR::reserved	ss/ecoff.h	/^  short reserved;$/;"	m	struct:ecoff_EXTR	access:public
ecoff_FDR	ss/ecoff.h	/^} ecoff_FDR;$/;"	t	typeref:struct:ecoff_fdr
ecoff_HDRR	ss/ecoff.h	/^} ecoff_HDRR;$/;"	t	typeref:struct:ecoff_symhdr_t
ecoff_PDR	ss/ecoff.h	/^} ecoff_PDR;$/;"	t	typeref:struct:ecoff_pdr
ecoff_SYMR	ss/ecoff.h	/^typedef struct ecoff_SYMR {$/;"	s
ecoff_SYMR	ss/ecoff.h	/^} ecoff_SYMR;$/;"	t	typeref:struct:ecoff_SYMR
ecoff_SYMR::index	ss/ecoff.h	/^  unsigned index :20;$/;"	m	struct:ecoff_SYMR	access:public
ecoff_SYMR::iss	ss/ecoff.h	/^  int iss;$/;"	m	struct:ecoff_SYMR	access:public
ecoff_SYMR::reserved	ss/ecoff.h	/^  unsigned reserved :1;$/;"	m	struct:ecoff_SYMR	access:public
ecoff_SYMR::sc	ss/ecoff.h	/^  unsigned sc :5;$/;"	m	struct:ecoff_SYMR	access:public
ecoff_SYMR::st	ss/ecoff.h	/^  unsigned st :6;$/;"	m	struct:ecoff_SYMR	access:public
ecoff_SYMR::value	ss/ecoff.h	/^  int value;$/;"	m	struct:ecoff_SYMR	access:public
ecoff_aouthdr	ss/ecoff.h	/^struct ecoff_aouthdr {$/;"	s
ecoff_aouthdr::bsize	ss/ecoff.h	/^  int bsize;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::bss_start	ss/ecoff.h	/^  int bss_start;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::cprmask	ss/ecoff.h	/^  int cprmask[4];$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::data_start	ss/ecoff.h	/^  int data_start;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::dsize	ss/ecoff.h	/^  int dsize;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::entry	ss/ecoff.h	/^  int entry;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::gp_value	ss/ecoff.h	/^  int gp_value;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::gprmask	ss/ecoff.h	/^  int gprmask;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::magic	ss/ecoff.h	/^  short magic;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::text_start	ss/ecoff.h	/^  int text_start;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::tsize	ss/ecoff.h	/^  int tsize;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_aouthdr::vstamp	ss/ecoff.h	/^  short vstamp;$/;"	m	struct:ecoff_aouthdr	access:public
ecoff_fdr	ss/ecoff.h	/^typedef struct ecoff_fdr {$/;"	s
ecoff_fdr::adr	ss/ecoff.h	/^  unsigned int adr;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::caux	ss/ecoff.h	/^  int caux;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::cbLine	ss/ecoff.h	/^  int cbLine;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::cbLineOffset	ss/ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::cbSs	ss/ecoff.h	/^  int cbSs;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::cline	ss/ecoff.h	/^  int cline;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::copt	ss/ecoff.h	/^  int copt;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::cpd	ss/ecoff.h	/^  unsigned short cpd;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::crfd	ss/ecoff.h	/^  int crfd;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::csym	ss/ecoff.h	/^  int csym;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::fBigendian	ss/ecoff.h	/^  unsigned fBigendian :1;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::fMerge	ss/ecoff.h	/^  unsigned fMerge :1;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::fReadin	ss/ecoff.h	/^  unsigned fReadin :1;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::iauxBase	ss/ecoff.h	/^  int iauxBase;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::ilineBase	ss/ecoff.h	/^  int ilineBase;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::ioptBase	ss/ecoff.h	/^  int ioptBase;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::ipdFirst	ss/ecoff.h	/^  unsigned short ipdFirst;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::issBase	ss/ecoff.h	/^  int issBase;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::isymBase	ss/ecoff.h	/^  int isymBase;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::lang	ss/ecoff.h	/^  unsigned lang :5;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::reserved	ss/ecoff.h	/^  unsigned reserved :24;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::rfdBase	ss/ecoff.h	/^  int rfdBase;$/;"	m	struct:ecoff_fdr	access:public
ecoff_fdr::rss	ss/ecoff.h	/^  int rss;$/;"	m	struct:ecoff_fdr	access:public
ecoff_filehdr	ss/ecoff.h	/^struct ecoff_filehdr {$/;"	s
ecoff_filehdr::f_flags	ss/ecoff.h	/^  unsigned short f_flags;$/;"	m	struct:ecoff_filehdr	access:public
ecoff_filehdr::f_magic	ss/ecoff.h	/^  unsigned short f_magic;$/;"	m	struct:ecoff_filehdr	access:public
ecoff_filehdr::f_nscns	ss/ecoff.h	/^  unsigned short f_nscns;$/;"	m	struct:ecoff_filehdr	access:public
ecoff_filehdr::f_nsyms	ss/ecoff.h	/^  int f_nsyms;$/;"	m	struct:ecoff_filehdr	access:public
ecoff_filehdr::f_opthdr	ss/ecoff.h	/^  unsigned short f_opthdr;$/;"	m	struct:ecoff_filehdr	access:public
ecoff_filehdr::f_symptr	ss/ecoff.h	/^  int f_symptr;$/;"	m	struct:ecoff_filehdr	access:public
ecoff_filehdr::f_timdat	ss/ecoff.h	/^  int f_timdat;$/;"	m	struct:ecoff_filehdr	access:public
ecoff_pdr	ss/ecoff.h	/^typedef struct ecoff_pdr {$/;"	s
ecoff_pdr::adr	ss/ecoff.h	/^  unsigned int adr;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::cbLineOffset	ss/ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::frameoffset	ss/ecoff.h	/^  int frameoffset;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::framereg	ss/ecoff.h	/^  short framereg;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::fregmask	ss/ecoff.h	/^  int fregmask;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::fregoffset	ss/ecoff.h	/^  int fregoffset;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::iline	ss/ecoff.h	/^  int iline;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::iopt	ss/ecoff.h	/^  int iopt;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::isym	ss/ecoff.h	/^  int isym;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::lnHigh	ss/ecoff.h	/^  int lnHigh;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::lnLow	ss/ecoff.h	/^  int lnLow;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::pcreg	ss/ecoff.h	/^  short pcreg;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::regmask	ss/ecoff.h	/^  int regmask;$/;"	m	struct:ecoff_pdr	access:public
ecoff_pdr::regoffset	ss/ecoff.h	/^  int regoffset;$/;"	m	struct:ecoff_pdr	access:public
ecoff_scnhdr	ss/ecoff.h	/^struct ecoff_scnhdr {$/;"	s
ecoff_scnhdr::s_flags	ss/ecoff.h	/^  int s_flags;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_lnnoptr	ss/ecoff.h	/^  int s_lnnoptr;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_name	ss/ecoff.h	/^  char s_name[8];$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_nlnno	ss/ecoff.h	/^  unsigned short s_nlnno;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_nreloc	ss/ecoff.h	/^  unsigned short s_nreloc;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_paddr	ss/ecoff.h	/^  int s_paddr;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_relptr	ss/ecoff.h	/^  int s_relptr;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_scnptr	ss/ecoff.h	/^  int s_scnptr;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_size	ss/ecoff.h	/^  int s_size;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_scnhdr::s_vaddr	ss/ecoff.h	/^  int s_vaddr;$/;"	m	struct:ecoff_scnhdr	access:public
ecoff_symhdr_t	ss/ecoff.h	/^typedef struct ecoff_symhdr_t {$/;"	s
ecoff_symhdr_t::cbAuxOffset	ss/ecoff.h	/^  int cbAuxOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbDnOffset	ss/ecoff.h	/^  int cbDnOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbExtOffset	ss/ecoff.h	/^  int cbExtOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbFdOffset	ss/ecoff.h	/^  int cbFdOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbLine	ss/ecoff.h	/^  int cbLine;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbLineOffset	ss/ecoff.h	/^  int cbLineOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbOptOffset	ss/ecoff.h	/^  int cbOptOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbPdOffset	ss/ecoff.h	/^  int cbPdOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbRfdOffset	ss/ecoff.h	/^  int cbRfdOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbSsExtOffset	ss/ecoff.h	/^  int cbSsExtOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbSsOffset	ss/ecoff.h	/^  int cbSsOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::cbSymOffset	ss/ecoff.h	/^  int cbSymOffset;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::crfd	ss/ecoff.h	/^  int crfd;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::iauxMax	ss/ecoff.h	/^  int iauxMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::idnMax	ss/ecoff.h	/^  int idnMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::iextMax	ss/ecoff.h	/^  int iextMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::ifdMax	ss/ecoff.h	/^  int ifdMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::ilineMax	ss/ecoff.h	/^  int ilineMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::ioptMax	ss/ecoff.h	/^  int ioptMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::ipdMax	ss/ecoff.h	/^  int ipdMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::issExtMax	ss/ecoff.h	/^  int issExtMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::issMax	ss/ecoff.h	/^  int issMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::isymMax	ss/ecoff.h	/^  int isymMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::magic	ss/ecoff.h	/^  short magic;$/;"	m	struct:ecoff_symhdr_t	access:public
ecoff_symhdr_t::vstamp	ss/ecoff.h	/^  short vstamp;$/;"	m	struct:ecoff_symhdr_t	access:public
econtd_delay	estimate.c	/^econtd_delay(egraph_node_t *v, int new_hi)$/;"	f	file:	signature:(egraph_node_t *v, int new_hi)
edge	tcfg.h	/^	tcfg_edge_t *edge;$/;"	m	struct:tcfg_elink_t	access:public
edge_mpset_cons	ilp.c	/^static void edge_mpset_cons(int lp_id, tcfg_edge_t *edge) {$/;"	f	file:	signature:(int lp_id, tcfg_edge_t *edge)
editAsmStr	infeasible.c	/^void editAsmStr(char *tmp) {$/;"	f	signature:(char *tmp)
eg_chain	exegraph.c	/^eg_chain_t	*eg_chain;$/;"	v
eg_chain_t	exegraph.h	/^} eg_chain_t;$/;"	t	typeref:struct:__anon33
eg_insts	exegraph.c	/^mas_inst_t	**eg_insts;$/;"	v
eg_insts_type	ss/ss_exegraph.c	/^char *eg_insts_type;$/;"	v
eg_len	exegraph.c	/^int		eg_len = 0, plog_len = 0, elog_len = 0, body_len = 0;$/;"	v
eg_mem_insts	ss/ss_exegraph.c	/^short int *eg_mem_insts, num_mem_insts;$/;"	v
egraph	exegraph.c	/^egraph_node_t	**egraph;$/;"	v
egraph_edge_t	exegraph.h	/^struct egraph_edge_t {$/;"	s
egraph_edge_t	exegraph.h	/^typedef struct egraph_edge_t egraph_edge_t;$/;"	t	typeref:struct:egraph_edge_t
egraph_edge_t::contd_type	exegraph.h	/^    char	    contd_type;$/;"	m	struct:egraph_edge_t	access:public
egraph_edge_t::dst	exegraph.h	/^    egraph_node_t   *src, *dst;$/;"	m	struct:egraph_edge_t	access:public
egraph_edge_t::lat	exegraph.h	/^    range16_t	    lat;	\/\/ max\/min latencies from src to dst$/;"	m	struct:egraph_edge_t	access:public
egraph_edge_t::next_in	exegraph.h	/^    egraph_edge_t   *next_in, *next_out;$/;"	m	struct:egraph_edge_t	access:public
egraph_edge_t::next_out	exegraph.h	/^    egraph_edge_t   *next_in, *next_out;$/;"	m	struct:egraph_edge_t	access:public
egraph_edge_t::normal	exegraph.h	/^    char	    normal;$/;"	m	struct:egraph_edge_t	access:public
egraph_edge_t::src	exegraph.h	/^    egraph_node_t   *src, *dst;$/;"	m	struct:egraph_edge_t	access:public
egraph_edges	exegraph.c	/^egraph_edge_t	*egraph_edges = NULL;$/;"	v
egraph_node_t	exegraph.h	/^} egraph_node_t;$/;"	t	typeref:struct:__anon32
elapsed_time	ss/misc.c	/^elapsed_time(long sec)$/;"	f	signature:(long sec)
elapsed_time	ss/misc.h	/^char *elapsed_time(long sec);$/;"	p	signature:(long sec)
elem	common.h	/^    void *elem;$/;"	m	struct:priority_queue_t	access:public
elog_len	exegraph.c	/^int		eg_len = 0, plog_len = 0, elog_len = 0, body_len = 0;$/;"	v
emap	ss/options.h	/^      char **emap;		\/* array of enum strings *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
emap_sz	ss/options.h	/^      int emap_sz;		\/* number of enum's in arrays *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
enable_abs_inst_cache	main.c	/^int enable_abs_inst_cache = 0; \/* For anabling abstract icache analysis *\/$/;"	v
enable_icache	main.c	/^int enable_icache = 0;$/;"	v
enable_il2cache	main.c	/^int enable_il2cache = 0; \/* For enabling level 2 icache analysis *\/$/;"	v
enable_scp_dcache	main.c	/^int enable_scp_dcache = 0; \/* Enable scope-aware dcache analysis *\/$/;"	v
enable_scp_dl2cache	main.c	/^int enable_scp_dl2cache = 0;\/* Enable scope-aware level 2 dcache analysis *\/$/;"	v
enable_ul2cache	main.c	/^int enable_ul2cache = 0; \/* For enabling level 2 ucache analysis *\/$/;"	v
end_addr	cfg.h	/^    addr_t	    start_addr, end_addr, main_addr;$/;"	m	struct:__anon5	access:public
end_bbb	bpred.c	/^bfg_node_t	    root_bbb, end_bbb;$/;"	v
end_bbb_id	bpred.c	/^int		    root_bbb_id, end_bbb_id;$/;"	v
end_bbb_in	bpred.c	/^btg_edge_t	**end_bbb_in, **root_bbb_out;$/;"	v
end_str	ilp.c	/^char start_str[] = "Sta", end_str[] = "End";$/;"	v
enqueue	common.c	/^enqueue(Queue *queue, void *x)$/;"	f	signature:(Queue *queue, void *x)
entry	common.h	/^		  void* entry;$/;"	m	struct:hashtab	access:public
entry	infeasible.h	/^  int entry;              \/\/ block id of loop entry$/;"	m	struct:__anon14	access:public
entry	ss/ecoff.h	/^  int entry;$/;"	m	struct:ecoff_aouthdr	access:public
enumAddrSet	scp_tscope.c	/^worklist_p *enumAddrSet; \/\/list of enumerated address$/;"	v
enumTSset	scp_tscope.c	/^worklist_p *enumTSset; \/\/the temporal scope for addrset being enumerated$/;"	v
enum_regular_address	scp_address.h	/^void enum_regular_address(dat_inst_t* d_inst, expr_p expr, int flag,$/;"	p	signature:(dat_inst_t* d_inst, expr_p expr, int flag, int curEq, worklist_p curTSnode, int curAddr)
enum_regular_address	scp_tscope.c	/^void enum_regular_address(dat_inst_t* d_inst, expr_p expr, int flag, int curEq,$/;"	f	signature:(dat_inst_t* d_inst, expr_p expr, int flag, int curEq, worklist_p curTSnode, int curAddr)
epilogs	pipeline.c	/^code_link_t **prologs, **epilogs;$/;"	v
eqTSset	scp_address.c	/^int eqTSset(worklist_p tsSet1, worklist_p tsSet2, int curLpId) {$/;"	f	signature:(worklist_p tsSet1, worklist_p tsSet2, int curLpId)
eqTSset	scp_address.h	/^int     eqTSset(worklist_p tsSet1,worklist_p tsSet2, int lpId);$/;"	p	signature:(worklist_p tsSet1,worklist_p tsSet2, int lpId)
err_value	ss/eval.c	/^static struct eval_value_t err_value = { et_int, { 0 } };$/;"	v	typeref:struct:eval_value_t	file:
esize	common.h	/^    int	    esize;	    \/* element size *\/$/;"	m	struct:queue_t	access:public
esize	common.h	/^    int	    esize;	\/* element size *\/$/;"	m	struct:stack_t	access:public
estConfScope	dump.c	/^int estConfScope(memscp_p m, worklist_p acs, loop_t *curLp) {$/;"	f	signature:(memscp_p m, worklist_p acs, loop_t *curLp)
estLpMissPS	dump.c	/^void estLpMissPS(loop_t *lp) {$/;"	f	signature:(loop_t *lp)
estScopeSize	scp_address.c	/^int estScopeSize(worklist_p tsSet, int lpId) {$/;"	f	signature:(worklist_p tsSet, int lpId)
estScopeSize	scp_address.h	/^int     estScopeSize(worklist_p tsSet, int lpId);$/;"	p	signature:(worklist_p tsSet, int lpId)
estScopeSizeOld	scp_address.c	/^int estScopeSizeOld(worklist_p tsSet, int lpId) {$/;"	f	signature:(worklist_p tsSet, int lpId)
estUnknownMiss	dump.c	/^void estUnknownMiss() {$/;"	f
est_egraph	estimate.c	/^est_egraph()$/;"	f
est_mpmiss_times	pipeline.c	/^static void est_mpmiss_times() {$/;"	f	file:
est_start_unit	pipeline.c	/^static void est_start_unit() {$/;"	f	file:
est_unit_term	ilp.c	/^static void est_unit_term(FILE *fp, tcfg_edge_t *e, int bpred, int hm,$/;"	f	file:	signature:(FILE *fp, tcfg_edge_t *e, int bpred, int hm, char *prefix, char *suffix)
est_units	pipeline.c	/^static void est_units() {$/;"	f	file:
estimateInducedMiss	dump.c	/^void estimateInducedMiss(tcfg_node_t* bbi, int type) {$/;"	f	signature:(tcfg_node_t* bbi, int type)
estimateNodeAllMiss	dump.c	/^void estimateNodeAllMiss(tcfg_node_t* bbi) {$/;"	f	signature:(tcfg_node_t* bbi)
estunit_mpcost_func	ilp.c	/^static void estunit_mpcost_func(int bbi_id, int hm, int lp_id) {$/;"	f	file:	signature:(int bbi_id, int hm, int lp_id)
estunit_mpunit_cons	ilp.c	/^static void estunit_mpunit_cons(int bbi_id, int hm, int lp_id) {$/;"	f	file:	signature:(int bbi_id, int hm, int lp_id)
et_NUM	ss/eval.h	/^  et_NUM$/;"	e	enum:eval_type_t
et_addr	ss/eval.h	/^  et_addr,			\/* address value *\/$/;"	e	enum:eval_type_t
et_double	ss/eval.h	/^  et_double,			\/* double-precision floating point value *\/$/;"	e	enum:eval_type_t
et_float	ss/eval.h	/^  et_float,			\/* single-precision floating point value *\/$/;"	e	enum:eval_type_t
et_int	ss/eval.h	/^  et_int,			\/* signed integer result *\/$/;"	e	enum:eval_type_t
et_qword	ss/eval.h	/^  et_qword,			\/* unsigned qword length integer result *\/$/;"	e	enum:eval_type_t
et_sqword	ss/eval.h	/^  et_sqword,			\/* signed qword length integer result *\/$/;"	e	enum:eval_type_t
et_symbol	ss/eval.h	/^  et_symbol,			\/* non-numeric result (!allowed in exprs)*\/$/;"	e	enum:eval_type_t
et_uint	ss/eval.h	/^  et_uint,			\/* unsigned integer result *\/$/;"	e	enum:eval_type_t
eval	ss/options.h	/^      int *eval;		\/* optional array of enum values *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
eval_as_addr	ss/eval.c	/^eval_as_addr(struct eval_value_t val)$/;"	f	signature:(struct eval_value_t val)
eval_as_addr	ss/eval.h	/^md_addr_t eval_as_addr(struct eval_value_t val);$/;"	p	signature:(struct eval_value_t val)
eval_as_double	ss/eval.c	/^eval_as_double(struct eval_value_t val)$/;"	f	signature:(struct eval_value_t val)
eval_as_double	ss/eval.h	/^double eval_as_double(struct eval_value_t val);$/;"	p	signature:(struct eval_value_t val)
eval_as_float	ss/eval.c	/^eval_as_float(struct eval_value_t val)$/;"	f	signature:(struct eval_value_t val)
eval_as_float	ss/eval.h	/^float eval_as_float(struct eval_value_t val);$/;"	p	signature:(struct eval_value_t val)
eval_as_int	ss/eval.c	/^eval_as_int(struct eval_value_t val)$/;"	f	signature:(struct eval_value_t val)
eval_as_int	ss/eval.h	/^int eval_as_int(struct eval_value_t val);$/;"	p	signature:(struct eval_value_t val)
eval_as_qword	ss/eval.c	/^eval_as_qword(struct eval_value_t val)$/;"	f	signature:(struct eval_value_t val)
eval_as_qword	ss/eval.h	/^qword_t eval_as_qword(struct eval_value_t val);$/;"	p	signature:(struct eval_value_t val)
eval_as_sqword	ss/eval.c	/^eval_as_sqword(struct eval_value_t val)$/;"	f	signature:(struct eval_value_t val)
eval_as_sqword	ss/eval.h	/^sqword_t eval_as_sqword(struct eval_value_t val);$/;"	p	signature:(struct eval_value_t val)
eval_as_uint	ss/eval.c	/^eval_as_uint(struct eval_value_t val)$/;"	f	signature:(struct eval_value_t val)
eval_as_uint	ss/eval.h	/^unsigned int eval_as_uint(struct eval_value_t val);$/;"	p	signature:(struct eval_value_t val)
eval_delete	ss/eval.c	/^eval_delete(struct eval_state_t *es)	\/* evaluator to delete *\/$/;"	f	signature:(struct eval_state_t *es)
eval_delete	ss/eval.h	/^eval_delete(struct eval_state_t *es);	\/* evaluator to delete *\/$/;"	p	signature:(struct eval_state_t *es)
eval_err_str	ss/eval.c	/^char *eval_err_str[ERR_NUM] = {$/;"	v
eval_err_t	ss/eval.h	/^enum eval_err_t {$/;"	g
eval_error	ss/eval.c	/^enum eval_err_t eval_error = ERR_NOERR;$/;"	v	typeref:enum:eval_err_t
eval_expr	ss/eval.c	/^eval_expr(struct eval_state_t *es,	\/* expression evaluator *\/$/;"	f	signature:(struct eval_state_t *es, char *p, char **endp)
eval_expr	ss/eval.h	/^eval_expr(struct eval_state_t *es,	\/* expression evaluator *\/$/;"	p	signature:(struct eval_state_t *es, char *p, char **endp)
eval_ident_t	ss/eval.h	/^(*eval_ident_t)(struct eval_state_t *es); \/* ident string in es->tok_buf *\/$/;"	t	typeref:struct:eval_ident_t
eval_new	ss/eval.c	/^eval_new(eval_ident_t f_eval_ident,	\/* user ident evaluator *\/$/;"	f	signature:(eval_ident_t f_eval_ident, void *user_ptr)
eval_new	ss/eval.h	/^eval_new(eval_ident_t f_eval_ident,	\/* user ident evaluator *\/$/;"	p	signature:(eval_ident_t f_eval_ident, void *user_ptr)
eval_print	ss/eval.c	/^eval_print(FILE *stream,		\/* output stream *\/$/;"	f	signature:(FILE *stream, struct eval_value_t val)
eval_print	ss/eval.h	/^eval_print(FILE *stream,		\/* output stream *\/$/;"	p	signature:(FILE *stream, struct eval_value_t val)
eval_state_t	ss/eval.h	/^struct eval_state_t {$/;"	s
eval_state_t::f_eval_ident	ss/eval.h	/^  eval_ident_t f_eval_ident;	\/* identifier evaluator *\/$/;"	m	struct:eval_state_t	access:public
eval_state_t::lastp	ss/eval.h	/^  char *lastp;			\/* save space for token peeks *\/$/;"	m	struct:eval_state_t	access:public
eval_state_t::p	ss/eval.h	/^  char *p;			\/* ptr to next char to consume from expr *\/$/;"	m	struct:eval_state_t	access:public
eval_state_t::peek_tok	ss/eval.h	/^  enum eval_token_t peek_tok;	\/* peek buffer, for one token look-ahead *\/$/;"	m	struct:eval_state_t	typeref:enum:eval_state_t::eval_token_t	access:public
eval_state_t::tok_buf	ss/eval.h	/^  char tok_buf[512];		\/* text of last token returned *\/$/;"	m	struct:eval_state_t	access:public
eval_state_t::user_ptr	ss/eval.h	/^  void *user_ptr;		\/* user-supplied argument pointer *\/$/;"	m	struct:eval_state_t	access:public
eval_token_t	ss/eval.h	/^enum eval_token_t {$/;"	g
eval_type_str	ss/eval.c	/^char *eval_type_str[et_NUM] = {$/;"	v
eval_type_t	ss/eval.h	/^enum eval_type_t {$/;"	g
eval_value_t	ss/eval.h	/^struct eval_value_t {$/;"	s
eval_value_t::__anon19::as_addr	ss/eval.h	/^    md_addr_t as_addr;			\/* value for type == et_addr *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::__anon19::as_double	ss/eval.h	/^    double as_double;			\/* value for type == et_double *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::__anon19::as_float	ss/eval.h	/^    float as_float;			\/* value for type == et_float *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::__anon19::as_int	ss/eval.h	/^    int as_int;				\/* value for type == et_int *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::__anon19::as_qword	ss/eval.h	/^    qword_t as_qword;			\/* value for type == ec_qword *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::__anon19::as_sqword	ss/eval.h	/^    sqword_t as_sqword;			\/* value for type == ec_sqword *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::__anon19::as_symbol	ss/eval.h	/^    char *as_symbol;			\/* value for type == et_symbol *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::__anon19::as_uint	ss/eval.h	/^    unsigned int as_uint;		\/* value for type == et_uint *\/$/;"	m	union:eval_value_t::__anon19	access:public
eval_value_t::type	ss/eval.h	/^  enum eval_type_t type;		\/* type of expression value *\/$/;"	m	struct:eval_value_t	typeref:enum:eval_value_t::eval_type_t	access:public
eval_value_t::value	ss/eval.h	/^  } value;$/;"	m	struct:eval_value_t	typeref:union:eval_value_t::__anon19	access:public
exec	loops.h	/^    int             exec;       \/\/maximum exec count$/;"	m	struct:loop_t	access:public
exec_count	infeasible.h	/^  int        exec_count;      \/\/ constraint for execution count as determined from DFA (-1 if undetermined)$/;"	m	struct:__anon12	access:public
exec_count	tcfg.h	/^	int exec_count; \/\/ vivy: for infeasible path constraints$/;"	m	struct:__anon38	access:public
execute	symexec.c	/^int     execute();$/;"	p	file:
execute	symexec.c	/^int execute() {$/;"	f
exit_loop	loops.c	/^static int exit_loop(tcfg_edge_t *e) {$/;"	f	file:	signature:(tcfg_edge_t *e)
exits	loops.h	/^    tcfg_elink_t    *exits;$/;"	m	struct:loop_t	access:public
exo_address_t	ss/machine.h	/^typedef qword_t exo_address_t;$/;"	t
exo_float_t	ss/machine.h	/^typedef double exo_float_t;$/;"	t
exo_integer_t	ss/machine.h	/^typedef qword_t exo_integer_t;$/;"	t
expandAddrExpr	symexec.c	/^void expandAddrExpr(expr_p exp, reg_t  *addrExpr) {$/;"	f	signature:(expr_p exp, reg_t *addrExpr)
expandAddrExpr	symexec.h	/^void expandAddrExpr(expr_p exp, reg_t *addrExpr);$/;"	p	signature:(expr_p exp, reg_t *addrExpr)
expr	ss/eval.c	/^expr(struct eval_state_t *es)		\/* expression evaluator *\/$/;"	f	file:	signature:(struct eval_state_t *es)
expr	ss/eval.c	/^static struct eval_value_t expr(struct eval_state_t *es);$/;"	p	file:	signature:(struct eval_state_t *es)
expr	symexec.h	/^	expr_p expr;$/;"	m	struct:__anon17	access:public
exprEq	reg.c	/^int exprEq(expr_p expr1, expr_p expr2) {$/;"	f	signature:(expr_p expr1, expr_p expr2)
exprEq	symexec.h	/^int exprEq(expr_p expr1, expr_p expr2);$/;"	p	signature:(expr_p expr1, expr_p expr2)
expr_p	symexec.h	/^typedef struct linear_expr * expr_p;$/;"	t	typeref:struct:linear_expr
expr_s	symexec.h	/^typedef struct linear_expr expr_s;$/;"	t	typeref:struct:linear_expr
ext	ss/misc.c	/^  char *ext;$/;"	m	struct:__anon21	file:	access:public
extend_cpred_times	pipeline.c	/^int *** extend_cpred_times;$/;"	v
extractl	ss/misc.c	/^extractl(int word,		\/* the word from which to extract *\/$/;"	f	signature:(int word, int pos, int num)
extractl	ss/misc.h	/^extractl(int word,		\/* the word from which to extract *\/$/;"	p	signature:(int word, int pos, int num)
f	ss/machine.h	/^  sfloat_t f[MD_NUM_FREGS];	\/* single-precision floating point view *\/$/;"	m	union:__anon22	access:public
fBigendian	ss/ecoff.h	/^  unsigned fBigendian :1;$/;"	m	struct:ecoff_fdr	access:public
fMerge	ss/ecoff.h	/^  unsigned fMerge :1;$/;"	m	struct:ecoff_fdr	access:public
fReadin	ss/ecoff.h	/^  unsigned fReadin :1;$/;"	m	struct:ecoff_fdr	access:public
f_add	ss/eval.c	/^f_add(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:	signature:(struct eval_value_t val1, struct eval_value_t val2)
f_div	ss/eval.c	/^f_div(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:	signature:(struct eval_value_t val1, struct eval_value_t val2)
f_eq_zero	ss/eval.c	/^f_eq_zero(struct eval_value_t val1)$/;"	f	file:	signature:(struct eval_value_t val1)
f_eval_ident	ss/eval.h	/^  eval_ident_t f_eval_ident;	\/* identifier evaluator *\/$/;"	m	struct:eval_state_t	access:public
f_flags	ss/ecoff.h	/^  unsigned short f_flags;$/;"	m	struct:ecoff_filehdr	access:public
f_magic	ss/ecoff.h	/^  unsigned short f_magic;$/;"	m	struct:ecoff_filehdr	access:public
f_mult	ss/eval.c	/^f_mult(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:	signature:(struct eval_value_t val1, struct eval_value_t val2)
f_neg	ss/eval.c	/^f_neg(struct eval_value_t val1)$/;"	f	file:	signature:(struct eval_value_t val1)
f_nscns	ss/ecoff.h	/^  unsigned short f_nscns;$/;"	m	struct:ecoff_filehdr	access:public
f_nsyms	ss/ecoff.h	/^  int f_nsyms;$/;"	m	struct:ecoff_filehdr	access:public
f_opthdr	ss/ecoff.h	/^  unsigned short f_opthdr;$/;"	m	struct:ecoff_filehdr	access:public
f_orphan_fn	ss/options.c	/^f_orphan_fn(int i, int argc, char **argv)$/;"	f	signature:(int i, int argc, char **argv)
f_sub	ss/eval.c	/^f_sub(struct eval_value_t val1, struct eval_value_t val2)$/;"	f	file:	signature:(struct eval_value_t val1, struct eval_value_t val2)
f_symptr	ss/ecoff.h	/^  int f_symptr;$/;"	m	struct:ecoff_filehdr	access:public
f_timdat	ss/ecoff.h	/^  int f_timdat;$/;"	m	struct:ecoff_filehdr	access:public
factor	ss/eval.c	/^factor(struct eval_state_t *es)		\/* expression evaluator *\/$/;"	f	file:	signature:(struct eval_state_t *es)
fatal	ss/misc.c	/^fatal(char *fmt, ...)$/;"	f	signature:(char *fmt, ...)
fatal	ss/misc.h	/^fatal(char *fmt, ...);$/;"	p	signature:(char *fmt, ...)
fatal_hook	ss/misc.c	/^fatal_hook(void (*fn)(FILE *stream))	\/* fatal hook function *\/$/;"	f	signature:(void (*fn)(FILE *stream))
fatal_hook	ss/misc.h	/^fatal_hook(void (*hook_fn)(FILE *stream));	\/* fatal hook function *\/$/;"	p	signature:(void (*hook_fn)(FILE *stream))
fcc	ss/machine.h	/^  int fcc;			\/* floating point condition codes *\/$/;"	m	struct:__anon23	access:public
fetch_dep	estimate.c	/^fetch_dep(egraph_edge_t *e)$/;"	f	file:	signature:(egraph_edge_t *e)
fetch_speed	ss/my_opt.c	/^int fetch_speed = 1;$/;"	v
fetch_width	ss/my_opt.c	/^int fetch_width;$/;"	v
fetch_width_depends	ss/ss_exegraph.c	/^static void fetch_width_depends(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
fetch_width_depends_m	ss/ss_exegraph.c	/^static void fetch_width_depends_m(int inst) {$/;"	f	file:	signature:(int inst)
fetch_width_depends_n	ss/ss_exegraph.c	/^static void fetch_width_depends_n(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
fifo_ibuf_depends	ss/ss_exegraph.c	/^static void fifo_ibuf_depends() {$/;"	f	file:
fifo_rob_depends	ss/ss_exegraph.c	/^static void fifo_rob_depends() {$/;"	f	file:
file	ss/machine.h	/^  enum md_reg_type file;	\/* register file *\/$/;"	m	struct:md_reg_names_t	typeref:enum:md_reg_names_t::md_reg_type	access:public
filp	ilp.c	/^FILE *filp, *fusr;$/;"	v
fin	exegraph.h	/^    range_t	    rdy, str, fin;	\/\/ ready, start, finish$/;"	m	struct:__anon32	access:public
findBlkAddr	scp_address.c	/^worklist_p  findBlkAddr(int blkAddr, worklist_p SAddrSet) {$/;"	f	signature:(int blkAddr, worklist_p SAddrSet)
findBlkAddr	scp_address.h	/^worklist_p  findBlkAddr(int addrBlk, worklist_p SAddrSet);$/;"	p	signature:(int addrBlk, worklist_p SAddrSet)
findReg	reg.c	/^int findReg(reg_t *regList, char regName[] ) {$/;"	f	signature:(reg_t *regList, char regName[] )
findReg	symexec.h	/^int findReg(reg_t *regList, char regName[]);$/;"	p	signature:(reg_t *regList, char regName[])
find_cond_exit	ilp.c	/^static void find_cond_exit(int lp_id, tcfg_edge_t *edge) {$/;"	f	file:	signature:(int lp_id, tcfg_edge_t *edge)
find_cond_exit	pipeline.c	/^static void find_cond_exit(int lp_id, tcfg_edge_t *edge, int num_inst) {$/;"	f	file:	signature:(int lp_id, tcfg_edge_t *edge, int num_inst)
find_hitloop	cache.c	/^find_hitloop()$/;"	f	file:
find_loops	loops.c	/^void find_loops() {$/;"	f
find_loops	loops.h	/^void find_loops();$/;"	p	signature:()
find_mlat_mpinst	pipeline.c	/^static void find_mlat_mpinst() {$/;"	f	file:
find_sep	estimate.c	/^find_sep()$/;"	f	file:
findproc	main.c	/^int findproc(int addr) {$/;"	f	signature:(int addr)
first_b	estimate.c	/^int		last_p, last_np, first_b, last_b, first_e;$/;"	v
first_e	estimate.c	/^int		last_p, last_np, first_b, last_b, first_e;$/;"	v
flag	exegraph.h	/^    char	    flag;$/;"	m	struct:__anon32	access:public
flag	infeasible.h	/^  int   flag; \/\/mark special opr, e.g. induction operation$/;"	m	struct:__anon8	access:public
flag	scp_address.h	/^    int                     flag;   \/*0: cannot renew, 1: can renew*\/ $/;"	m	struct:scoped_address	access:public
flag	scp_address.h	/^    int flag;$/;"	m	struct:temporal_scope	access:public
flag	scp_cache.h	/^	int flag;$/;"	m	struct:scope_block	access:public
flag	symexec.h	/^	int flag;$/;"	m	struct:BIV	access:public
flag	symexec.h	/^	int flag;$/;"	m	struct:__anon17	access:public
flag_emap	ss/options.c	/^static char *flag_emap[NUM_FLAGS] = {$/;"	v	file:
flag_eval	ss/options.c	/^static int flag_eval[NUM_FLAGS] = {$/;"	v	file:
flags	bpred.h	/^    int		flags;$/;"	m	struct:__anon1	access:public
flags	cfg.h	/^    int		flags;		\/\/ for traverse usage$/;"	m	struct:__anon3	access:public
flags	cfg.h	/^    int		flags;$/;"	m	struct:proc_t	access:public
flags	loops.h	/^    int		        flags;$/;"	m	struct:loop_t	access:public
flags	tcfg.h	/^	int flags;$/;"	m	struct:tcfg_edge_t	access:public
flags	tcfg.h	/^	unsigned flags;$/;"	m	struct:__anon38	access:public
flags2str	ss/symbol.c	/^flags2str(unsigned int flags)	\/* bfd symbol flags *\/$/;"	f	file:	signature:(unsigned int flags)
flush_on_syscalls	ss/my_opt.c	/^int flush_on_syscalls;$/;"	v
for_counter	ss/machine.h	571;"	d
for_counter	ss/machine.h	575;"	d
for_double	ss/options.h	/^    } for_double;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_double_t	access:public
for_enum	ss/options.h	/^    } for_enum;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
for_float	ss/options.h	/^    } for_float;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_float_t	access:public
for_int	ss/options.h	/^    } for_int;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_int_t	access:public
for_string	ss/options.h	/^    } for_string;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_string_t	access:public
for_uint	ss/options.h	/^    } for_uint;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_uint_t	access:public
format	ss/options.h	/^  char *format;			\/* option value print format *\/$/;"	m	struct:opt_opt_t	access:public
fprintInstr	infdump.c	/^void fprintInstr(FILE *fp, insn_t *is ) {$/;"	f	signature:(FILE *fp, insn_t *is )
frameoffset	ss/ecoff.h	/^  int frameoffset;$/;"	m	struct:ecoff_pdr	access:public
framereg	ss/ecoff.h	/^  short framereg;$/;"	m	struct:ecoff_pdr	access:public
freeAll	symexec.c	/^static void freeAll() {$/;"	f	file:
freeAll	symexec.c	/^static void freeAll();$/;"	p	file:
freeBIV	reg.c	/^void freeBIV(biv_p *biv) {$/;"	f	signature:(biv_p *biv)
freeCacheLine	unicache.c	/^static void freeCacheLine(acs_p acl) {$/;"	f	file:	signature:(acs_p acl)
freeCacheSet	unicache.c	/^static void freeCacheSet(acs_p* acs) {$/;"	f	file:	signature:(acs_p* acs)
freeCacheState	unicache.c	/^static void freeCacheState(acs_p** acs) {$/;"	f	file:	signature:(acs_p** acs)
freeExpr	symexec_value.c	/^void freeExpr(expr_p expr) {$/;"	f	signature:(expr_p expr)
freeList	common.c	/^void freeList(worklist_p *Wlist) {$/;"	f	signature:(worklist_p *Wlist)
freeList	common.h	/^void freeList(worklist_p *Wlist);$/;"	p	signature:(worklist_p *Wlist)
freeMem	scp_tscope.c	/^void freeMem() {$/;"	f
freeMemBlk	symexec.c	/^void freeMemBlk(mem_p *memBlk) {$/;"	f	signature:(mem_p *memBlk)
freeMemBlock	unicache.c	/^static void freeMemBlock(mem_blk_set_t* head) {$/;"	f	file:	signature:(mem_blk_set_t* head)
freeMemList	symexec.c	/^void freeMemList(worklist_p *memList) {$/;"	f	signature:(worklist_p *memList)
free_queue	common.c	/^free_queue(Queue *queue)$/;"	f	signature:(Queue *queue)
free_stack	common.c	/^free_stack(Stack *stack)$/;"	f	signature:(Stack *stack)
fregmask	ss/ecoff.h	/^  int fregmask;$/;"	m	struct:ecoff_pdr	access:public
fregoffset	ss/ecoff.h	/^  int fregoffset;$/;"	m	struct:ecoff_pdr	access:public
freq	cfg.h	/^	int freq;$/;"	m	struct:ovrl_graph	access:public
fu	exegraph.h	/^    char	    fu, num_fu;		\/\/ applicable to EX nodes$/;"	m	struct:__anon32	access:public
fu2pfu	ss/ss_machine.c	/^enum ss_pfu_class fu2pfu[] = {$/;"	v	typeref:enum:ss_pfu_class
fu_config	ss/my_opt.c	/^struct res_desc fu_config[] = { { "integer-ALU", 1, 0, { { IntALU, 1, 1 } } }, {$/;"	v	typeref:struct:res_desc
fu_lat	ss/ss_exegraph.c	/^static range16_t fu_lat[] = { { 1, 1 }, \/\/ FUClass_NA = 0,$/;"	v	file:
fu_lat	ss/ss_machine.c	/^range_t fu_lat[] = {$/;"	v
fusr	ilp.c	/^FILE *filp, *fusr;$/;"	v
gcd	address.c	/^int gcd ( int a, int b )$/;"	f	signature:( int a, int b )
gcd	address.h	/^int gcd(int a, int b);$/;"	p	signature:(int a, int b)
gcd	symexec.c	/^extern int gcd(int a, int b);$/;"	p	file:	signature:(int a, int b)
gcd	unicache.c	/^extern int gcd(int a, int b);$/;"	p	file:	signature:(int a, int b)
gen	cache.c	/^mem_blk_t	    **gen;$/;"	v
genAccessAddress	scp_address.h	/^void genAccessAddress(dat_inst_t *d_inst, inf_node_t* ib);$/;"	p	signature:(dat_inst_t *d_inst, inf_node_t* ib)
genAccessAddress	scp_tscope.c	/^void genAccessAddress(dat_inst_t *d_inst, inf_node_t* ib) {$/;"	f	signature:(dat_inst_t *d_inst, inf_node_t* ib)
getAddrBaseIndex	address.c	/^ric_p getAddrBaseIndex(de_inst_t* inst, int base, int index, int opt)$/;"	f	signature:(de_inst_t* inst, int base, int index, int opt)
getAddrBaseIndex	unicache.c	/^extern ric_p getAddrBaseIndex(de_inst_t* inst, int base, int index, int opt);$/;"	p	file:	signature:(de_inst_t* inst, int base, int index, int opt)
getAddrBaseOffset	address.c	/^ric_p getAddrBaseOffset(de_inst_t* inst, int base, int offset, int opt)$/;"	f	signature:(de_inst_t* inst, int base, int offset, int opt)
getAddrBaseOffset	unicache.c	/^extern ric_p getAddrBaseOffset(de_inst_t* inst, int base, int offset, int opt);$/;"	p	file:	signature:(de_inst_t* inst, int base, int offset, int opt)
getAddrD	symexec.c	/^int getAddrD(dat_inst_t *d_inst) {$/;"	f	signature:(dat_inst_t *d_inst)
getAddrD	symexec.h	/^int getAddrD(dat_inst_t* datInst);$/;"	p	signature:(dat_inst_t* datInst)
getAllLoopNodes	address.c	/^static slist_p getAllLoopNodes(int loop_id)$/;"	f	file:	signature:(int loop_id)
getCardinality	unicache.c	/^static int getCardinality(mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(mem_blk_set_t* mem_blk_set)
getDirName	infdump.c	/^char *getDirName( int dir ) {$/;"	f	signature:( int dir )
getDstCtx	ss/ss_exegraph.c	/^int getDstCtx(int ctx, int ctx_length, int bbi_id) {$/;"	f	signature:(int ctx, int ctx_length, int bbi_id)
getIbLB	scp_tscope.c	/^int getIbLB(inf_node_t *ib) {$/;"	f	signature:(inf_node_t *ib)
getIbLoop	scp_tscope.c	/^extern loop_t *getIbLoop(inf_node_t *ib);$/;"	p	file:	signature:(inf_node_t *ib)
getIbLoop	symexec.c	/^loop_t* getIbLoop(inf_node_t *ib) {$/;"	f	signature:(inf_node_t *ib)
getLength	ilp.c	/^static int getLength(int x) {$/;"	f	file:	signature:(int x)
getLoopBound	address.c	/^static int getLoopBound(loop_t* loop)$/;"	f	file:	signature:(loop_t* loop)
getLpBound	scp_tscope.c	/^static int getLpBound(loop_t *lp) {$/;"	f	file:	signature:(loop_t *lp)
getMemoryBlockOfSet	unicache.c	/^static mem_blk_set_t* getMemoryBlockOfSet(mem_blk_set_t* mem_blk, int set) {$/;"	f	file:	signature:(mem_blk_set_t* mem_blk, int set)
getMemoryBlocks	unicache.c	/^static mem_blk_set_t* getMemoryBlocks(ric_p addr) {$/;"	f	file:	signature:(ric_p addr)
getNextElem	common.c	/^int getNextElem(char *str, int *pos, char *token) {$/;"	f	signature:(char *str, int *pos, char *token)
getNextElem	common.h	/^int getNextElem(char *str, int *pos, char *token);$/;"	p	signature:(char *str, int *pos, char *token)
getNextToken	common.c	/^int getNextToken(char *token, char *str, char *pos, char *delim) {$/;"	f	signature:(char *token, char *str, char *pos, char *delim)
getShiftedBlock	unicache.c	/^static int getShiftedBlock(unsigned int tblock);$/;"	p	file:	signature:(unsigned int tblock)
get_context_backward	pipeline.c	/^int get_context_backward(int dst_ctx, int src_length, int dst_length) {$/;"	f	signature:(int dst_ctx, int src_length, int dst_length)
get_context_forward	pipeline.c	/^int get_context_forward(int src_ctx, int src_length, int dst_legnth) {$/;"	f	signature:(int src_ctx, int src_length, int dst_legnth)
get_jptable	main.c	/^void get_jptable(addr_t src, int index, addr_t * target) {$/;"	f	signature:(addr_t src, int index, addr_t * target)
get_jptable_static	main.c	/^int get_jptable_static(addr_t src, addr_t * target) {$/;"	f	signature:(addr_t src, addr_t * target)
get_loop_affected_sets	pipeline.c	/^static void get_loop_affected_sets(int lp_id, tcfg_edge_t *mp_edge,$/;"	f	file:	signature:(int lp_id, tcfg_edge_t *mp_edge, int num_inst)
get_loop_tags	cache.c	/^get_loop_tags()$/;"	f	file:
get_mblk_hitmiss	cache.c	/^get_mblk_hitmiss(tcfg_node_t* bbi, int mblk_id, loop_t* lp)$/;"	f	signature:(tcfg_node_t* bbi, int mblk_id, loop_t* lp)
get_mblk_hitmiss_l2	cache.c	/^get_mblk_hitmiss_l2(tcfg_node_t* bbi, int mblk_id, loop_t* lp)$/;"	f	signature:(tcfg_node_t* bbi, int mblk_id, loop_t* lp)
get_mblk_hitmiss_ul2	scp_cache.c	/^int get_mblk_hitmiss_ul2(tcfg_node_t* bbi, int mblk_id, loop_t* lp,$/;"	f	signature:(tcfg_node_t* bbi, int mblk_id, loop_t* lp, int contextMask)
get_mblk_hitmiss_ul2	scp_cache.h	/^int get_mblk_hitmiss_ul2(tcfg_node_t*, int, loop_t*, int);$/;"	p	signature:(tcfg_node_t*, int, loop_t*, int)
get_mblks	cache.c	/^get_mblks()$/;"	f
get_mp_conflicts	cache.c	/^get_mp_conflicts(tcfg_node_t *bbi)$/;"	f	file:	signature:(tcfg_node_t *bbi)
get_next_token	ss/eval.c	/^get_next_token(struct eval_state_t *es)	\/* expression evaluator *\/$/;"	f	file:	signature:(struct eval_state_t *es)
getcore	ss/misc.c	/^getcore(int nbytes)$/;"	f	signature:(int nbytes)
getcore	ss/misc.h	/^void *getcore(int nbytes);$/;"	p	signature:(int nbytes)
getcwd	ss/options.c	58;"	d	file:
getticks	common.c	/^ticks getticks() {$/;"	f
getticks	test.c	/^static __inline__ ticks getticks(void)$/;"	f	file:	signature:(void)
gp_value	ss/ecoff.h	/^  int gp_value;$/;"	m	struct:ecoff_aouthdr	access:public
gprmask	ss/ecoff.h	/^  int gprmask;$/;"	m	struct:ecoff_aouthdr	access:public
gzclose	ss/misc.c	/^gzclose(FILE *fd)$/;"	f	signature:(FILE *fd)
gzclose	ss/misc.h	/^void gzclose(FILE *fd);$/;"	p	signature:(FILE *fd)
gzcmds	ss/misc.c	/^} gzcmds[] = {$/;"	v	typeref:struct:__anon21	file:
gzopen	ss/misc.c	/^gzopen(char *fname, char *type)$/;"	f	signature:(char *fname, char *type)
gzopen	ss/misc.h	/^FILE *gzopen(char *fname, char *type);$/;"	p	signature:(char *fname, char *type)
half_t	ss/host.h	/^typedef unsigned short half_t;		\/* half - 16 bits *\/$/;"	t
handle_first_mblk	cache.c	/^handle_first_mblk(int bbi_id)$/;"	f	file:	signature:(int bbi_id)
handle_mpmiss	pipeline.c	/^static void handle_mpmiss() {$/;"	f	file:
handle_other_mblk	cache.c	/^handle_other_mblk(int bbi_id, int start_mb)$/;"	f	file:	signature:(int bbi_id, int start_mb)
hashtab	common.h	/^struct hashtab {$/;"	s
hashtab::entry	common.h	/^		  void* entry;$/;"	m	struct:hashtab	access:public
hashtab::next	common.h	/^		  struct hashtab* next;$/;"	m	struct:hashtab	typeref:struct:hashtab::hashtab	access:public
hashtab_p	common.h	/^typedef struct hashtab* hashtab_p;$/;"	t	typeref:struct:hashtab
hashtab_s	common.h	/^typedef struct hashtab hashtab_s;$/;"	t	typeref:struct:hashtab
head	common.h	/^    void    *head, *tail;   \/* head points to oldest element *\/$/;"	m	struct:queue_t	access:public
head	loops.h	/^    tcfg_node_t	    *head;	\/\/ [head, tail]$/;"	m	struct:loop_t	access:public
header	ss/options.h	/^  char *header;			\/* options header *\/$/;"	m	struct:opt_odb_t	access:public
hexValue	common.c	/^int hexValue( char *hexStr ) {$/;"	f	signature:( char *hexStr )
hexValue	common.h	/^int hexValue (char *hexStr);$/;"	p	signature:(char *hexStr)
hi	common.h	/^    char lo, hi;$/;"	m	struct:__anon37	access:public
hi	common.h	/^    int	    lo, hi;$/;"	m	struct:__anon35	access:public
hi	common.h	/^    short int	lo, hi;$/;"	m	struct:__anon36	access:public
hi	ss/machine.h	/^  sword_t hi, lo;		\/* multiplier HI\/LO result registers *\/$/;"	m	struct:__anon23	access:public
hm_str	ilp.c	/^static void hm_str(int edge_id, int hm) {$/;"	f	file:	signature:(int edge_id, int hm)
hm_term	ilp.c	/^static void hm_term(FILE *fp, int edge_id, int hm, char *prefix, char *suffix) {$/;"	f	file:	signature:(FILE *fp, int edge_id, int hm, char *prefix, char *suffix)
hook_fn	ss/misc.c	/^static void (*hook_fn)(FILE *stream) = NULL;$/;"	v	file:
i1_u1_ps	unicache.c	/^int i1_u1_ps = 0;$/;"	v
iauxBase	ss/ecoff.h	/^  int iauxBase;$/;"	m	struct:ecoff_fdr	access:public
iauxMax	ss/ecoff.h	/^  int iauxMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ibuf_mpred_depends	ss/ss_exegraph.c	/^static void ibuf_mpred_depends(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
ibuf_normal_depends	ss/ss_exegraph.c	/^static void ibuf_normal_depends(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
ic_flag	pipeline.h	/^	short ic_flag;$/;"	m	struct:__anon34	access:public
ic_flag_l2	pipeline.h	/^	short ic_flag_l2;$/;"	m	struct:__anon34	access:public
id	bpred.h	/^    int		id;$/;"	m	struct:__anon1	access:public
id	cfg.h	/^    int		id;		\/\/ basic block id (per procedure)$/;"	m	struct:__anon3	access:public
id	cfg.h	/^    int		id;		\/\/ proc id$/;"	m	struct:proc_t	access:public
id	loops.h	/^    int		        id;$/;"	m	struct:loop_t	access:public
id	tcfg.h	/^	int id; \/\/ global id in tcfg (has nothing to do with its bb id)$/;"	m	struct:__anon38	access:public
id	tcfg.h	/^	int id;$/;"	m	struct:tcfg_edge_t	access:public
identify_loops	cfg.c	/^identify_loops(proc_t *proc)$/;"	f	file:	signature:(proc_t *proc)
idnMax	ss/ecoff.h	/^  int idnMax;$/;"	m	struct:ecoff_symhdr_t	access:public
iextMax	ss/ecoff.h	/^  int iextMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ifd	ss/ecoff.h	/^  short ifd;$/;"	m	struct:ecoff_EXTR	access:public
ifdMax	ss/ecoff.h	/^  int ifdMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ignoreRegUpdate	symexec.c	/^int ignoreRegUpdate(char *r) {$/;"	f	signature:(char *r)
iline	ss/ecoff.h	/^  int iline;$/;"	m	struct:ecoff_pdr	access:public
ilineBase	ss/ecoff.h	/^  int ilineBase;$/;"	m	struct:ecoff_fdr	access:public
ilineMax	ss/ecoff.h	/^  int ilineMax;$/;"	m	struct:ecoff_symhdr_t	access:public
imm	isa.h	/^	 int 		 imm;					\/* Immediate integer value. For base $/;"	m	struct:__anon16	access:public
in	bpred.h	/^    bfg_edge_t	*in;	\/\/ in edges$/;"	m	struct:__anon1	access:public
in	cfg.h	/^    cfg_edge_t	**in;		\/\/ incoming edges$/;"	m	struct:__anon3	access:public
in	exegraph.h	/^    egraph_edge_t   *in, *out;$/;"	m	struct:__anon32	access:public
in	isa.h	/^    int	    *in, *out;		   \/* input\/output operands (registers) *\/$/;"	m	struct:__anon16	access:public
in	tcfg.h	/^	tcfg_edge_t *in, *out; \/\/ incoming and outgoing edges$/;"	m	struct:__anon38	access:public
in_abs_mem_value	cfg.h	/^	 abs_mem_p in_abs_mem_value;  \/* A data structure holding value in abstract *\/$/;"	m	struct:__anon3	access:public
in_abs_reg_value	cfg.h	/^	 ric_p* in_abs_reg_value;	\/* values. Register numbers can directly be *\/$/;"	m	struct:__anon3	access:public
include_proc	main.c	/^char *include_proc;$/;"	v
index	main.c	/^	int index;$/;"	m	struct:jptb	file:	access:public
index	ss/ecoff.h	/^  unsigned index :20;$/;"	m	struct:ecoff_SYMR	access:public
inf_cfg	infeasible.h	/^  inf_node_t *inf_cfg;$/;"	m	struct:__anon13	access:public
inf_loop_t	infeasible.h	/^} inf_loop_t;$/;"	t	typeref:struct:__anon14
inf_loops	infeasible.h	/^inf_loop_t *inf_loops;$/;"	v
inf_node_t	infeasible.h	/^} inf_node_t;$/;"	t	typeref:struct:__anon12
inf_proc_t	infeasible.h	/^} inf_proc_t;$/;"	t	typeref:struct:__anon13
inf_procs	infeasible.h	/^inf_proc_t *inf_procs;    \/\/ extension to cfg structure for infeasibility analysis$/;"	v
infeas_analysis	infeasible.c	/^void infeas_analysis( char *obj_file ) {$/;"	f	signature:( char *obj_file )
infeas_analysis	infeasible.h	/^void infeas_analysis( char *obj_file );$/;"	p	signature:( char *obj_file )
infeas_blockcount	ilp.c	/^int infeas_blockcount(tcfg_node_t *ib, int ctxt) {$/;"	f	signature:(tcfg_node_t *ib, int ctxt)
infeas_cons	ilp.c	/^int infeas_cons() {$/;"	f
infeas_nullifiers	ilp.c	/^int infeas_nullifiers(assign_t **nullifier_list, int num_nullifiers, int pid,$/;"	f	signature:(assign_t **nullifier_list, int num_nullifiers, int pid, int ctxt)
info	ss/misc.h	/^info(char *fmt, ...);$/;"	p	signature:(char *fmt, ...)
info	ss/misc.h	144;"	d
initAll	scp_tscope.c	/^void initAll(char *bin_fname) {$/;"	f	signature:(char *bin_fname)
initAll	symexec.c	/^static void initAll() {$/;"	f	file:
initAll	symexec.c	/^static void initAll();$/;"	p	file:
initBlock	symexec.c	/^static int initBlock() {$/;"	f	file:
initExpr	reg.c	/^void initExpr(expr_p expr) {$/;"	f	signature:(expr_p expr)
initExpr	symexec.h	/^void initExpr(expr_p expr);$/;"	p	signature:(expr_p expr)
initMem	scp_tscope.c	/^void initMem() {$/;"	f
initReg	reg.c	/^void initReg(reg_t *reg) {$/;"	f	signature:(reg_t *reg)
initReg	symexec.h	/^void initReg(reg_t *reg);$/;"	p	signature:(reg_t *reg)
initRegSet	reg.c	/^int initRegSet(reg_t *regList) {$/;"	f	signature:(reg_t *regList)
initRegSet	symexec.h	/^int initRegSet(reg_t *regList);$/;"	p	signature:(reg_t *regList)
initVal	symexec.h	/^	reg_t initVal;$/;"	m	struct:BIV	access:public
init_bfg	bpred.c	/^init_bfg()$/;"	f	file:
init_end_bbb	bpred.c	/^init_end_bbb()$/;"	f	file:
init_est	estimate.c	/^init_est()$/;"	f	file:
init_est_body	estimate.c	/^init_est_body()$/;"	f	file:
init_est_plog	estimate.c	/^init_est_plog()$/;"	f	file:
init_isa	isa.c	/^init_isa()$/;"	f
init_isa_ss	ss/ss_isa.c	/^init_isa_ss()$/;"	f
init_pa	pipeline.c	/^static void init_pa() {$/;"	f	file:
init_queue	common.c	/^init_queue(Queue *queue, int elem_size)$/;"	f	signature:(Queue *queue, int elem_size)
init_root_bbb	bpred.c	/^init_root_bbb()$/;"	f	file:
init_sep	estimate.c	/^init_sep()$/;"	f	file:
init_shaded_pnode	estimate.c	/^init_shaded_pnode(egraph_edge_t *e)$/;"	f	file:	signature:(egraph_edge_t *e)
init_stack	common.c	/^init_stack(Stack *stack, int elem_size)$/;"	f	signature:(Stack *stack, int elem_size)
init_tok_map	ss/eval.c	/^init_tok_map(void)$/;"	f	file:	signature:(void)
init_var_grps	ilp.c	/^static void init_var_grps() {$/;"	f	file:
initializeCache	unicache.c	/^static void initializeCache(tcfg_node_t* bbi) {$/;"	f	file:	signature:(tcfg_node_t* bbi)
initialize_CHMC	unicache.c	/^static void initialize_CHMC() {$/;"	f	file:
initialized	ss/symbol.h	/^  int initialized;		\/* initialized? (if data segment) *\/$/;"	m	struct:sym_sym_t	access:public
inorder_depends	ss/ss_exegraph.c	/^static void inorder_depends() {$/;"	f	file:
insn	symexec.h	/^	void *insn; \/\/instruction performs inductive operation$/;"	m	struct:BIV	access:public
insn	symexec.h	/^	void *insn;$/;"	m	struct:__anon18	access:public
insn_t	infeasible.h	/^} insn_t;$/;"	t	typeref:struct:__anon8
insnlist	infeasible.h	/^  insn_t     *insnlist;$/;"	m	struct:__anon12	access:public
insnlist_st	infeasible.h	/^insn_t *insnlist_st;      \/\/ preprocessing instructions$/;"	v
inst	cfg.h	/^		 de_inst_t* inst;$/;"	m	union:col_data::__anon6	access:public
inst	cfg.h	/^		 de_inst_t* inst;$/;"	m	union:ovrl_graph::__anon7	access:public
inst	exegraph.h	/^    short	    inst, stage;   $/;"	m	struct:__anon32	access:public
inst	pipeline.h	/^	de_inst_t *inst;$/;"	m	struct:__anon34	access:public
instAddr	scp_address.h	/^    int                 instAddr;   \/*Inst addr*\/$/;"	m	struct:scoped_address	access:public
instAddr	symexec.h	/^	long instAddr; \/*inst assigns value for this entry*\/$/;"	m	struct:sym_memory_model	access:public
inst_access	isa.h	/^	 ACCESS_T inst_access;		\/* Instruction access classification *\/$/;"	m	struct:__anon16	access:public
inst_addr	address.h	/^	int inst_addr;$/;"	m	struct:abs_mem	access:public
inst_age_l1	cache.h	/^char** inst_age_l1;$/;"	v
inst_age_l2	cache.h	/^char** inst_age_l2;$/;"	v
inst_block	scp_cache.h	/^	mem_blk_set_t* inst_block;\/* address of instruction memory block *\/$/;"	m	struct:scope_block	access:public
inst_cache_delay	tcfg.h	/^	int inst_cache_delay; \/* For instruction cache analysis using abstract$/;"	m	struct:__anon38	access:public
inst_chmc_l1	cache.h	/^char** inst_chmc_l1;$/;"	v
inst_chmc_l2	cache.h	/^char** inst_chmc_l2;$/;"	v
inst_coexists	ss/ss_exegraph.c	/^static void inst_coexists(int curr) {$/;"	f	file:	signature:(int curr)
inst_contends	ss/ss_exegraph.c	/^static void inst_contends(int curr) {$/;"	f	file:	signature:(int curr)
inst_num	common.h	47;"	d
inst_ps_loop_ul2	scp_cache.h	/^loop_t*** inst_ps_loop_ul2;$/;"	v
inst_psnc_ul2	scp_cache.h	/^char** inst_psnc_ul2;$/;"	v
inst_size	common.h	48;"	d
inst_type	isa.c	/^inst_type(de_inst_t *inst)$/;"	f	signature:(de_inst_t *inst)
inst_type_t	isa.h	/^enum inst_type_t {$/;"	g
inst_win_size_ss	ss/ss_machine.c	/^inst_win_size_ss()$/;"	f
inst_ys_set	scp_cache.h	/^	worklist_p inst_ys_set;\/* contains instruction memory blocks*\/$/;"	m	struct:scope_block	access:public
intervalLength	ilp.c	/^int intervalLength(int lw, int up, int f) {$/;"	f	signature:(int lw, int up, int f)
invalid	cfg.h	/^	int invalid;$/;"	m	struct:ovrl_graph	access:public
invalidateMemoryAloc	address.c	/^static void invalidateMemoryAloc(abs_mem_p abs_mem_st)$/;"	f	file:	signature:(abs_mem_p abs_mem_st)
iopt	ss/ecoff.h	/^  int iopt;$/;"	m	struct:ecoff_pdr	access:public
ioptBase	ss/ecoff.h	/^  int ioptBase;$/;"	m	struct:ecoff_fdr	access:public
ioptMax	ss/ecoff.h	/^  int ioptMax;$/;"	m	struct:ecoff_symhdr_t	access:public
ipdFirst	ss/ecoff.h	/^  unsigned short ipdFirst;$/;"	m	struct:ecoff_fdr	access:public
ipdMax	ss/ecoff.h	/^  int ipdMax;$/;"	m	struct:ecoff_symhdr_t	access:public
isBAConflict	conflicts.c	/^char isBAConflict( assign_t *A, branch_t *B, int r ) {  $/;"	f	signature:( assign_t *A, branch_t *B, int r )
isBBConflict	conflicts.c	/^char isBBConflict( branch_t *A, branch_t *B, int r1, int r2 ) {  $/;"	f	signature:( branch_t *A, branch_t *B, int r1, int r2 )
isDecNum	common.c	/^int isDecNum(char c) {$/;"	f	signature:(char c)
isDecNum	common.h	/^int isDecNum(char c);$/;"	p	signature:(char c)
isDeeper	infeasible.c	/^char isDeeper( int paft, int pbef ) {$/;"	f	signature:( int paft, int pbef )
isEmpty	common.c	/^int isEmpty(worklist_p Wlist)$/;"	f	signature:(worklist_p Wlist)
isEmpty	common.h	/^int isEmpty(worklist_p Wlist);$/;"	p	signature:(worklist_p Wlist)
isHexNum	common.c	/^int isHexNum(char c) {$/;"	f	signature:(char c)
isHexNum	common.h	/^int isHexNum(char c);$/;"	p	signature:(char c)
isInner	loops.c	/^int isInner(int lpId, int pLpId) {$/;"	f	signature:(int lpId, int pLpId)
isInner	loops.h	/^int isInner(int lpId, int pLpId);       \/\/return if lpId is inner pLpId$/;"	p	signature:(int lpId, int pLpId)
isLoadInst	address.c	/^static int isLoadInst(char* isa_name)$/;"	f	file:	signature:(char* isa_name)
isLoadInst	symexec.c	/^int isLoadInst(char *isa_name) {$/;"	f	signature:(char *isa_name)
isLoopBranch	conflicts.c	/^char isLoopBranch( cfg_node_t *bb ) {$/;"	f	signature:( cfg_node_t *bb )
isMemAccess	symexec.c	/^int isMemAccess(char* isa_name)$/;"	f	signature:(char* isa_name)
isResident	unicache.c	/^static int isResident(mem_blk_set_t* mem_blk_h, mem_blk_set_t* item) {$/;"	f	file:	signature:(mem_blk_set_t* mem_blk_h, mem_blk_set_t* item)
isStoreInst	address.c	/^static int isStoreInst(char* isa_name)$/;"	f	file:	signature:(char* isa_name)
isStoreInst	symexec.c	/^int isStoreInst(char *isa_name) {$/;"	f	signature:(char *isa_name)
is_lib_func	ss/ss_readfile.c	/^is_lib_func(char *func_name)$/;"	f	file:	signature:(char *func_name)
is_same_cache_block	unicache.c	/^static int is_same_cache_block(acs_p acs1, acs_p acs2) {$/;"	f	file:	signature:(acs_p acs1, acs_p acs2)
is_unconditional	tcfg.h	/^	char is_unconditional;$/;"	m	struct:__anon38	access:public
isa	isa.c	/^isa_t	*isa;		\/\/ info of the instruction types of the ISA$/;"	v
isa_t	isa.h	/^} isa_t;$/;"	t	typeref:struct:__anon15
iss	ss/ecoff.h	/^  int iss;$/;"	m	struct:ecoff_SYMR	access:public
issBase	ss/ecoff.h	/^  int issBase;$/;"	m	struct:ecoff_fdr	access:public
issExtMax	ss/ecoff.h	/^  int issExtMax;$/;"	m	struct:ecoff_symhdr_t	access:public
issMax	ss/ecoff.h	/^  int issMax;$/;"	m	struct:ecoff_symhdr_t	access:public
issue_width_depends	ss/ss_exegraph.c	/^static void issue_width_depends(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
issue_width_depends_m	ss/ss_exegraph.c	/^static void issue_width_depends_m(int inst) {$/;"	f	file:	signature:(int inst)
issue_width_depends_n	ss/ss_exegraph.c	/^static void issue_width_depends_n(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
issuelat	ss/resource.h	/^    int issuelat;			\/* issue latency: number of cycles$/;"	m	struct:res_desc::res_template	access:public
isym	ss/ecoff.h	/^  int isym;$/;"	m	struct:ecoff_pdr	access:public
isymBase	ss/ecoff.h	/^  int isymBase;$/;"	m	struct:ecoff_fdr	access:public
isymMax	ss/ecoff.h	/^  int isymMax;$/;"	m	struct:ecoff_symhdr_t	access:public
iterValue	scp_tscope.c	/^int *iterValue;$/;"	v
itlb_opt	ss/my_opt.c	/^char *itlb_opt;$/;"	v
joinBrach	symexec.c	/^static int  joinBrach(inf_proc_t *iproc, inf_node_t *ib, int lpHeaderId);$/;"	p	file:	signature:(inf_proc_t *iproc, inf_node_t *ib, int lpHeaderId)
joinBranch	symexec.c	/^static int joinBranch(inf_proc_t *iproc, inf_node_t *ib, int isLpHead) {$/;"	f	file:	signature:(inf_proc_t *iproc, inf_node_t *ib, int isLpHead)
joinCache	unicache.c	/^static acs_p* joinCache(acs_p* acs1, acs_p* arg, ANALYSIS_T type) {$/;"	f	file:	signature:(acs_p* acs1, acs_p* arg, ANALYSIS_T type)
joinCacheMay	unicache.c	/^static acs_p* joinCacheMay(acs_p* acs1, acs_p* arg) {$/;"	f	file:	signature:(acs_p* acs1, acs_p* arg)
joinCacheMust	unicache.c	/^static acs_p* joinCacheMust(acs_p* acs1, acs_p* arg) {$/;"	f	file:	signature:(acs_p* acs1, acs_p* arg)
joinCachePS	unicache.c	/^static acs_p* joinCachePS(acs_p* acs1, acs_p* arg) {$/;"	f	file:	signature:(acs_p* acs1, acs_p* arg)
joinMemoryAloc	address.c	/^static void joinMemoryAloc(abs_mem_p mem1, abs_mem_p* mem2)$/;"	f	file:	signature:(abs_mem_p mem1, abs_mem_p* mem2)
joinMemoryAloc	address.c	/^static void joinMemoryAloc(abs_mem_p mem1, abs_mem_p* mem2);$/;"	p	file:	signature:(abs_mem_p mem1, abs_mem_p* mem2)
jptb	main.c	/^typedef struct jptb {$/;"	s	file:
jptb	main.c	/^} jptb;$/;"	t	typeref:struct:jptb	file:
jptb::adr	main.c	/^	addr_t adr;$/;"	m	struct:jptb	file:	access:public
jptb::index	main.c	/^	int index;$/;"	m	struct:jptb	file:	access:public
jptb::ntarget	main.c	/^	int ntarget;$/;"	m	struct:jptb	file:	access:public
jptb::ptarget	main.c	/^	addr_t *ptarget;$/;"	m	struct:jptb	file:	access:public
jump_cond	infeasible.h	/^  char jump_cond;               \/\/ condition that makes a branch instruction jump$/;"	m	struct:branch_t	access:public
k	symexec.h	/^	int k;$/;"	m	struct:linear_expr	access:public
key	common.h	/^    int  key;$/;"	m	struct:priority_queue_t	access:public
l	ss/machine.h	/^  sword_t l[MD_NUM_FREGS];	\/* integer word view *\/$/;"	m	union:__anon22	access:public
l1	main.c	/^int X, Y, B, l1, l2;$/;"	v
l1_d1_ps	unicache.c	/^int l1_d1_ps = 0;$/;"	v
l1_i1_ps	unicache.c	/^int l1_i1_ps = 0;$/;"	v
l2	main.c	/^int X, Y, B, l1, l2;$/;"	v
l2_inst_access	isa.h	/^	 ACCESS_T l2_inst_access;	\/* L2 Instruction access classification *\/$/;"	m	struct:__anon16	access:public
l_contd	exegraph.h	/^    egraph_edge_t   *e_contd, *l_contd;$/;"	m	struct:__anon32	access:public
l_msk	cache.h	/^    unsigned	l_msk;	\/\/ block mask$/;"	m	struct:__anon26	access:public
lang	ss/ecoff.h	/^  unsigned lang :5;$/;"	m	struct:ecoff_fdr	access:public
largeint_t	ss/misc.c	/^typedef qword_t largeint_t;$/;"	t	file:
largeint_t	ss/misc.c	/^typedef word_t largeint_t;$/;"	t	file:
lastNode	scp_tscope.c	/^worklist_p lastNode;$/;"	v
last_b	estimate.c	/^int		last_p, last_np, first_b, last_b, first_e;$/;"	v
last_np	estimate.c	/^int		last_p, last_np, first_b, last_b, first_e;$/;"	v
last_p	estimate.c	/^int		last_p, last_np, first_b, last_b, first_e;$/;"	v
lastp	ss/eval.h	/^  char *lastp;			\/* save space for token peeks *\/$/;"	m	struct:eval_state_t	access:public
lat	exegraph.h	/^    range16_t	    lat;		\/\/ execution latency of EX nodes$/;"	m	struct:__anon32	access:public
lat	exegraph.h	/^    range16_t	    lat;	\/\/ max\/min latencies from src to dst$/;"	m	struct:egraph_edge_t	access:public
latest_time	estimate.c	/^latest_time(egraph_node_t *v)$/;"	f	file:	signature:(egraph_node_t *v)
lcontd_delay	estimate.c	/^lcontd_delay(egraph_node_t *v)$/;"	f	file:	signature:(egraph_node_t *v)
ld_load_prog	ss/loader.c	/^ld_load_prog(char *fname)		$/;"	f	signature:(char *fname)
ld_load_prog	ss/loader.h	/^ld_load_prog(char *fname);$/;"	p	signature:(char *fname)
ld_prog_entry	ss/loader.c	/^md_addr_t ld_prog_entry = 0;$/;"	v
ld_text_base	ss/ss_readfile.c	/^md_addr_t	ld_text_base = 0;$/;"	v
ld_text_size	ss/ss_readfile.c	/^unsigned int	ld_text_size = 0;$/;"	v
linear_expr	symexec.h	/^struct linear_expr {$/;"	s
linear_expr::added	symexec.h	/^	int added[MAX_EXPR_LEN]; \/\/added=0: not processed, added=1: added$/;"	m	struct:linear_expr	access:public
linear_expr::coef	symexec.h	/^	int coef[MAX_EXPR_LEN];$/;"	m	struct:linear_expr	access:public
linear_expr::k	symexec.h	/^	int k;$/;"	m	struct:linear_expr	access:public
linear_expr::value	symexec.h	/^	reg_t value[MAX_EXPR_LEN]; \/\/restrict to CONST \/ INDUCTION \/ PARA$/;"	m	struct:linear_expr	access:public
linear_expr::varNum	symexec.h	/^	int varNum;$/;"	m	struct:linear_expr	access:public
lineno	infeasible.h	/^  int  lineno;                  \/\/ line number in bb$/;"	m	struct:__anon9	access:public
lnHigh	ss/ecoff.h	/^  int lnHigh;$/;"	m	struct:ecoff_pdr	access:public
lnLow	ss/ecoff.h	/^  int lnLow;$/;"	m	struct:ecoff_pdr	access:public
lo	common.h	/^    char lo, hi;$/;"	m	struct:__anon37	access:public
lo	common.h	/^    int	    lo, hi;$/;"	m	struct:__anon35	access:public
lo	common.h	/^    short int	lo, hi;$/;"	m	struct:__anon36	access:public
lo	ss/machine.h	/^  sword_t hi, lo;		\/* multiplier HI\/LO result registers *\/$/;"	m	struct:__anon23	access:public
loadMem	symexec.c	/^void    loadMem(worklist_p memList, reg_t writeAddr, reg_t *regValue);$/;"	p	file:	signature:(worklist_p memList, reg_t writeAddr, reg_t *regValue)
loadMem	symexec.c	/^void loadMem (worklist_p memList, reg_t writeAddr, reg_t *regValue) {$/;"	f	signature:(worklist_p memList, reg_t writeAddr, reg_t *regValue)
load_wait_store	ss/ss_exegraph.c	/^static void load_wait_store() {$/;"	f	file:
local	ss/symbol.h	/^  int local;			\/* compiler local symbol? *\/$/;"	m	struct:sym_sym_t	access:public
log_base2	ss/misc.c	/^log_base2(int n)$/;"	f	signature:(int n)
log_base2	ss/misc.h	/^int log_base2(int n);$/;"	p	signature:(int n)
longjmp	ss/host.h	137;"	d
lookup_addr	cfg.c	/^lookup_addr(de_inst_t *code, int num, addr_t addr)$/;"	f	file:	signature:(de_inst_t *code, int num, addr_t addr)
lookup_addr	ss/ss_readfile.c	/^lookup_addr(char *fname)$/;"	f	file:	signature:(char *fname)
lookup_bb	cfg.c	/^lookup_bb(cfg_node_t *cfg, int num, addr_t addr)$/;"	f	file:	signature:(cfg_node_t *cfg, int num, addr_t addr)
lookup_jptable	main.c	/^int lookup_jptable(addr_t adr) {$/;"	f	signature:(addr_t adr)
lookup_mlat	pipeline.c	/^static void lookup_mlat(int orig, int dist, tcfg_node_t *bbi, int no_mlat) {$/;"	f	file:	signature:(int orig, int dist, tcfg_node_t *bbi, int no_mlat)
lookup_proc	cfg.c	/^lookup_proc(addr_t addr)$/;"	f	file:	signature:(addr_t addr)
loopEqual	conflicts.c	/^char loopEqual( cfg_node_t *b1, cfg_node_t *b2 ) {$/;"	f	signature:( cfg_node_t *b1, cfg_node_t *b2 )
loopSymExec	symexec.c	/^int loopSymExec(loop_t *lp, inf_proc_t *p, int mustFlag, P_Queue **outQueue) {$/;"	f	signature:(loop_t *lp, inf_proc_t *p, int mustFlag, P_Queue **outQueue)
loop_bbb_idx	loops.c	34;"	d	file:
loop_cache_tags	cache.c	/^tag_link_t	***loop_cache_tags;$/;"	v
loop_check	cfg.c	/^loop_check(proc_t *proc, int start, int end)$/;"	f	file:	signature:(proc_t *proc, int start, int end)
loop_comm_ances	loops.c	/^loop_t ***loop_comm_ances; \/\/ loop_comm_ances[lp1, lp2]$/;"	v
loop_comm_ances	loops.h	/^loop_t***	loop_comm_ances;$/;"	v
loop_dist	scp_cache.c	/^int loop_dist(loop_t* lp1, loop_t* lp2) {$/;"	f	signature:(loop_t* lp1, loop_t* lp2)
loop_dist	scp_cache.h	/^int loop_dist(loop_t* lp1, loop_t* lp2);$/;"	p	signature:(loop_t* lp1, loop_t* lp2)
loop_id	infeasible.h	/^  int        loop_id;$/;"	m	struct:__anon12	access:public
loop_id	infeasible.h	/^  int loop_id;            \/*HBK: id of corresponding loop_t*\/$/;"	m	struct:__anon14	access:public
loop_id	scp_address.h	/^    int loop_id;$/;"	m	struct:temporal_scope	access:public
loop_id	tcfg.h	/^	int loop_id; \/\/ vivy: for infeasible path constraints$/;"	m	struct:__anon38	access:public
loop_map	address.c	/^loop_t** loop_map;$/;"	v
loop_map	loops.c	/^loop_t **loop_map; \/\/ bbi => loop$/;"	v
loop_map	loops.h	/^loop_t	    **loop_map;		\/\/ bbi => loop$/;"	v
loop_process	loops.c	/^void loop_process() {$/;"	f
loop_relations	loops.c	/^void loop_relations() {$/;"	f
loop_relations	loops.h	/^void loop_relations();$/;"	p	signature:()
loop_role	cfg.h	/^    int		loop_role;	\/\/ whether it is a loop head, tail, or neither$/;"	m	struct:__anon3	access:public
loop_role	infeasible.h	/^  int		 loop_role;$/;"	m	struct:__anon12	access:public
loop_t	loops.h	/^struct loop_t {$/;"	s
loop_t	loops.h	/^typedef struct loop_t	loop_t;$/;"	t	typeref:struct:loop_t
loop_t::biv_list	loops.h	/^    void*           biv_list;   \/\/list of BIV in this loop$/;"	m	struct:loop_t	access:public
loop_t::bound	loops.h	/^    int             bound;      \/\/maximum lb        $/;"	m	struct:loop_t	access:public
loop_t::exec	loops.h	/^    int             exec;       \/\/maximum exec count$/;"	m	struct:loop_t	access:public
loop_t::exits	loops.h	/^    tcfg_elink_t    *exits;$/;"	m	struct:loop_t	access:public
loop_t::flags	loops.h	/^    int		        flags;$/;"	m	struct:loop_t	access:public
loop_t::head	loops.h	/^    tcfg_node_t	    *head;	\/\/ [head, tail]$/;"	m	struct:loop_t	access:public
loop_t::id	loops.h	/^    int		        id;$/;"	m	struct:loop_t	access:public
loop_t::parent	loops.h	/^    loop_t	        *parent;$/;"	m	struct:loop_t	access:public
loop_t::rBound	loops.h	/^    int             rBound;    \/\/relative bound$/;"	m	struct:loop_t	access:public
loop_t::rId	loops.h	/^    int             rId;       \/\/relative bound compared to loop rbId$/;"	m	struct:loop_t	access:public
loop_t::rType	loops.h	/^    int             rType;     \/\/type of relative loop bound$/;"	m	struct:loop_t	access:public
loop_t::tail	loops.h	/^    tcfg_node_t	    *tail;$/;"	m	struct:loop_t	access:public
loops	loops.c	/^loop_t **loops;$/;"	v
loops	loops.h	/^loop_t** loops;$/;"	v
lower_bound	address.h	/^	addr_t lower_bound;	  $/;"	m	struct:ric	access:public
lpOut_acs	scp_cache.c	/^scp_acs *lpOut_acs; \/\/summarized & recomputed acs of inner loops$/;"	v
lpPersIn	scp_cache.c	/^scp_acs *lpPersIn; \/\/lpPersIn[id] = PS blocks of lp->id$/;"	v
lpReqPS	scp_cache.c	/^worklist_p *lpReqPS; \/\/PS.blk needed in loop->id$/;"	v
lp_coldms	scp_cache.c	/^int lp_coldms[36]; \/\/lp_coldms[id] = number of cold miss in lp id$/;"	v
ls	cache.h	/^    int		ls;	\/\/ cache line size$/;"	m	struct:__anon26	access:public
lsb	cache.h	/^    int		lsb;    \/\/ lsb = log(ls)$/;"	m	struct:__anon26	access:public
lw	scp_address.h	/^    int lw;$/;"	m	struct:temporal_scope	access:public
m	scp_cache.h	/^	saddr_p m; \/*scope address of this scoped block*\/$/;"	m	struct:scope_block	access:public
magic	ss/ecoff.h	/^  short magic;$/;"	m	struct:ecoff_aouthdr	access:public
magic	ss/ecoff.h	/^  short magic;$/;"	m	struct:ecoff_symhdr_t	access:public
main	main.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	ss/eval.c	/^main(void)$/;"	f	signature:(void)
main	ss/options.c	/^main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	test.c	/^int main()$/;"	f
main_addr	cfg.h	/^    addr_t	    start_addr, end_addr, main_addr;$/;"	m	struct:__anon5	access:public
main_proc	cfg.h	/^    int		    main_proc;	\/\/ index of the main proc$/;"	m	struct:__anon5	access:public
makeCacheBlock	unicache.c	/^static acs_p makeCacheBlock(mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(mem_blk_set_t* mem_blk_set)
makeCacheSet	unicache.c	/^static acs_p* makeCacheSet() {$/;"	f	file:
makeCopy	unicache.c	/^static acs_p makeCopy(acs_p acs_in) {$/;"	f	file:	signature:(acs_p acs_in)
makeEmpty	unicache.c	/^static acs_p makeEmpty() {$/;"	f	file:
makeRIC	address.c	/^ric_p makeRIC(ric_p arg)$/;"	f	signature:(ric_p arg)
makeRICPerInstruction	address.c	/^static void makeRICPerInstruction(de_inst_t* inst, ric_p* abs_reg)$/;"	f	file:	signature:(de_inst_t* inst, ric_p* abs_reg)
make_est	estimate.c	/^make_est()$/;"	f	file:
map_bb_bbi	ilp.c	/^static char map_bb_bbi(int proc, int bb, int first, int sign, int coeff) {$/;"	f	file:	signature:(int proc, int bb, int first, int sign, int coeff)
map_bb_bbi_context	ilp.c	/^static char map_bb_bbi_context(int proc, int bb, int first, int sign, int coeff,$/;"	f	file:	signature:(int proc, int bb, int first, int sign, int coeff, int k)
map_bbi_loop	loops.c	/^void map_bbi_loop() {$/;"	f
map_bbi_loop	loops.h	/^void map_bbi_loop();$/;"	p	signature:()
markLoop	infeasible.c	/^void markLoop( inf_proc_t *ip, inf_node_t *head, inf_node_t *ib, int lpid, char **checked ) {$/;"	f	signature:( inf_proc_t *ip, inf_node_t *head, inf_node_t *ib, int lpid, char **checked )
mark_data_dep	ss/ss_exegraph.c	/^static void mark_data_dep(int src_id, int dst_id) {$/;"	f	file:	signature:(int src_id, int dst_id)
mas_inst_t	pipeline.h	/^} mas_inst_t;$/;"	t	typeref:struct:__anon34
master	ss/resource.h	/^    struct res_desc *master;		\/* master resource record *\/$/;"	m	struct:res_desc::res_template	typeref:struct:res_desc::res_template::res_desc	access:public
max	common.h	51;"	d
maxAddr	scp_tscope.c	/^int minAddr, maxAddr;$/;"	v
max_elog_len	pipeline.c	/^int *max_elog_len;$/;"	v
max_exec	symexec.h	/^	int max_exec; \/*Maximum number of executions*\/$/;"	m	struct:__anon18	access:public
max_inst_lat	isa.c	/^max_inst_lat(de_inst_t *inst)$/;"	f	signature:(de_inst_t *inst)
max_miss	symexec.h	/^	int max_miss; \/*Maximum estimate cache misses*\/$/;"	m	struct:__anon18	access:public
max_miss	tcfg.h	/^	int max_miss;$/;"	m	struct:__anon38	access:public
maxof	address.c	/^int maxof(int n_args, ...){$/;"	f	signature:(int n_args, ...)
mblk_hit_loop	cache.c	/^loop_t		***mblk_hit_loop;$/;"	v
mblk_id	pipeline.h	/^	short mblk_id;$/;"	m	struct:__anon34	access:public
mblk_id_l2	pipeline.h	/^	short mblk_id_l2;$/;"	m	struct:__anon34	access:public
mblk_tag_t	cache.h	/^} mblk_tag_t;$/;"	t	typeref:struct:__anon28
md_addr_t	ss/machine.h	/^typedef word_t md_addr_t;$/;"	t
md_amode_NUM	ss/machine.h	/^  md_amode_NUM$/;"	e	enum:md_amode_type
md_amode_disp	ss/machine.h	/^  md_amode_disp,	\/* (reg + const) addressing *\/$/;"	e	enum:md_amode_type
md_amode_fp	ss/machine.h	/^  md_amode_fp,		\/* stack access through frame pointer *\/$/;"	e	enum:md_amode_type
md_amode_gp	ss/machine.h	/^  md_amode_gp,		\/* global data access through global pointer *\/$/;"	e	enum:md_amode_type
md_amode_imm	ss/machine.h	/^  md_amode_imm,		\/* immediate addressing mode *\/$/;"	e	enum:md_amode_type
md_amode_rr	ss/machine.h	/^  md_amode_rr,		\/* (reg + reg) addressing *\/$/;"	e	enum:md_amode_type
md_amode_sp	ss/machine.h	/^  md_amode_sp,		\/* stack access through stack pointer *\/$/;"	e	enum:md_amode_type
md_amode_str	ss/machine.c	/^char *md_amode_str[md_amode_NUM] =$/;"	v
md_amode_type	ss/machine.h	/^enum md_amode_type {$/;"	g
md_crc_regs	ss/machine.c	/^md_crc_regs(struct regs_t *regs)$/;"	f	signature:(struct regs_t *regs)
md_crc_regs	ss/machine.h	/^word_t md_crc_regs(struct regs_t *regs);$/;"	p	signature:(struct regs_t *regs)
md_ctrl_t	ss/machine.h	/^} md_ctrl_t;$/;"	t	typeref:struct:__anon23
md_fault_access	ss/machine.h	/^  md_fault_access,		\/* storage access fault *\/$/;"	e	enum:md_fault_type
md_fault_alignment	ss/machine.h	/^  md_fault_alignment,		\/* storage alignment fault *\/$/;"	e	enum:md_fault_type
md_fault_break	ss/machine.h	/^  md_fault_break,		\/* BREAK instruction fault *\/$/;"	e	enum:md_fault_type
md_fault_div0	ss/machine.h	/^  md_fault_div0,		\/* division by zero fault *\/$/;"	e	enum:md_fault_type
md_fault_internal	ss/machine.h	/^  md_fault_internal		\/* internal S\/W fault *\/$/;"	e	enum:md_fault_type
md_fault_none	ss/machine.h	/^  md_fault_none = 0,		\/* no fault *\/$/;"	e	enum:md_fault_type
md_fault_overflow	ss/machine.h	/^  md_fault_overflow,		\/* signed arithmetic overflow fault *\/$/;"	e	enum:md_fault_type
md_fault_type	ss/machine.h	/^enum md_fault_type {$/;"	g
md_fault_unimpl	ss/machine.h	/^  md_fault_unimpl,		\/* unimplemented instruction fault *\/$/;"	e	enum:md_fault_type
md_fpr_t	ss/machine.h	/^} md_fpr_t;$/;"	t	typeref:union:__anon22
md_fu2name	ss/machine.c	/^char *md_fu2name[NUM_FU_CLASSES] = {$/;"	v
md_fu_class	ss/machine.h	/^enum md_fu_class {$/;"	g
md_gpr_t	ss/machine.h	/^typedef sword_t md_gpr_t[MD_NUM_IREGS];$/;"	t
md_init_decoder	ss/machine.c	/^md_init_decoder(void)$/;"	f	signature:(void)
md_init_decoder	ss/machine.h	/^void md_init_decoder(void);$/;"	p	signature:(void)
md_inst_t	ss/machine.h	/^} md_inst_t;$/;"	t	typeref:struct:__anon24
md_lr_masks	ss/machine.c	/^word_t md_lr_masks[] = {$/;"	v
md_mask2op	ss/machine.c	/^enum md_opcode md_mask2op[MD_MAX_MASK+1];$/;"	v	typeref:enum:md_opcode
md_op2flags	ss/machine.c	/^unsigned int md_op2flags[OP_MAX] = {$/;"	v
md_op2flags	ss/ss_isa.c	/^unsigned int md_op2flags[OP_MAX] = {$/;"	v
md_op2format	ss/machine.c	/^char *md_op2format[OP_MAX] = {$/;"	v
md_op2fu	ss/machine.c	/^enum md_fu_class md_op2fu[OP_MAX] = {$/;"	v	typeref:enum:md_fu_class
md_op2name	ss/machine.c	/^char *md_op2name[OP_MAX] = {$/;"	v
md_op2name	ss/ss_isa.c	/^char *md_op2name[OP_MAX] = {$/;"	v
md_opcode	ss/machine.h	/^enum md_opcode {$/;"	g
md_print_creg	ss/machine.c	/^md_print_creg(md_ctrl_t regs, int reg, FILE *stream)$/;"	f	signature:(md_ctrl_t regs, int reg, FILE *stream)
md_print_creg	ss/machine.h	/^void md_print_creg(md_ctrl_t regs, int reg, FILE *stream);$/;"	p	signature:(md_ctrl_t regs, int reg, FILE *stream)
md_print_cregs	ss/machine.c	/^md_print_cregs(md_ctrl_t regs, FILE *stream)$/;"	f	signature:(md_ctrl_t regs, FILE *stream)
md_print_cregs	ss/machine.h	/^void md_print_cregs(md_ctrl_t regs, FILE *stream);$/;"	p	signature:(md_ctrl_t regs, FILE *stream)
md_print_fpreg	ss/machine.c	/^md_print_fpreg(md_fpr_t regs, int reg, FILE *stream)$/;"	f	signature:(md_fpr_t regs, int reg, FILE *stream)
md_print_fpreg	ss/machine.h	/^void md_print_fpreg(md_fpr_t regs, int reg, FILE *stream);$/;"	p	signature:(md_fpr_t regs, int reg, FILE *stream)
md_print_fpregs	ss/machine.c	/^md_print_fpregs(md_fpr_t regs, FILE *stream)$/;"	f	signature:(md_fpr_t regs, FILE *stream)
md_print_fpregs	ss/machine.h	/^void md_print_fpregs(md_fpr_t regs, FILE *stream);$/;"	p	signature:(md_fpr_t regs, FILE *stream)
md_print_insn	ss/machine.c	/^md_print_insn(md_inst_t inst,		\/* instruction to disassemble *\/$/;"	f	signature:(md_inst_t inst, md_addr_t pc, FILE *stream)
md_print_insn	ss/machine.h	/^md_print_insn(md_inst_t inst,		\/* instruction to disassemble *\/$/;"	p	signature:(md_inst_t inst, md_addr_t pc, FILE *stream)
md_print_ireg	ss/machine.c	/^md_print_ireg(md_gpr_t regs, int reg, FILE *stream)$/;"	f	signature:(md_gpr_t regs, int reg, FILE *stream)
md_print_ireg	ss/machine.h	/^void md_print_ireg(md_gpr_t regs, int reg, FILE *stream);$/;"	p	signature:(md_gpr_t regs, int reg, FILE *stream)
md_print_iregs	ss/machine.c	/^md_print_iregs(md_gpr_t regs, FILE *stream)$/;"	f	signature:(md_gpr_t regs, FILE *stream)
md_print_iregs	ss/machine.h	/^void md_print_iregs(md_gpr_t regs, FILE *stream);$/;"	p	signature:(md_gpr_t regs, FILE *stream)
md_reg_name	ss/machine.c	/^md_reg_name(enum md_reg_type rt, int reg)$/;"	f	signature:(enum md_reg_type rt, int reg)
md_reg_name	ss/machine.h	/^char *md_reg_name(enum md_reg_type rt, int reg);$/;"	p	signature:(enum md_reg_type rt, int reg)
md_reg_names	ss/machine.c	/^struct md_reg_names_t md_reg_names[] =$/;"	v	typeref:struct:md_reg_names_t
md_reg_names	ss/machine.h	/^enum md_reg_names {$/;"	g
md_reg_names_t	ss/machine.h	/^struct md_reg_names_t {$/;"	s
md_reg_names_t::file	ss/machine.h	/^  enum md_reg_type file;	\/* register file *\/$/;"	m	struct:md_reg_names_t	typeref:enum:md_reg_names_t::md_reg_type	access:public
md_reg_names_t::reg	ss/machine.h	/^  int reg;			\/* register index *\/$/;"	m	struct:md_reg_names_t	access:public
md_reg_names_t::str	ss/machine.h	/^  char *str;			\/* register name *\/$/;"	m	struct:md_reg_names_t	access:public
md_reg_obj	ss/machine.c	/^md_reg_obj(struct regs_t *regs,			\/* registers to access *\/$/;"	f	signature:(struct regs_t *regs, int is_write, enum md_reg_type rt, int reg, struct eval_value_t *val)
md_reg_obj	ss/machine.h	/^md_reg_obj(struct regs_t *regs,			\/* registers to access *\/$/;"	p	signature:(struct regs_t *regs, int is_write, enum md_reg_type rt, int reg, struct eval_value_t *val)
md_reg_type	ss/machine.h	/^enum md_reg_type {$/;"	g
md_xor_regs	ss/machine.c	/^md_xor_regs(struct regs_t *regs)$/;"	f	signature:(struct regs_t *regs)
md_xor_regs	ss/machine.h	/^word_t md_xor_regs(struct regs_t *regs);$/;"	p	signature:(struct regs_t *regs)
memListEq	symexec.c	/^int     memListEq(worklist_p list1, worklist_p list2);$/;"	p	file:	signature:(worklist_p list1, worklist_p list2)
memListEq	symexec.c	/^int memListEq(worklist_p dstList, worklist_p srcList) {$/;"	f	signature:(worklist_p dstList, worklist_p srcList)
memListIn	infeasible.h	/^  worklist_p    memListIn;$/;"	m	struct:__anon12	access:public
memListOut	infeasible.h	/^  worklist_p    memListOut;$/;"	m	struct:__anon12	access:public
mem_blk_h	cache.h	/^	mem_blk_set_t* mem_blk_h;$/;"	m	struct:cache_block	access:public
mem_blk_set	cache.h	/^struct mem_blk_set $/;"	s
mem_blk_set::block	cache.h	/^	unsigned block;	  $/;"	m	struct:mem_blk_set	access:public
mem_blk_set::next	cache.h	/^	struct mem_blk_set* next;$/;"	m	struct:mem_blk_set	typeref:struct:mem_blk_set::mem_blk_set	access:public
mem_blk_set_t	cache.h	/^typedef struct mem_blk_set mem_blk_set_t;$/;"	t	typeref:struct:mem_blk_set
mem_blk_t	cache.h	/^} mem_blk_t;$/;"	t	typeref:struct:__anon27
mem_bus_width	ss/my_opt.c	/^int mem_bus_width;$/;"	v
mem_free	common.h	57;"	d
mem_lat	ss/my_opt.c	/^int mem_lat[2] = { \/* lat to first chunk *\/30, \/* lat between remaining chunks *\/$/;"	v
mem_nelt	ss/my_opt.c	/^int mem_nelt = 2;$/;"	v
mem_p	symexec.h	/^typedef struct sym_memory_model* mem_p;$/;"	t	typeref:struct:sym_memory_model
mem_s	symexec.h	/^typedef struct sym_memory_model mem_s;$/;"	t	typeref:struct:sym_memory_model
mergeInnerLoopAnalysis	dump.c	/^void mergeInnerLoopAnalysis() {$/;"	f
mergeMemList	symexec.c	/^int     mergeMemList(worklist_p *dstList, worklist_p srcList);$/;"	p	file:	signature:(worklist_p *dstList, worklist_p srcList)
mergeMemList	symexec.c	/^int mergeMemList(worklist_p *dstList, worklist_p srcList) {$/;"	f	signature:(worklist_p *dstList, worklist_p srcList)
mergeReg	reg.c	/^int mergeReg(reg_t *dstReg, reg_t srcReg, int isBackEdge) {$/;"	f	signature:(reg_t *dstReg, reg_t srcReg, int isBackEdge)
mergeReg	symexec.h	/^int mergeReg(reg_t *dstReg, reg_t srcReg, int isBackEdge); \/\/merge abs.reg value$/;"	p	signature:(reg_t *dstReg, reg_t srcReg, int isBackEdge)
mergeSBlk	scp_cache.h	/^int mergeSBlk(sblk_p dst, sblk_p src);$/;"	p	signature:(sblk_p dst, sblk_p src)
mergeTSset	scp_address.c	/^int mergeTSset(worklist_p dstSet, worklist_p srcSet, int lpId) {$/;"	f	signature:(worklist_p dstSet, worklist_p srcSet, int lpId)
mergeTSset	scp_address.h	/^int     mergeTSset(worklist_p dstSet, worklist_p srcSet, int lpId);$/;"	p	signature:(worklist_p dstSet, worklist_p srcSet, int lpId)
microarch_modeling	main.c	/^static void microarch_modeling() {$/;"	f	file:
min	common.h	52;"	d
minAddr	scp_tscope.c	/^int minAddr, maxAddr;$/;"	v
min_overlap	estimate.c	/^min_overlap(egraph_node_t *v, egraph_node_t *u)$/;"	f	file:	signature:(egraph_node_t *v, egraph_node_t *u)
minof	address.c	/^int minof(int n_args, ...){$/;"	f	signature:(int n_args, ...)
mlat_bbi	pipeline.c	/^int *mlat_bbi;$/;"	v
mlat_mpinst	pipeline.c	/^int *mlat_mpinst;$/;"	v
mod_addr	isa.h	/^	 ric_p mod_addr;$/;"	m	struct:__anon16	access:public
mp_affected_sets	pipeline.c	/^tcfg_elink_t ***mp_affected_sets;$/;"	v
mp_cache_cons	ilp.c	/^static void mp_cache_cons() {$/;"	f	file:
mp_gen	cache.c	/^mem_blk_t	    **mp_gen;$/;"	v
mp_insts	bpred.c	/^de_inst_t	***mp_insts;$/;"	v
mp_set_body_hitmiss	pipeline.c	/^static void mp_set_body_hitmiss(int edge_id, int hm_id, int set) {$/;"	f	file:	signature:(int edge_id, int hm_id, int set)
mp_set_tags	pipeline.c	/^int **mp_set_tags;$/;"	v
mp_times	pipeline.c	/^int ***mp_times;$/;"	v
mpa_acs_in	tcfg.h	/^	worklist_p* mpa_acs_in;$/;"	m	struct:__anon38	access:public
mpa_acs_out	tcfg.h	/^	worklist_p* mpa_acs_out;$/;"	m	struct:__anon38	access:public
mpaex_datacache	scp_cache.c	/^void mpaex_datacache(int analysis) {$/;"	f	signature:(int analysis)
mpcache_misses	ilp.c	/^mpcache_misses();$/;"	p	file:
mpcache_misses	ilp.c	/^static void mpcache_misses() {$/;"	f	file:
mpcost_func	ilp.c	/^static void mpcost_func() {$/;"	f	file:
mpinst_coexists	ss/ss_exegraph.c	/^static void mpinst_coexists(int curr, int br_inst) {$/;"	f	file:	signature:(int curr, int br_inst)
mpred_times	pipeline.c	/^int **cpred_times, **mpred_times, start_time;$/;"	v
mpset_cons	ilp.c	/^static void mpset_cons() {$/;"	f	file:
mpset_str	ilp.c	/^static void mpset_str(tcfg_edge_t *edge, int lp_id, int set) {$/;"	f	file:	signature:(tcfg_edge_t *edge, int lp_id, int set)
mpset_term	ilp.c	/^static void mpset_term(FILE *fp, tcfg_edge_t *edge, int lp_id, int set,$/;"	f	file:	signature:(FILE *fp, tcfg_edge_t *edge, int lp_id, int set, char *prefix, char *suffix)
mpunit_cache_misses	ilp.c	/^static void mpunit_cache_misses(int bbi_id, int hm, int lp_id) {$/;"	f	file:	signature:(int bbi_id, int hm, int lp_id)
mpunit_cons	ilp.c	/^static void mpunit_cons() {$/;"	f	file:
mpunit_str	ilp.c	/^static void mpunit_str(tcfg_edge_t *edge, int hm, int set) {$/;"	f	file:	signature:(tcfg_edge_t *edge, int hm, int set)
mpunit_term	ilp.c	/^static void mpunit_term(FILE *fp, tcfg_edge_t *edge, int hm, int set,$/;"	f	file:	signature:(FILE *fp, tcfg_edge_t *edge, int hm, int set, char *prefix, char *suffix)
my_bsearch	common.c	/^my_bsearch(const void *key, const void *base, size_t n, size_t size,$/;"	f	signature:(const void *key, const void *base, size_t n, size_t size, int (*cmp)(const void *k, const void *datum))
my_bsearch	common.h	/^my_bsearch(const void *key, const void *base, size_t n, size_t size,$/;"	p	signature:(const void *key, const void *base, size_t n, size_t size, int (*cmp)(const void *k, const void *datum))
my_dump_tcfg	main.c	/^void my_dump_tcfg(int* unrolled_loop_map) {$/;"	f	signature:(int* unrolled_loop_map)
my_eval_ident	ss/eval.c	/^my_eval_ident(struct eval_state_t *es)$/;"	f	signature:(struct eval_state_t *es)
my_insert	common.c	/^my_insert(const void *x, void *base, void *y, int *nelem, int size)$/;"	f	signature:(const void *x, void *base, void *y, int *nelem, int size)
my_insert	common.h	/^my_insert(const void *x, void *base, void *y, int *nelem, int size);$/;"	p	signature:(const void *x, void *base, void *y, int *nelem, int size)
myatoq	ss/misc.c	/^myatoq(char *nptr, char **endp, int base)$/;"	f	signature:(char *nptr, char **endp, int base)
myatoq	ss/misc.h	/^qword_t myatoq(char *nptr, char **endp, int base);$/;"	p	signature:(char *nptr, char **endp, int base)
myatosq	ss/misc.c	/^myatosq(char *nptr, char **endp, int base)$/;"	f	signature:(char *nptr, char **endp, int base)
myatosq	ss/misc.h	/^sqword_t myatosq(char *nptr, char **endp, int base);$/;"	p	signature:(char *nptr, char **endp, int base)
myfprintf	ss/misc.c	/^myfprintf(FILE *stream, char *format, ...)$/;"	f	signature:(FILE *stream, char *format, ...)
myfprintf	ss/misc.h	/^void myfprintf(FILE *stream, char *format, ...);$/;"	p	signature:(FILE *stream, char *format, ...)
myrand	ss/misc.c	/^myrand(void)			\/* returns random number *\/$/;"	f	signature:(void)
myrand	ss/misc.h	/^int myrand(void);		\/* returns random number *\/$/;"	p	signature:(void)
mysprintf	ss/misc.c	/^mysprintf(char *obuf, char *format, ...)$/;"	f	signature:(char *obuf, char *format, ...)
mysprintf	ss/misc.h	/^char *mysprintf(char *obuf, char *format, ...);$/;"	p	signature:(char *obuf, char *format, ...)
mysrand	ss/misc.c	/^mysrand(unsigned int seed)	\/* random number generator seed *\/$/;"	f	signature:(unsigned int seed)
mysrand	ss/misc.h	/^mysrand(unsigned int seed);	\/* random number generator seed *\/$/;"	p	signature:(unsigned int seed)
mystrdup	ss/misc.c	/^mystrdup(char *s)		\/* string to duplicate to heap storage *\/$/;"	f	signature:(char *s)
mystrdup	ss/misc.h	/^mystrdup(char *s);		\/* string to duplicate to heap storage *\/$/;"	p	signature:(char *s)
mystricmp	ss/misc.c	/^mystricmp(char *s1, char *s2)	\/* strings to compare, case insensitive *\/$/;"	f	signature:(char *s1, char *s2)
mystricmp	ss/misc.h	/^mystricmp(char *s1, char *s2);	\/* strings to compare, case insensitive *\/$/;"	p	signature:(char *s1, char *s2)
mystrrchr	ss/misc.c	/^mystrrchr(char *s, char c)$/;"	f	signature:(char *s, char c)
mystrrchr	ss/misc.h	/^mystrrchr(char *s, char c);$/;"	p	signature:(char *s, char c)
myvfprintf	ss/misc.c	/^myvfprintf(FILE *stream, char *format, va_list v)$/;"	f	signature:(FILE *stream, char *format, va_list v)
myvfprintf	ss/misc.h	/^void myvfprintf(FILE *stream, char *format, va_list v);$/;"	p	signature:(FILE *stream, char *format, va_list v)
myvsprintf	ss/misc.c	/^myvsprintf(char *obuf, char *format, va_list v)$/;"	f	signature:(char *obuf, char *format, va_list v)
myvsprintf	ss/misc.h	/^char *myvsprintf(char *obuf, char *format, va_list v);$/;"	p	signature:(char *obuf, char *format, va_list v)
n_data_persistence	tcfg.h	/^	int n_data_persistence; \/* Number of persistence data blocks *\/$/;"	m	struct:__anon38	access:public
n_l2_persistence	tcfg.h	/^	int n_l2_persistence; \/* Number of instruction in l2 instruction cache *\/$/;"	m	struct:__anon38	access:public
n_persistence	tcfg.h	/^	int n_persistence; \/* Number of persistence instruction *\/$/;"	m	struct:__anon38	access:public
n_u1_data_persistence	tcfg.h	/^	int n_u1_data_persistence; \/* Number of persistence data blocks in unified cache *\/$/;"	m	struct:__anon38	access:public
n_u1_persistence	tcfg.h	/^	int n_u1_persistence; \/* Number of persistence instruction in Unified cache*\/$/;"	m	struct:__anon38	access:public
na	cache.h	/^    int		na;$/;"	m	struct:__anon26	access:public
name	cfg.h	/^    char* name;$/;"	m	struct:__anon4	access:public
name	isa.h	/^    char    *name;	\/\/ inst name$/;"	m	struct:__anon15	access:public
name	scp_address.h	/^    char name[256];$/;"	m	struct:size_cons	access:public
name	ss/options.h	/^  char *name;			\/* option name, e.g., "-foo:bar" *\/$/;"	m	struct:opt_opt_t	access:public
name	ss/resource.h	/^  char *name;				\/* name of functional unit *\/$/;"	m	struct:res_desc	access:public
name	ss/resource.h	/^  char *name;				\/* pool name *\/$/;"	m	struct:res_pool	access:public
name	ss/symbol.h	/^  char *name;			\/* symbol name *\/$/;"	m	struct:sym_sym_t	access:public
name	symexec.h	/^	char name[4];$/;"	m	struct:__anon17	access:public
ncmp	ss/symbol.c	/^ncmp(struct sym_sym_t **sym1, struct sym_sym_t **sym2)$/;"	f	file:	signature:(struct sym_sym_t **sym1, struct sym_sym_t **sym2)
neg	conflicts.c	/^int neg( int a ) {$/;"	f	signature:( int a )
nelt	ss/options.h	/^  int *nelt;			\/* number of elements parsed *\/$/;"	m	struct:opt_opt_t	access:public
nents	ss/resource.h	/^  int nents[MAX_RES_CLASSES];$/;"	m	struct:res_pool	access:public
new_bbb	bpred.c	/^new_bbb(int bbi_id, int bhr)$/;"	f	file:	signature:(int bbi_id, int bhr)
new_bfg_edge	bpred.c	/^new_bfg_edge(bfg_node_t *x, bfg_node_t *y, int branch)$/;"	f	file:	signature:(bfg_node_t *x, bfg_node_t *y, int branch)
new_contend	ss/ss_exegraph.c	/^static void new_contend(egraph_node_t *src, egraph_node_t *dst, int normal) {$/;"	f	file:	signature:(egraph_node_t *src, egraph_node_t *dst, int normal)
new_depend	ss/ss_exegraph.c	/^static void new_depend(egraph_node_t *src, egraph_node_t *dst, int low,$/;"	f	file:	signature:(egraph_node_t *src, egraph_node_t *dst, int low, int high, int normal)
new_edge	cfg.c	/^new_edge(cfg_node_t *src, cfg_node_t *dst, int taken)$/;"	f	file:	signature:(cfg_node_t *src, cfg_node_t *dst, int taken)
new_epilog	pipeline.c	/^static int new_epilog(int log_set, tcfg_edge_t **path, int path_len) {$/;"	f	file:	signature:(int log_set, tcfg_edge_t **path, int path_len)
new_loop	loops.c	/^new_loop(tcfg_edge_t *e) {$/;"	f	file:	signature:(tcfg_edge_t *e)
new_prolog	pipeline.c	/^static void new_prolog(int log_set, tcfg_edge_t **path, int path_len,$/;"	f	file:	signature:(int log_set, tcfg_edge_t **path, int path_len, int num_skip)
new_tcfg_edge	tcfg.c	/^new_tcfg_edge(tcfg_node_t *src, tcfg_node_t *dst, int branch)$/;"	f	file:	signature:(tcfg_node_t *src, tcfg_node_t *dst, int branch)
new_tcfg_node	tcfg.c	/^new_tcfg_node(cfg_node_t *bb)$/;"	f	file:	signature:(cfg_node_t *bb)
new_term	ilp.c	/^void new_term(FILE *fp) {$/;"	f	signature:(FILE *fp)
newb	cache.h	/^	unsigned newb;$/;"	m	struct:ovr_mapping	access:public
next	address.h	/^	struct abs_mem* next;$/;"	m	struct:abs_mem	typeref:struct:abs_mem::abs_mem	access:public
next	address.h	/^	struct slist* next;$/;"	m	struct:slist	typeref:struct:slist::slist	access:public
next	cache.c	/^		  tag_link_t	    *next;$/;"	m	struct:tag_link_t	file:	access:public
next	cache.h	/^	struct mem_blk_set* next;$/;"	m	struct:mem_blk_set	typeref:struct:mem_blk_set::mem_blk_set	access:public
next	cache.h	/^	struct ovr_mapping* next;$/;"	m	struct:ovr_mapping	typeref:struct:ovr_mapping::ovr_mapping	access:public
next	cfg.h	/^	struct col_data* next;$/;"	m	struct:col_data	typeref:struct:col_data::col_data	access:public
next	cfg.h	/^	struct ovrl_graph* next;$/;"	m	struct:ovrl_graph	typeref:struct:ovrl_graph::ovrl_graph	access:public
next	common.h	/^		  struct hashtab* next;$/;"	m	struct:hashtab	typeref:struct:hashtab::hashtab	access:public
next	common.h	/^	struct worklist* next;$/;"	m	struct:worklist	typeref:struct:worklist::worklist	access:public
next	common.h	/^    struct priority_queue_t *next;$/;"	m	struct:priority_queue_t	typeref:struct:priority_queue_t::priority_queue_t	access:public
next	pipeline.h	/^	code_link_t *next;$/;"	m	struct:code_link_t	access:public
next	scp_address.h	/^    struct size_cons *next;$/;"	m	struct:size_cons	typeref:struct:size_cons::size_cons	access:public
next	ss/options.h	/^  struct opt_note_t *next;	\/* next option note *\/$/;"	m	struct:opt_note_t	typeref:struct:opt_note_t::opt_note_t	access:public
next	ss/options.h	/^  struct opt_opt_t *next;	\/* next option *\/$/;"	m	struct:opt_opt_t	typeref:struct:opt_opt_t::opt_opt_t	access:public
next	tcfg.h	/^	tcfg_elink_t *next;$/;"	m	struct:tcfg_elink_t	access:public
next	tcfg.h	/^	tcfg_nlink_t *next;$/;"	m	struct:tcfg_nlink_t	access:public
next_cond_bbi	bpred.c	/^next_cond_bbi(tcfg_edge_t *e)$/;"	f	file:	signature:(tcfg_edge_t *e)
next_in	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
next_in	bpred.h	/^    btg_edge_t	*next_in, *next_out;$/;"	m	struct:btg_edge_t	access:public
next_in	exegraph.h	/^    egraph_edge_t   *next_in, *next_out;$/;"	m	struct:egraph_edge_t	access:public
next_in	tcfg.h	/^	tcfg_edge_t *next_in; \/\/ next incoming edge of dst$/;"	m	struct:tcfg_edge_t	access:public
next_out	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
next_out	bpred.h	/^    btg_edge_t	*next_in, *next_out;$/;"	m	struct:btg_edge_t	access:public
next_out	exegraph.h	/^    egraph_edge_t   *next_in, *next_out;$/;"	m	struct:egraph_edge_t	access:public
next_out	tcfg.h	/^	tcfg_edge_t *next_out; \/\/ next outgoing edge of src$/;"	m	struct:tcfg_edge_t	access:public
njp	main.c	/^int njp;$/;"	v
normal	exegraph.h	/^    char	    normal;$/;"	m	struct:egraph_edge_t	access:public
note	ss/options.h	/^  char *note;			\/* option note *\/$/;"	m	struct:opt_note_t	access:public
notes	ss/options.h	/^  struct opt_note_t *notes;	\/* option notes *\/$/;"	m	struct:opt_odb_t	typeref:struct:opt_odb_t::opt_note_t	access:public
ns	cache.h	/^    int		ns;	\/\/ #sets$/;"	m	struct:__anon26	access:public
nsb	cache.h	/^    int		nsb;    \/\/ nsb = log(ns)$/;"	m	struct:__anon26	access:public
nsets	ss/my_opt.c	/^int nsets, bsize, assoc;$/;"	v
nsets_dl1	ss/my_opt.c	/^int nsets_dl1, bsize_dl1, assoc_dl1;$/;"	v
nsets_dl2	ss/my_opt.c	/^int nsets_dl2, bsize_dl2, assoc_dl2;$/;"	v
nsets_l2	ss/my_opt.c	/^int nsets_l2, bsize_l2, assoc_l2;$/;"	v
nt	cache.h	/^    int		nt;	\/\/ #tags$/;"	m	struct:__anon26	access:public
nt_s	cache.h	/^    int		nt_s;	\/\/ # of tag + set$/;"	m	struct:__anon26	access:public
ntarget	main.c	/^	int ntarget;$/;"	m	struct:jptb	file:	access:public
ntb	cache.h	/^    int		ntb;	\/\/ tag bits = log(nt)$/;"	m	struct:__anon26	access:public
nullifier_list	infeasible.h	/^  assign_t **nullifier_list;$/;"	m	struct:__anon10	access:public
nullifier_list	infeasible.h	/^  assign_t **nullifier_list;$/;"	m	struct:__anon11	access:public
num_BA	infeasible.h	/^int num_BA;               \/\/ global number of BA conflict pairs$/;"	v
num_BA_conflicts	infeasible.h	/^  int  num_BA_conflicts;$/;"	m	struct:branch_t	access:public
num_BB	infeasible.h	/^int num_BB;               \/\/ global number of BB conflict pairs$/;"	v
num_BB_conflicts	infeasible.h	/^  int  num_BB_conflicts;$/;"	m	struct:branch_t	access:public
num_assign	infeasible.h	/^  int        num_assign;      \/\/ #assign effects in this node$/;"	m	struct:__anon12	access:public
num_bb	cfg.h	/^    int		num_bb;		\/\/ number of basic blocks$/;"	m	struct:proc_t	access:public
num_bb	infeasible.h	/^  int num_bb;$/;"	m	struct:__anon13	access:public
num_bfg_nodes	bpred.c	/^int		    num_bfg_nodes;$/;"	v
num_d_inst	cfg.h	/^     int    num_d_inst;$/;"	m	struct:__anon3	access:public
num_eg_edges	exegraph.c	/^int		num_eg_edges = 0;$/;"	v
num_elogs	pipeline.c	/^int num_plogs, num_elogs;$/;"	v
num_fu	exegraph.h	/^    char	    fu, num_fu;		\/\/ applicable to EX nodes$/;"	m	struct:__anon32	access:public
num_hit_miss	cache.c	/^int		    *num_hit_miss;$/;"	v
num_in	cfg.h	/^    int		num_in;		\/\/ number of incoming edges$/;"	m	struct:__anon3	access:public
num_in	isa.h	/^    int	    num_in, num_out;	\/* number of input\/output operands *\/$/;"	m	struct:__anon16	access:public
num_inf_loops	infeasible.h	/^int num_inf_loops;        \/\/ loops detected for infeasible path analysis, as specified in .cons (global across procedures)$/;"	v
num_insn	infeasible.h	/^  int        num_insn;$/;"	m	struct:__anon12	access:public
num_insn_st	infeasible.h	/^int     num_insn_st;$/;"	v
num_inst	cfg.h	/^    int		    num_inst;	\/\/ number of instructions$/;"	m	struct:__anon5	access:public
num_inst	cfg.h	/^    int		num_inst;	\/\/ number of instructions$/;"	m	struct:__anon3	access:public
num_inst	cfg.h	/^    int		num_inst;	\/\/ number of instructions$/;"	m	struct:proc_t	access:public
num_inst	pipeline.h	/^	int num_inst;$/;"	m	struct:code_link_t	access:public
num_isa	isa.c	/^int	num_isa;	\/\/ number of instruction types of the ISA$/;"	v
num_mblk_conflicts	cache.c	/^int		**num_mblk_conflicts;$/;"	v
num_mblks	cache.c	/^int		    *num_mblks;$/;"	v
num_mem_insts	ss/ss_exegraph.c	/^short int *eg_mem_insts, num_mem_insts;$/;"	v
num_mp_insts	bpred.c	/^int		*num_mp_insts;$/;"	v
num_mp_set_tags	pipeline.c	/^int *num_mp_set_tags;$/;"	v
num_nullifiers	infeasible.h	/^  int      num_nullifiers;$/;"	m	struct:__anon10	access:public
num_nullifiers	infeasible.h	/^  int      num_nullifiers;$/;"	m	struct:__anon11	access:public
num_out	isa.h	/^    int	    num_in, num_out;	\/* number of input\/output operands *\/$/;"	m	struct:__anon16	access:public
num_plog_trunc	pipeline.c	/^int *num_plog_trunc;$/;"	v
num_plogs	pipeline.c	/^int num_plogs, num_elogs;$/;"	v
num_procs	cfg.h	/^    int		    num_procs;	\/\/ number of procedures$/;"	m	struct:__anon5	access:public
num_procs	ss/ss_readfile.c	/^int		num_procs;$/;"	v
num_resources	ss/resource.h	/^  int num_resources;			\/* total number of res instances *\/$/;"	m	struct:res_pool	access:public
num_tcfg_edges	tcfg.c	/^int num_tcfg_edges = 0;$/;"	v
num_tcfg_loops	loops.c	/^int num_tcfg_loops;$/;"	v
num_tcfg_loops	loops.h	/^int num_tcfg_loops;$/;"	v
num_tcfg_nodes	tcfg.c	/^int num_tcfg_nodes = 0, tcfg_size = 0;$/;"	v
num_topo_tcfg	tcfg.h	/^int num_topo_tcfg;$/;"	v
num_topo_tcfg_loops	tcfg.h	/^int num_topo_tcfg_loops;$/;"	v
num_vars	cfg.h	/^    int         num_vars;   \/\/ number of global variables$/;"	m	struct:__anon5	access:public
numberOfLoop	pipeline.c	/^int* numberOfLoop;$/;"	v
numberofContext	pipeline.c	/^int* numberofContext;$/;"	v
numberofLoadInst	ilp.c	/^int numberofLoadInst(tcfg_node_t* bbi) {$/;"	f	signature:(tcfg_node_t* bbi)
nvars	ss/options.h	/^  int nvars;			\/* > 1 if var for list options *\/$/;"	m	struct:opt_opt_t	access:public
oc	ss/options.h	/^  enum opt_class_t oc;		\/* class of this option *\/$/;"	m	struct:opt_opt_t	typeref:enum:opt_opt_t::opt_class_t	access:public
oc_NUM	ss/options.h	/^  oc_NUM$/;"	e	enum:opt_class_t
oc_double	ss/options.h	/^  oc_double,		\/* double option *\/$/;"	e	enum:opt_class_t
oc_enum	ss/options.h	/^  oc_enum,		\/* enumeration option *\/$/;"	e	enum:opt_class_t
oc_flag	ss/options.h	/^  oc_flag,		\/* boolean option *\/$/;"	e	enum:opt_class_t
oc_float	ss/options.h	/^  oc_float,		\/* float option *\/$/;"	e	enum:opt_class_t
oc_int	ss/options.h	/^  oc_int = 0,		\/* integer option *\/$/;"	e	enum:opt_class_t
oc_string	ss/options.h	/^  oc_string,		\/* string option *\/$/;"	e	enum:opt_class_t
oc_uint	ss/options.h	/^  oc_uint,		\/* unsigned integer option *\/$/;"	e	enum:opt_class_t
old	cache.h	/^	unsigned old;$/;"	m	struct:ovr_mapping	access:public
op	infeasible.h	/^  char  op[OP_LEN];$/;"	m	struct:__anon8	access:public
op_enum	isa.h	/^    int	    op_enum;	    	\/* continuous numbered opcode $/;"	m	struct:__anon16	access:public
opcode	isa.h	/^    int	    opcode;	\/\/ inst opcode$/;"	m	struct:__anon15	access:public
oplat	ss/resource.h	/^    int oplat;				\/* operation latency: cycles until$/;"	m	struct:res_desc::res_template	access:public
opr	symexec.h	/^	char opr[8]; \/\/inductive operation, e.g + - * \/ >>$/;"	m	struct:BIV	access:public
opt	unicache.c	/^int opt = 0;$/;"	v
opt_class_t	ss/options.h	/^enum opt_class_t {$/;"	g
opt_delete	ss/options.c	/^opt_delete(struct opt_odb_t *odb)	\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb)
opt_delete	ss/options.h	/^opt_delete(struct opt_odb_t *odb);	\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb)
opt_find_option	ss/options.c	/^opt_find_option(struct opt_odb_t *odb,	\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, char *opt_name)
opt_find_option	ss/options.h	/^opt_find_option(struct opt_odb_t *odb,	\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *opt_name)
opt_for_double_t	ss/options.h	/^    struct opt_for_double_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_for_enum_t	ss/options.h	/^    struct opt_for_enum_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_for_float_t	ss/options.h	/^    struct opt_for_float_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_for_int_t	ss/options.h	/^    struct opt_for_int_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_for_string_t	ss/options.h	/^    struct opt_for_string_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_for_uint_t	ss/options.h	/^    struct opt_for_uint_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_new	ss/options.c	/^opt_new(orphan_fn_t orphan_fn)	\/* user-specified orphan parser *\/$/;"	f	signature:(orphan_fn_t orphan_fn)
opt_new	ss/options.h	/^opt_new(orphan_fn_t orphan_fn);		\/* user-specified orphan parser *\/$/;"	p	signature:(orphan_fn_t orphan_fn)
opt_note_t	ss/options.h	/^struct opt_note_t {$/;"	s
opt_note_t::next	ss/options.h	/^  struct opt_note_t *next;	\/* next option note *\/$/;"	m	struct:opt_note_t	typeref:struct:opt_note_t::opt_note_t	access:public
opt_note_t::note	ss/options.h	/^  char *note;			\/* option note *\/$/;"	m	struct:opt_note_t	access:public
opt_null_string	ss/options.c	/^opt_null_string(struct opt_opt_t *opt)$/;"	f	signature:(struct opt_opt_t *opt)
opt_odb_t	ss/options.h	/^struct opt_odb_t {$/;"	s
opt_odb_t::header	ss/options.h	/^  char *header;			\/* options header *\/$/;"	m	struct:opt_odb_t	access:public
opt_odb_t::notes	ss/options.h	/^  struct opt_note_t *notes;	\/* option notes *\/$/;"	m	struct:opt_odb_t	typeref:struct:opt_odb_t::opt_note_t	access:public
opt_odb_t::options	ss/options.h	/^  struct opt_opt_t *options;	\/* user-installed options in option database *\/$/;"	m	struct:opt_odb_t	typeref:struct:opt_odb_t::opt_opt_t	access:public
opt_odb_t::orphan_fn	ss/options.h	/^  orphan_fn_t orphan_fn;	\/* user-specified orphan parser *\/$/;"	m	struct:opt_odb_t	access:public
opt_opt_t	ss/options.h	/^struct opt_opt_t {$/;"	s
opt_opt_t::accrue	ss/options.h	/^  int accrue;			\/* accrue list across uses *\/$/;"	m	struct:opt_opt_t	access:public
opt_opt_t::desc	ss/options.h	/^  char *desc;			\/* option description *\/$/;"	m	struct:opt_opt_t	access:public
opt_opt_t::format	ss/options.h	/^  char *format;			\/* option value print format *\/$/;"	m	struct:opt_opt_t	access:public
opt_opt_t::name	ss/options.h	/^  char *name;			\/* option name, e.g., "-foo:bar" *\/$/;"	m	struct:opt_opt_t	access:public
opt_opt_t::nelt	ss/options.h	/^  int *nelt;			\/* number of elements parsed *\/$/;"	m	struct:opt_opt_t	access:public
opt_opt_t::next	ss/options.h	/^  struct opt_opt_t *next;	\/* next option *\/$/;"	m	struct:opt_opt_t	typeref:struct:opt_opt_t::opt_opt_t	access:public
opt_opt_t::nvars	ss/options.h	/^  int nvars;			\/* > 1 if var for list options *\/$/;"	m	struct:opt_opt_t	access:public
opt_opt_t::oc	ss/options.h	/^  enum opt_class_t oc;		\/* class of this option *\/$/;"	m	struct:opt_opt_t	typeref:enum:opt_opt_t::opt_class_t	access:public
opt_opt_t::opt_variant_t	ss/options.h	/^  union opt_variant_t {$/;"	u	struct:opt_opt_t	access:public
opt_opt_t::opt_variant_t::for_double	ss/options.h	/^    } for_double;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_double_t	access:public
opt_opt_t::opt_variant_t::for_enum	ss/options.h	/^    } for_enum;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
opt_opt_t::opt_variant_t::for_float	ss/options.h	/^    } for_float;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_float_t	access:public
opt_opt_t::opt_variant_t::for_int	ss/options.h	/^    } for_int;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_int_t	access:public
opt_opt_t::opt_variant_t::for_string	ss/options.h	/^    } for_string;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_string_t	access:public
opt_opt_t::opt_variant_t::for_uint	ss/options.h	/^    } for_uint;$/;"	m	union:opt_opt_t::opt_variant_t	typeref:struct:opt_opt_t::opt_variant_t::opt_for_uint_t	access:public
opt_opt_t::opt_variant_t::opt_for_double_t	ss/options.h	/^    struct opt_for_double_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_opt_t::opt_variant_t::opt_for_double_t::var	ss/options.h	/^      double *var;		\/* pointer to double option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_double_t	access:public
opt_opt_t::opt_variant_t::opt_for_enum_t	ss/options.h	/^    struct opt_for_enum_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_opt_t::opt_variant_t::opt_for_enum_t::emap	ss/options.h	/^      char **emap;		\/* array of enum strings *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
opt_opt_t::opt_variant_t::opt_for_enum_t::emap_sz	ss/options.h	/^      int emap_sz;		\/* number of enum's in arrays *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
opt_opt_t::opt_variant_t::opt_for_enum_t::eval	ss/options.h	/^      int *eval;		\/* optional array of enum values *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
opt_opt_t::opt_variant_t::opt_for_enum_t::var	ss/options.h	/^      int *var;			\/* ptr to *int* enum option, NOTE: AN INT *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
opt_opt_t::opt_variant_t::opt_for_float_t	ss/options.h	/^    struct opt_for_float_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_opt_t::opt_variant_t::opt_for_float_t::var	ss/options.h	/^      float *var;		\/* pointer to float option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_float_t	access:public
opt_opt_t::opt_variant_t::opt_for_int_t	ss/options.h	/^    struct opt_for_int_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_opt_t::opt_variant_t::opt_for_int_t::var	ss/options.h	/^      int *var;			\/* pointer to integer option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_int_t	access:public
opt_opt_t::opt_variant_t::opt_for_string_t	ss/options.h	/^    struct opt_for_string_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_opt_t::opt_variant_t::opt_for_string_t::var	ss/options.h	/^      char **var;		\/* pointer to string pointer option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_string_t	access:public
opt_opt_t::opt_variant_t::opt_for_uint_t	ss/options.h	/^    struct opt_for_uint_t {$/;"	s	union:opt_opt_t::opt_variant_t	access:public
opt_opt_t::opt_variant_t::opt_for_uint_t::var	ss/options.h	/^      unsigned int *var;	\/* pointer to unsigned integer option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_uint_t	access:public
opt_opt_t::print	ss/options.h	/^  int print;			\/* print option during `-dumpconfig'? *\/$/;"	m	struct:opt_opt_t	access:public
opt_opt_t::variant	ss/options.h	/^  } variant;$/;"	m	struct:opt_opt_t	typeref:union:opt_opt_t::opt_variant_t	access:public
opt_print_help	ss/options.c	/^opt_print_help(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, FILE *fd)
opt_print_help	ss/options.h	/^opt_print_help(struct opt_odb_t *odb,	\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, FILE *fd)
opt_print_option	ss/options.c	/^opt_print_option(struct opt_opt_t *opt,\/* option variable *\/$/;"	f	signature:(struct opt_opt_t *opt, FILE *fd)
opt_print_option	ss/options.h	/^opt_print_option(struct opt_opt_t *opt,	\/* option variable *\/$/;"	p	signature:(struct opt_opt_t *opt, FILE *fd)
opt_print_options	ss/options.c	/^opt_print_options(struct opt_odb_t *odb,\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, FILE *fd, int terse, int notes)
opt_print_options	ss/options.h	/^opt_print_options(struct opt_odb_t *odb,\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, FILE *fd, int terse, int notes)
opt_process_options	ss/options.c	/^opt_process_options(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, int argc, char **argv)
opt_process_options	ss/options.h	/^opt_process_options(struct opt_odb_t *odb,	\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, int argc, char **argv)
opt_reg_double	ss/options.c	/^opt_reg_double(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, double *var, double def_val, int print, char *format)
opt_reg_double	ss/options.h	/^opt_reg_double(struct opt_odb_t *odb,	\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, double *var, double def_val, int print, char *format)
opt_reg_double_list	ss/options.c	/^opt_reg_double_list(struct opt_odb_t *odb, \/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, double *vars, int nvars, int *nelt, double *def_val, int print, char *format, int accrue)
opt_reg_double_list	ss/options.h	/^opt_reg_double_list(struct opt_odb_t *odb,\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, double *vars, int nvars, int *nelt, double *def_val, int print, char *format, int accrue)
opt_reg_enum	ss/options.c	/^opt_reg_enum(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, int *var, char *def_val, char **emap, int *eval, int emap_sz, int print, char *format)
opt_reg_enum	ss/options.h	/^opt_reg_enum(struct opt_odb_t *odb,	\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, int *var, char *def_val, char **emap, int *eval, int emap_sz, int print, char *format)
opt_reg_enum_list	ss/options.c	/^opt_reg_enum_list(struct opt_odb_t *odb,\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, int *vars, int nvars, int *nelt, char *def_val, char **emap, int *eval, int emap_sz, int print, char *format, int accrue)
opt_reg_enum_list	ss/options.h	/^opt_reg_enum_list(struct opt_odb_t *odb,\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, int *vars, int nvars, int *nelt, char *def_val, char **emap, int *eval, int emap_sz, int print, char *format, int accrue)
opt_reg_flag	ss/options.c	/^opt_reg_flag(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, int *var, int def_val, int print, char *format)
opt_reg_flag	ss/options.h	/^opt_reg_flag(struct opt_odb_t *odb,	\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, int *var, int def_val, int print, char *format)
opt_reg_flag_list	ss/options.c	/^opt_reg_flag_list(struct opt_odb_t *odb,\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, int *vars, int nvars, int *nelt, int *def_val, int print, char *format, int accrue)
opt_reg_flag_list	ss/options.h	/^opt_reg_flag_list(struct opt_odb_t *odb,\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, int *vars, int nvars, int *nelt, int *def_val, int print, char *format, int accrue)
opt_reg_float	ss/options.c	/^opt_reg_float(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, float *var, float def_val, int print, char *format)
opt_reg_float	ss/options.h	/^opt_reg_float(struct opt_odb_t *odb,	\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, float *var, float def_val, int print, char *format)
opt_reg_float_list	ss/options.c	/^opt_reg_float_list(struct opt_odb_t *odb,\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, float *vars, int nvars, int *nelt, float *def_val, int print, char *format, int accrue)
opt_reg_float_list	ss/options.h	/^opt_reg_float_list(struct opt_odb_t *odb,\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, float *vars, int nvars, int *nelt, float *def_val, int print, char *format, int accrue)
opt_reg_header	ss/options.c	/^opt_reg_header(struct opt_odb_t *odb,	\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, char *header)
opt_reg_header	ss/options.h	/^opt_reg_header(struct opt_odb_t *odb,	\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *header)
opt_reg_int	ss/options.c	/^opt_reg_int(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, int *var, int def_val, int print, char *format)
opt_reg_int	ss/options.h	/^opt_reg_int(struct opt_odb_t *odb,	\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, int *var, int def_val, int print, char *format)
opt_reg_int_list	ss/options.c	/^opt_reg_int_list(struct opt_odb_t *odb,\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, int *vars, int nvars, int *nelt, int *def_val, int print, char *format, int accrue)
opt_reg_int_list	ss/options.h	/^opt_reg_int_list(struct opt_odb_t *odb,	\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, int *vars, int nvars, int *nelt, int *def_val, int print, char *format, int accrue)
opt_reg_note	ss/options.c	/^opt_reg_note(struct opt_odb_t *odb,	\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, char *note_str)
opt_reg_note	ss/options.h	/^opt_reg_note(struct opt_odb_t *odb,	\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *note)
opt_reg_string	ss/options.c	/^opt_reg_string(struct opt_odb_t *odb,	\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, char **var, char *def_val, int print, char *format)
opt_reg_string	ss/options.h	/^opt_reg_string(struct opt_odb_t *odb,	\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, char **var, char *def_val, int print, char *format)
opt_reg_string_list	ss/options.c	/^opt_reg_string_list(struct opt_odb_t *odb,\/* option data base *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, char **vars, int nvars, int *nelt, char **def_val, int print, char *format, int accrue)
opt_reg_string_list	ss/options.h	/^opt_reg_string_list(struct opt_odb_t *odb,\/* option data base *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, char **vars, int nvars, int *nelt, char **def_val, int print, char *format, int accrue)
opt_reg_uint	ss/options.c	/^opt_reg_uint(struct opt_odb_t *odb,	\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, unsigned int *var, unsigned int def_val, int print, char *format)
opt_reg_uint	ss/options.h	/^opt_reg_uint(struct opt_odb_t *odb,	\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, unsigned int *var, unsigned int def_val, int print, char *format)
opt_reg_uint_list	ss/options.c	/^opt_reg_uint_list(struct opt_odb_t *odb,\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, char *name, char *desc, unsigned int *vars, int nvars, int *nelt, unsigned int *def_val, int print, char *format, int accrue)
opt_reg_uint_list	ss/options.h	/^opt_reg_uint_list(struct opt_odb_t *odb,\/* option database *\/$/;"	p	signature:(struct opt_odb_t *odb, char *name, char *desc, unsigned int *vars, int nvars, int *nelt, unsigned int *def_val, int print, char *format, int accrue)
opt_variant_t	ss/options.h	/^  union opt_variant_t {$/;"	u	struct:opt_opt_t	access:public
options	ss/options.h	/^  struct opt_opt_t *options;	\/* user-installed options in option database *\/$/;"	m	struct:opt_odb_t	typeref:struct:opt_odb_t::opt_opt_t	access:public
orphan_fn	ss/my_opt.c	/^static int orphan_fn(int i, int argc, char **argv) {$/;"	f	file:	signature:(int i, int argc, char **argv)
orphan_fn	ss/options.h	/^  orphan_fn_t orphan_fn;	\/* user-specified orphan parser *\/$/;"	m	struct:opt_odb_t	access:public
orphan_fn_t	ss/options.h	/^(*orphan_fn_t)(int i,		\/* index of the orphan'ed argument *\/$/;"	t
out	bpred.h	/^    bfg_edge_t	*out;	\/\/ out edges$/;"	m	struct:__anon1	access:public
out	exegraph.h	/^    egraph_edge_t   *in, *out;$/;"	m	struct:__anon32	access:public
out	isa.h	/^    int	    *in, *out;		   \/* input\/output operands (registers) *\/$/;"	m	struct:__anon16	access:public
out	tcfg.h	/^	tcfg_edge_t *in, *out; \/\/ incoming and outgoing edges$/;"	m	struct:__anon38	access:public
out_abs_mem_value	cfg.h	/^	 abs_mem_p out_abs_mem_value; \/*  memory locations *\/$/;"	m	struct:__anon3	access:public
out_abs_reg_value	cfg.h	/^	 ric_p* out_abs_reg_value; \/* indexed in this structure *\/$/;"	m	struct:__anon3	access:public
out_n	cfg.h	/^    cfg_edge_t	*out_n, *out_t;	\/\/ outgoing edges (non-taken\/taken) $/;"	m	struct:__anon3	access:public
out_t	cfg.h	/^    cfg_edge_t	*out_n, *out_t;	\/\/ outgoing edges (non-taken\/taken) $/;"	m	struct:__anon3	access:public
ovr_map_p	cache.h	/^typedef struct ovr_mapping* ovr_map_p;$/;"	t	typeref:struct:ovr_mapping
ovr_map_s	cache.h	/^typedef struct ovr_mapping ovr_map_s;$/;"	t	typeref:struct:ovr_mapping
ovr_mapping	cache.h	/^struct ovr_mapping {$/;"	s
ovr_mapping::newb	cache.h	/^	unsigned newb;$/;"	m	struct:ovr_mapping	access:public
ovr_mapping::next	cache.h	/^	struct ovr_mapping* next;$/;"	m	struct:ovr_mapping	typeref:struct:ovr_mapping::ovr_mapping	access:public
ovr_mapping::old	cache.h	/^	unsigned old;$/;"	m	struct:ovr_mapping	access:public
ovrl_graph	cfg.h	/^struct ovrl_graph {$/;"	s
ovrl_graph::__anon7::inst	cfg.h	/^		 de_inst_t* inst;$/;"	m	union:ovrl_graph::__anon7	access:public
ovrl_graph::__anon7::pref	cfg.h	/^		 col_data_p pref;$/;"	m	union:ovrl_graph::__anon7	access:public
ovrl_graph::__anon7::proc	cfg.h	/^		 proc_t* proc;$/;"	m	union:ovrl_graph::__anon7	access:public
ovrl_graph::freq	cfg.h	/^	int freq;$/;"	m	struct:ovrl_graph	access:public
ovrl_graph::invalid	cfg.h	/^	int invalid;$/;"	m	struct:ovrl_graph	access:public
ovrl_graph::next	cfg.h	/^	struct ovrl_graph* next;$/;"	m	struct:ovrl_graph	typeref:struct:ovrl_graph::ovrl_graph	access:public
ovrl_graph::type	cfg.h	/^	int type;$/;"	m	struct:ovrl_graph	access:public
ovrl_graph::u	cfg.h	/^	}u;$/;"	m	struct:ovrl_graph	typeref:union:ovrl_graph::__anon7	access:public
ovrl_graph_p	cfg.h	/^typedef struct ovrl_graph* ovrl_graph_p;$/;"	t	typeref:struct:ovrl_graph
ovrl_graph_s	cfg.h	/^typedef struct ovrl_graph ovrl_graph_s;$/;"	t	typeref:struct:ovrl_graph
p	ss/eval.h	/^  char *p;			\/* ptr to next char to consume from expr *\/$/;"	m	struct:eval_state_t	access:public
p_dequeue	common.c	/^void* p_dequeue(P_Queue **headList) {$/;"	f	signature:(P_Queue **headList)
p_dequeue	common.h	/^void* p_dequeue(P_Queue **headList);$/;"	p	signature:(P_Queue **headList)
p_enqueue	common.c	/^void p_enqueue(P_Queue **headList, void *newItem, int key) {$/;"	f	signature:(P_Queue **headList, void *newItem, int key)
p_enqueue	common.h	/^void p_enqueue(P_Queue **headList, void *newItem, int key);$/;"	p	signature:(P_Queue **headList, void *newItem, int key)
p_info	cfg.h	/^    symbol_i    *p_info;    \/\/ procedure symbol info$/;"	m	struct:__anon5	access:public
p_queue_empty	common.c	/^int p_queue_empty(P_Queue **headList) {$/;"	f	signature:(P_Queue **headList)
p_queue_empty	common.h	/^int p_queue_empty(P_Queue **headList);$/;"	p	signature:(P_Queue **headList)
panic	ss/misc.c	/^panic(char *fmt, ...)$/;"	f	signature:(char *fmt, ...)
panic	ss/misc.h	/^panic(char *fmt, ...);$/;"	p	signature:(char *fmt, ...)
panicRegType	reg.c	/^void panicRegType(reg_t reg) {$/;"	f	signature:(reg_t reg)
para	symexec.h	/^	char para[4];$/;"	m	struct:__anon17	access:public
parent	loops.h	/^    loop_t	        *parent;$/;"	m	struct:loop_t	access:public
path_analysis	main.c	/^static void path_analysis(char *fName) {$/;"	f	file:	signature:(char *fName)
pcreg	ss/ecoff.h	/^  short pcreg;$/;"	m	struct:ecoff_pdr	access:public
pdepth	main.c	/^int *pdepth;$/;"	v
peek_next_token	ss/eval.c	/^peek_next_token(struct eval_state_t *es) \/* expression evalutor *\/$/;"	f	file:	signature:(struct eval_state_t *es)
peek_tok	ss/eval.h	/^  enum eval_token_t peek_tok;	\/* peek buffer, for one token look-ahead *\/$/;"	m	struct:eval_state_t	typeref:enum:eval_state_t::eval_token_t	access:public
pfu_quant	ss/ss_machine.c	/^pfu_quant[] = {$/;"	v
pi	bpred.h	/^    short	pi;	\/\/ branch context (bhr manipulated with branch address)$/;"	m	struct:__anon1	access:public
pi_table	bpred.c	/^int		    *pi_table;$/;"	v
pid	infeasible.h	/^  int pid;                \/\/ procedure id$/;"	m	struct:__anon14	access:public
pipe_analysis	pipeline.c	/^void pipe_analysis() {$/;"	f
pipe_ibuf_size	pipeline.c	/^int pipe_ibuf_size;$/;"	v
pipe_iwin_size	pipeline.c	/^int pipe_iwin_size;$/;"	v
pipe_iwin_size	pipeline.c	/^int prolog_size, pipe_iwin_size;$/;"	v
pipe_stages	pipeline.c	/^int pipe_stages = 5;$/;"	v
pjptb	main.c	/^jptb * pjptb;$/;"	v
plog_backtrack	estimate.c	/^plog_backtrack(egraph_edge_t *e)$/;"	f	file:	signature:(egraph_edge_t *e)
plog_len	exegraph.c	/^int		eg_len = 0, plog_len = 0, elog_len = 0, body_len = 0;$/;"	v
pred	exegraph.h	/^    short   pred;$/;"	m	struct:__anon33	access:public
pred_type	ss/my_opt.c	/^char *pred_type;$/;"	v
pref	cfg.h	/^		 col_data_p pref;$/;"	m	union:ovrl_graph::__anon7	access:public
prerr	unicache.c	/^void prerr(char* msg) {$/;"	f	signature:(char* msg)
prev_in	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
prev_out	bpred.h	/^    bfg_edge_t  *prev_out, *next_out, *prev_in, *next_in;$/;"	m	struct:bfg_edge_t	access:public
print	ss/options.h	/^  int print;			\/* print option during `-dumpconfig'? *\/$/;"	m	struct:opt_opt_t	access:public
printAcs	unicache.c	/^void printAcs(acs_p** acs_print) {$/;"	f	signature:(acs_p** acs_print)
printAssign	infdump.c	/^int printAssign( assign_t *assg, char printcf ) {$/;"	f	signature:( assign_t *assg, char printcf )
printBAConflict	infdump.c	/^int printBAConflict( BA_conflict_t *cf ) {$/;"	f	signature:( BA_conflict_t *cf )
printBBConflict	infdump.c	/^int printBBConflict( BB_conflict_t *cf ) {$/;"	f	signature:( BB_conflict_t *cf )
printBIV	reg.c	/^void printBIV(FILE *fp, biv_p biVar) {$/;"	f	signature:(FILE *fp, biv_p biVar)
printBIV	symexec.h	/^void printBIV(FILE *fp, biv_p biVar);$/;"	p	signature:(FILE *fp, biv_p biVar)
printBIV	symexec_value.c	/^void printBIV(FILE *fp, biv_p biVar) {$/;"	f	signature:(FILE *fp, biv_p biVar)
printBranch	infdump.c	/^int printBranch( branch_t *br, char printcf ) {$/;"	f	signature:( branch_t *br, char printcf )
printContext	ilp.c	/^static void printContext(int context, int length, char* st) {$/;"	f	file:	signature:(int context, int length, char* st)
printDataRef	symexec.c	/^void printDataRef(FILE *fp,dat_inst_t *d_inst) {$/;"	f	signature:(FILE *fp,dat_inst_t *d_inst)
printDataRef	symexec.h	/^void printDataRef(FILE *fp, dat_inst_t* datInst);$/;"	p	signature:(FILE *fp, dat_inst_t* datInst)
printEffects	infdump.c	/^int printEffects( char printcf ) {$/;"	f	signature:( char printcf )
printExpr	reg.c	/^void printExpr(FILE* fp, expr_p expr) {$/;"	f	signature:(FILE* fp, expr_p expr)
printExpr	symexec.h	/^void printExpr(FILE* fp, expr_p expr);$/;"	p	signature:(FILE* fp, expr_p expr)
printInstr	infdump.c	/^void printInstr( insn_t *is ) {$/;"	f	signature:( insn_t *is )
printInstructions	infdump.c	/^int printInstructions() {$/;"	f
printMemList	symexec.c	/^void    printMemList(FILE* fp, worklist_p);$/;"	p	file:	signature:(FILE* fp, worklist_p)
printMemList	symexec.c	/^void printMemList(FILE *fp,worklist_p memList) {$/;"	f	signature:(FILE *fp,worklist_p memList)
printReg	reg.c	/^void printReg(FILE *fp, reg_t reg) {$/;"	f	signature:(FILE *fp, reg_t reg)
printReg	symexec.h	/^void printReg(FILE *fp, reg_t reg);$/;"	p	signature:(FILE *fp, reg_t reg)
printRegList	reg.c	/^void printRegList(FILE *fp, reg_t *regList) {$/;"	f	signature:(FILE *fp, reg_t *regList)
printSAddr	scp_address.c	/^void printSAddr(FILE *fp, saddr_p memblk, int full) {$/;"	f	signature:(FILE *fp, saddr_p memblk, int full)
printSAddr	scp_address.h	/^void    printSAddr(FILE *fp, saddr_p memblk, int full);   \/\/print one scoped mem$/;"	p	signature:(FILE *fp, saddr_p memblk, int full)
printSAddrSet	scp_address.c	/^void printSAddrSet(FILE *fp, worklist_p addrSet, int full) {$/;"	f	signature:(FILE *fp, worklist_p addrSet, int full)
printSAddrSet	scp_address.h	/^void    printSAddrSet(FILE *fp, worklist_p sAddrSet,int full);\/\/print set scpmem$/;"	p	signature:(FILE *fp, worklist_p sAddrSet,int full)
printTS	scp_address.c	/^void printTS(FILE *fp, ts_p ts) {$/;"	f	signature:(FILE *fp, ts_p ts)
printTS	scp_address.h	/^void    printTS(FILE *fp, ts_p as);$/;"	p	signature:(FILE *fp, ts_p as)
printTSset	scp_address.c	/^void printTSset(FILE *fp, worklist_p tsSet) {$/;"	f	signature:(FILE *fp, worklist_p tsSet)
printTSset	scp_address.h	/^void    printTSset(FILE *fp, worklist_p tsSet);$/;"	p	signature:(FILE *fp, worklist_p tsSet)
print_help	ss/options.c	/^print_help(struct opt_opt_t *opt,	\/* option variable *\/$/;"	f	file:	signature:(struct opt_opt_t *opt, FILE *fd)
print_option_header	ss/options.c	/^print_option_header(struct opt_odb_t *odb,\/* options database *\/$/;"	f	file:	signature:(struct opt_odb_t *odb, FILE *fd)
print_option_notes	ss/options.c	/^print_option_notes(struct opt_odb_t *odb,\/* options database *\/$/;"	f	file:	signature:(struct opt_odb_t *odb, FILE *fd)
printflag	scp_cache.h	/^int printflag;$/;"	v
priority_queue_t	common.h	/^typedef struct priority_queue_t {$/;"	s
priority_queue_t::elem	common.h	/^    void *elem;$/;"	m	struct:priority_queue_t	access:public
priority_queue_t::key	common.h	/^    int  key;$/;"	m	struct:priority_queue_t	access:public
priority_queue_t::next	common.h	/^    struct priority_queue_t *next;$/;"	m	struct:priority_queue_t	typeref:struct:priority_queue_t::priority_queue_t	access:public
proc	cfg.h	/^		 proc_t* proc;$/;"	m	union:col_data::__anon6	access:public
proc	cfg.h	/^		 proc_t* proc;$/;"	m	union:ovrl_graph::__anon7	access:public
proc	cfg.h	/^    proc_t  	*proc;		\/\/ up-link to the procedure containing it$/;"	m	struct:__anon3	access:public
proc	infeasible.h	/^  proc_t *proc;$/;"	m	struct:__anon13	access:public
proc_inline	tcfg.c	/^proc_inline(proc_t *proc, tcfg_node_t *call_bbi, tcfg_node_t *ret_bbi,$/;"	f	file:	signature:(proc_t *proc, tcfg_node_t *call_bbi, tcfg_node_t *ret_bbi, int depth)
proc_t	cfg.h	/^struct proc_t {$/;"	s
proc_t	cfg.h	/^typedef struct proc_t	    proc_t;$/;"	t	typeref:struct:proc_t
proc_t::cfg	cfg.h	/^    cfg_node_t	*cfg;		\/\/ cfg nodes with num_bb nodes$/;"	m	struct:proc_t	access:public
proc_t::code	cfg.h	/^    de_inst_t   *code;		\/\/ instructions$/;"	m	struct:proc_t	access:public
proc_t::flags	cfg.h	/^    int		flags;$/;"	m	struct:proc_t	access:public
proc_t::id	cfg.h	/^    int		id;		\/\/ proc id$/;"	m	struct:proc_t	access:public
proc_t::num_bb	cfg.h	/^    int		num_bb;		\/\/ number of basic blocks$/;"	m	struct:proc_t	access:public
proc_t::num_inst	cfg.h	/^    int		num_inst;	\/\/ number of instructions$/;"	m	struct:proc_t	access:public
proc_t::sa	cfg.h	/^    addr_t	sa;		\/\/ proc start addr$/;"	m	struct:proc_t	access:public
proc_t::size	cfg.h	/^    int		size;		\/\/ size (in bytes)$/;"	m	struct:proc_t	access:public
process_file	ss/options.c	/^process_file(struct opt_odb_t *odb, char *fname, int depth)$/;"	f	file:	signature:(struct opt_odb_t *odb, char *fname, int depth)
process_file	ss/options.c	/^static void process_file(struct opt_odb_t *odb, char *fname, int depth);$/;"	p	file:	signature:(struct opt_odb_t *odb, char *fname, int depth)
process_option	ss/options.c	/^process_option(struct opt_odb_t *odb,	\/* option database *\/$/;"	f	signature:(struct opt_odb_t *odb, int index, int argc, char **argv)
procs	cfg.h	/^    proc_t	    *procs;		\/\/ procedures$/;"	m	struct:__anon5	access:public
procs_addr	ss/ss_readfile.c	/^addr_t		*procs_addr; $/;"	v
prog	main.c	/^prog_t prog;$/;"	v
prog_name	est.sh	/^prog_name()$/;"	f
prog_name	sim.sh	/^prog_name()$/;"	f
prog_name	solve.sh	/^prog_name()$/;"	f
prog_name	solve_time.sh	/^prog_name()$/;"	f
prog_t	cfg.h	/^} prog_t;$/;"	t	typeref:struct:__anon5
prog_tran	tcfg.c	/^prog_tran()$/;"	f
prog_tran	tcfg.h	/^prog_tran();$/;"	p	signature:()
prolog_size	pipeline.c	/^int prolog_size, pipe_iwin_size;$/;"	v
prologs	pipeline.c	/^code_link_t **prologs, **epilogs;$/;"	v
prvAcsNode	scp_cache.c	/^worklist_p *prvAcsNode;$/;"	v
psLoop	scp_address.h	/^    worklist_p			psLoop;$/;"	m	struct:scoped_address	access:public
ptarget	main.c	/^	addr_t *ptarget;$/;"	m	struct:jptb	file:	access:public
pub	ss/symbol.h	/^  int pub;			\/* externally visible? *\/$/;"	m	struct:sym_sym_t	access:public
quantity	ss/resource.h	/^  int quantity;				\/* total instances of this unit *\/$/;"	m	struct:res_desc	access:public
queue_empty	common.c	/^queue_empty(Queue *queue)$/;"	f	signature:(Queue *queue)
queue_t	common.h	/^typedef struct queue_t {$/;"	s
queue_t::base	common.h	/^    void    *base;$/;"	m	struct:queue_t	access:public
queue_t::capt	common.h	/^    int	    capt;	    \/* capacity *\/$/;"	m	struct:queue_t	access:public
queue_t::esize	common.h	/^    int	    esize;	    \/* element size *\/$/;"	m	struct:queue_t	access:public
queue_t::head	common.h	/^    void    *head, *tail;   \/* head points to oldest element *\/$/;"	m	struct:queue_t	access:public
queue_t::tail	common.h	/^    void    *head, *tail;   \/* head points to oldest element *\/$/;"	m	struct:queue_t	access:public
qword_t	ss/host.h	/^typedef unsigned __int64 qword_t;	\/* qword - 64 bits *\/$/;"	t
qword_t	ss/host.h	/^typedef unsigned long long qword_t;	\/* qword - 64 bits *\/$/;"	t
qword_t	ss/host.h	/^typedef unsigned long qword_t;		\/* qword - 64 bits *\/$/;"	t
r1	infeasible.h	/^  char  r1[OP_LEN];$/;"	m	struct:__anon8	access:public
r2	infeasible.h	/^  char  r2[OP_LEN];$/;"	m	struct:__anon8	access:public
r3	infeasible.h	/^  char  r3[OP_LEN];$/;"	m	struct:__anon8	access:public
rBound	loops.h	/^    int             rBound;    \/\/relative bound$/;"	m	struct:loop_t	access:public
rId	loops.h	/^    int             rId;       \/\/relative bound compared to loop rbId$/;"	m	struct:loop_t	access:public
rType	loops.h	/^    int             rType;     \/\/type of relative loop bound$/;"	m	struct:loop_t	access:public
r_addr	isa.h	/^    addr_t  r_addr;$/;"	m	struct:__anon16	access:public
range16_t	common.h	/^} range16_t;$/;"	t	typeref:struct:__anon36
range8_t	common.h	/^} range8_t;$/;"	t	typeref:struct:__anon37
range_isect	common.c	/^range_isect(range_t *x, range_t *y)$/;"	f	signature:(range_t *x, range_t *y)
range_isect	common.h	/^range_isect(range_t *x, range_t *y);$/;"	p	signature:(range_t *x, range_t *y)
range_t	common.h	/^} range_t;$/;"	t	typeref:struct:__anon35
range_union	common.c	/^range_union(range_t *x, range_t *y)$/;"	f	signature:(range_t *x, range_t *y)
range_union	common.h	/^range_union(range_t *x, range_t *y);$/;"	p	signature:(range_t *x, range_t *y)
ras_size	ss/my_opt.c	/^int ras_size = 8;$/;"	v
rdy	exegraph.h	/^    range_t	    rdy, str, fin;	\/\/ ready, start, finish$/;"	m	struct:__anon32	access:public
reInit	symexec.c	/^static void reInit(inf_proc_t* p, int startId, int endId, int *visited) {$/;"	f	file:	signature:(inf_proc_t* p, int startId, int endId, int *visited)
reach	bpred.c	/^reach(bfg_node_t *x, bfg_node_t *y, int branch)$/;"	f	file:	signature:(bfg_node_t *x, bfg_node_t *y, int branch)
reach_end	bpred.c	/^reach_end(bfg_node_t *x, int branch)$/;"	f	file:	signature:(bfg_node_t *x, int branch)
reachableNoCancel	conflicts.c	/^int reachableNoCancel( char *res, assign_t ***nullifier_list, int *num_nullifiers,$/;"	f	signature:( char *res, assign_t ***nullifier_list, int *num_nullifiers, int pid, int srcid, int destid, char *deritree, assign_t *assg, cfg_node_t *bblist, int num_bb, char **visited )
readBlockCounts	infeasible.c	/^int readBlockCounts( char *obj_file ) {$/;"	f	signature:( char *obj_file )
readEstWCET	scripts/runAllOpt.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runAll_Mul_Opt.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runDefault.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runEst.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runEstp1.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runEstp2.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runSim.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runSimM.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runSimP.sh	/^readEstWCET(){$/;"	f
readEstWCET	scripts/runSimS.sh	/^readEstWCET(){$/;"	f
readExtraCons	scp_tscope.c	/^void readExtraCons(char *bin_fname) {$/;"	f	signature:(char *bin_fname)
readInsn	infeasible.c	/^void readInsn ( char *obj_file ) {$/;"	f	signature:( char *obj_file )
readInstr	infeasible.c	/^void readInstr( char *obj_file ) {$/;"	f	signature:( char *obj_file )
readObsWCET	scripts/runAllOpt.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runAll_Mul_Opt.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runBenchmarks.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runBenchmarksORG.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runDefault.sh	/^readObsWCET(){$/;"	f
readObsWCET	scripts/runEstp1.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runEstp2.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runSim.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runSimM.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runSimP.sh	/^readObsWCET()$/;"	f
readObsWCET	scripts/runSimS.sh	/^readObsWCET()$/;"	f
readSizeCons	scp_tscope.c	/^void readSizeCons(char *bin_fname) {$/;"	f	signature:(char *bin_fname)
readSymExecResult	symexec.c	/^static void readSymExecResult(inf_node_t *ib) {$/;"	f	file:	signature:(inf_node_t *ib)
readSymExecResult	symexec.c	/^static void readSymExecResult(inf_node_t *ib);$/;"	p	file:	signature:(inf_node_t *ib)
read_code	readfile.c	/^read_code(char *fname)$/;"	f	signature:(char *fname)
read_code_ss	ss/ss_readfile.c	/^read_code_ss(char *fname)$/;"	f	signature:(char *fname)
read_functions	main.c	/^int read_functions(char *obj_file) {$/;"	f	signature:(char *obj_file)
read_injp	main.c	/^void read_injp(char * objfile) {$/;"	f	signature:(char * objfile)
read_inst	ss/ss_readfile.c	/^read_inst(FILE *fp, addr_t addr, int i)$/;"	f	file:	signature:(FILE *fp, addr_t addr, int i)
read_opt	options.c	/^read_opt(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
read_opt_ss	ss/my_opt.c	/^int read_opt_ss(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
read_recursive	main.c	/^void read_recursive(char * objfile) {$/;"	f	signature:(char * objfile)
read_text_head	ss/ss_readfile.c	/^read_text_head(FILE *fp)$/;"	f	file:	signature:(FILE *fp)
ready_earlier	ss/ss_exegraph.c	/^static int ready_earlier(int inst1, int inst2) {$/;"	f	file:	signature:(int inst1, int inst2)
rearrangeTS	scp_address.c	/^void rearrangeTS(saddr_p smem) {$/;"	f	signature:(saddr_p smem)
rearrangeTS	scp_address.h	/^void        rearrangeTS(saddr_p smem);$/;"	p	signature:(saddr_p smem)
reg	ss/machine.h	/^  int reg;			\/* register index *\/$/;"	m	struct:md_reg_names_t	access:public
reg2expr	reg.c	/^void reg2expr(reg_t *r) {$/;"	f	signature:(reg_t *r)
reg2expr	symexec.h	/^void reg2expr(reg_t *r);$/;"	p	signature:(reg_t *r)
regDerive	symexec.c	/^static int  regDerive(inf_node_t *ib,insn_t *insn,int ignore,char *jal,int dbg);$/;"	p	file:	signature:(inf_node_t *ib,insn_t *insn,int ignore,char *jal,int dbg)
regDerive	symexec.c	/^static int regDerive(inf_node_t *ib, insn_t *insn, $/;"	f	file:	signature:(inf_node_t *ib, insn_t *insn, int ignore, char *jal, int dbg)
regEq	reg.c	/^int regEq( reg_t reg1, reg_t reg2 ) {$/;"	f	signature:( reg_t reg1, reg_t reg2 )
regEq	symexec.h	/^int regEq(reg_t reg1, reg_t reg2);$/;"	p	signature:(reg_t reg1, reg_t reg2)
regListIn	infeasible.h	/^  void         *regListIn;  $/;"	m	struct:__anon12	access:public
regListOut	infeasible.h	/^  void         *regListOut;$/;"	m	struct:__anon12	access:public
regName	symexec.h	/^	char regName[10];$/;"	m	struct:BIV	access:public
regOpr	reg.c	/^int regOpr(char *op,reg_t *rD, reg_t r1, reg_t r2) {$/;"	f	signature:(char *op,reg_t *rD, reg_t r1, reg_t r2)
regOpr	symexec.h	/^int regOpr(char *op, reg_t *rD, reg_t r1, reg_t r2); \/\/abs.opr on r.values$/;"	p	signature:(char *op, reg_t *rD, reg_t r1, reg_t r2)
regRedefined	symexec.c	/^static int  regRedefined(char *regName, insn_t *insn);$/;"	p	file:	signature:(char *regName, insn_t *insn)
regRedefined	symexec.c	/^static int regRedefined(char* regName, insn_t *insn) {$/;"	f	file:	signature:(char* regName, insn_t *insn)
regUnknown	reg.c	/^void regUnknown(reg_t *reg) {$/;"	f	signature:(reg_t *reg)
regUnknown	symexec.h	/^void regUnknown(reg_t *reg);$/;"	p	signature:(reg_t *reg)
regValue	symexec.h	/^	reg_t regValue; \/*reg. value saved in this entry*\/$/;"	m	struct:sym_memory_model	access:public
reg_loop_exit	loops.c	/^static void reg_loop_exit(tcfg_edge_t *e) {$/;"	f	file:	signature:(tcfg_edge_t *e)
reg_t	symexec.h	/^} reg_t;$/;"	t	typeref:struct:__anon17
regmask	ss/ecoff.h	/^  int regmask;$/;"	m	struct:ecoff_pdr	access:public
regoffset	ss/ecoff.h	/^  int regoffset;$/;"	m	struct:ecoff_pdr	access:public
regs_C	ss/regs.h	/^  md_ctrl_t regs_C;		\/* control register file *\/$/;"	m	struct:regs_t	access:public
regs_F	ss/regs.h	/^  md_fpr_t regs_F;		\/* floating point register file *\/$/;"	m	struct:regs_t	access:public
regs_NPC	ss/regs.h	/^  md_addr_t regs_NPC;		\/* next-cycle program counter *\/$/;"	m	struct:regs_t	access:public
regs_PC	ss/regs.h	/^  md_addr_t regs_PC;		\/* program counter *\/$/;"	m	struct:regs_t	access:public
regs_R	ss/regs.h	/^  md_gpr_t regs_R;		\/* (signed) integer register file *\/$/;"	m	struct:regs_t	access:public
regs_create	ss/regs.h	/^struct regs_t *regs_create(void);$/;"	p	signature:(void)
regs_destroy	ss/regs.h	/^regs_destroy(struct regs_t *regs);	\/* register file to release *\/$/;"	p	signature:(struct regs_t *regs)
regs_dump	ss/regs.h	/^regs_dump(struct regs_t *regs,		\/* register file to display *\/$/;"	p	signature:(struct regs_t *regs, FILE *stream)
regs_init	ss/regs.h	/^regs_init(struct regs_t *regs);		\/* register file to initialize *\/$/;"	p	signature:(struct regs_t *regs)
regs_t	ss/regs.h	/^struct regs_t {$/;"	s
regs_t::regs_C	ss/regs.h	/^  md_ctrl_t regs_C;		\/* control register file *\/$/;"	m	struct:regs_t	access:public
regs_t::regs_F	ss/regs.h	/^  md_fpr_t regs_F;		\/* floating point register file *\/$/;"	m	struct:regs_t	access:public
regs_t::regs_NPC	ss/regs.h	/^  md_addr_t regs_NPC;		\/* next-cycle program counter *\/$/;"	m	struct:regs_t	access:public
regs_t::regs_PC	ss/regs.h	/^  md_addr_t regs_PC;		\/* program counter *\/$/;"	m	struct:regs_t	access:public
regs_t::regs_R	ss/regs.h	/^  md_gpr_t regs_R;		\/* (signed) integer register file *\/$/;"	m	struct:regs_t	access:public
remAfterNode	common.c	/^void remAfterNode(worklist_p *prvNode, worklist_p *headNode) {$/;"	f	signature:(worklist_p *prvNode, worklist_p *headNode)
removeOneFromWorkList	common.c	/^void* removeOneFromWorkList(worklist_p* Wlist)$/;"	f	signature:(worklist_p* Wlist)
removeOneFromWorkList	common.h	/^void* removeOneFromWorkList(worklist_p* Wlist);$/;"	p	signature:(worklist_p* Wlist)
res_create_pool	ss/resource.h	/^struct res_pool *res_create_pool(char *name, struct res_desc *pool, int ndesc);$/;"	p	signature:(char *name, struct res_desc *pool, int ndesc)
res_desc	ss/resource.h	/^struct res_desc {$/;"	s
res_desc::busy	ss/resource.h	/^  int busy;				\/* non-zero if this unit is busy *\/$/;"	m	struct:res_desc	access:public
res_desc::name	ss/resource.h	/^  char *name;				\/* name of functional unit *\/$/;"	m	struct:res_desc	access:public
res_desc::quantity	ss/resource.h	/^  int quantity;				\/* total instances of this unit *\/$/;"	m	struct:res_desc	access:public
res_desc::res_template	ss/resource.h	/^  struct res_template {$/;"	s	struct:res_desc	access:public
res_desc::res_template::issuelat	ss/resource.h	/^    int issuelat;			\/* issue latency: number of cycles$/;"	m	struct:res_desc::res_template	access:public
res_desc::res_template::master	ss/resource.h	/^    struct res_desc *master;		\/* master resource record *\/$/;"	m	struct:res_desc::res_template	typeref:struct:res_desc::res_template::res_desc	access:public
res_desc::res_template::oplat	ss/resource.h	/^    int oplat;				\/* operation latency: cycles until$/;"	m	struct:res_desc::res_template	access:public
res_desc::x	ss/resource.h	/^  } x[MAX_RES_CLASSES];$/;"	m	struct:res_desc	typeref:struct:res_desc::res_template	access:public
res_dump	ss/resource.h	/^void res_dump(struct res_pool *pool, FILE *stream);$/;"	p	signature:(struct res_pool *pool, FILE *stream)
res_fpalu	ss/my_opt.c	/^int res_fpalu;$/;"	v
res_fpmult	ss/my_opt.c	/^int res_fpmult;$/;"	v
res_get	ss/resource.h	/^struct res_template *res_get(struct res_pool *pool, int class);$/;"	p	signature:(struct res_pool *pool, int class)
res_ialu	ss/my_opt.c	/^int res_ialu;$/;"	v
res_imult	ss/my_opt.c	/^int res_imult;$/;"	v
res_memport	ss/my_opt.c	/^int res_memport;$/;"	v
res_pool	ss/resource.h	/^struct res_pool {$/;"	s
res_pool::name	ss/resource.h	/^  char *name;				\/* pool name *\/$/;"	m	struct:res_pool	access:public
res_pool::nents	ss/resource.h	/^  int nents[MAX_RES_CLASSES];$/;"	m	struct:res_pool	access:public
res_pool::num_resources	ss/resource.h	/^  int num_resources;			\/* total number of res instances *\/$/;"	m	struct:res_pool	access:public
res_pool::resources	ss/resource.h	/^  struct res_desc *resources;		\/* resource instances *\/$/;"	m	struct:res_pool	typeref:struct:res_pool::res_desc	access:public
res_pool::table	ss/resource.h	/^  struct res_template *table[MAX_RES_CLASSES][MAX_INSTS_PER_CLASS];$/;"	m	struct:res_pool	typeref:struct:res_pool::res_template	access:public
res_template	ss/resource.h	/^  struct res_template {$/;"	s	struct:res_desc	access:public
reserved	ss/ecoff.h	/^  short reserved;$/;"	m	struct:ecoff_EXTR	access:public
reserved	ss/ecoff.h	/^  unsigned reserved :1;$/;"	m	struct:ecoff_SYMR	access:public
reserved	ss/ecoff.h	/^  unsigned reserved :24;$/;"	m	struct:ecoff_fdr	access:public
reset_nodes_flags	estimate.c	/^reset_nodes_flags(int first, int last)$/;"	f	file:	signature:(int first, int last)
resideLpId	symexec.h	/^	int resideLpId; \/*Loop where this data reference reside*\/$/;"	m	struct:__anon18	access:public
resources	ss/resource.h	/^  struct res_desc *resources;		\/* resource instances *\/$/;"	m	struct:res_pool	typeref:struct:res_pool::res_desc	access:public
result_type	ss/eval.c	/^result_type(enum eval_type_t t1,	\/* left operand type *\/$/;"	f	file:	signature:(enum eval_type_t t1, enum eval_type_t t2)
returnMemoryAloc	address.c	/^ric_p returnMemoryAloc(ric_s mem, abs_mem_p abs_mem_st)$/;"	f	signature:(ric_s mem, abs_mem_p abs_mem_st)
rfdBase	ss/ecoff.h	/^  int rfdBase;$/;"	m	struct:ecoff_fdr	access:public
rhs	infeasible.h	/^  int  rhs;                     \/\/ the rhs constant$/;"	m	struct:__anon9	access:public
rhs	infeasible.h	/^  int  rhs;                     \/\/ the rhs constant$/;"	m	struct:branch_t	access:public
rhs_var	infeasible.h	/^  char rhs_var;                 \/\/ 1 if rhs is a variable$/;"	m	struct:__anon9	access:public
rhs_var	infeasible.h	/^  char rhs_var;                 \/\/ 1 if rhs is a variable$/;"	m	struct:branch_t	access:public
ric	address.h	/^struct ric {$/;"	s
ric::lower_bound	address.h	/^	addr_t lower_bound;	  $/;"	m	struct:ric	access:public
ric::stride	address.h	/^	addr_t stride;$/;"	m	struct:ric	access:public
ric::upper_bound	address.h	/^	addr_t upper_bound;$/;"	m	struct:ric	access:public
ric_p	address.h	/^typedef struct ric* ric_p;$/;"	t	typeref:struct:ric
ric_s	address.h	/^typedef struct ric ric_s;$/;"	t	typeref:struct:ric
rob_depends	ss/ss_exegraph.c	/^static void rob_depends(int inst, int succ) {$/;"	f	file:	signature:(int inst, int succ)
root_bbb	bpred.c	/^bfg_node_t	    root_bbb, end_bbb;$/;"	v
root_bbb_id	bpred.c	/^int		    root_bbb_id, end_bbb_id;$/;"	v
root_bbb_out	bpred.c	/^btg_edge_t	**end_bbb_in, **root_bbb_out;$/;"	v
root_reach	bpred.c	/^root_reach(bfg_node_t *target)$/;"	f	file:	signature:(bfg_node_t *target)
root_reach_end	bpred.c	/^root_reach_end(int pi)$/;"	f	file:	signature:(int pi)
rss	ss/ecoff.h	/^  int rss;$/;"	m	struct:ecoff_fdr	access:public
rt_NPC	ss/machine.h	/^  rt_NPC,		\/* next program counter *\/$/;"	e	enum:md_reg_type
rt_NUM	ss/machine.h	/^  rt_NUM$/;"	e	enum:md_reg_type
rt_PC	ss/machine.h	/^  rt_PC,		\/* program counter *\/$/;"	e	enum:md_reg_type
rt_ctrl	ss/machine.h	/^  rt_ctrl,		\/* control register *\/$/;"	e	enum:md_reg_type
rt_dpr	ss/machine.h	/^  rt_dpr,		\/* double-precision floating pointer register *\/$/;"	e	enum:md_reg_type
rt_fpr	ss/machine.h	/^  rt_fpr,		\/* single-precision floating pointer register *\/$/;"	e	enum:md_reg_type
rt_gpr	ss/machine.h	/^  rt_gpr,		\/* general purpose register *\/$/;"	e	enum:md_reg_type
rt_lpr	ss/machine.h	/^  rt_lpr,		\/* integer-precision floating pointer register *\/$/;"	e	enum:md_reg_type
runBenchmark	scripts/runAllOpt.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runAll_Mul_Opt.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runBenchmarks.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runBenchmarksORG.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runEstp1.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runEstp2.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runSim.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runSimM.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runSimP.sh	/^runBenchmark()$/;"	f
runBenchmark	scripts/runSimS.sh	/^runBenchmark()$/;"	f
runEst	scripts/runAllOpt.sh	/^runEst()$/;"	f
runEst	scripts/runAll_Mul_Opt.sh	/^runEst()$/;"	f
runEst	scripts/runEst.sh	/^runEst()$/;"	f
runEst	scripts/runEstp1.sh	/^runEst()$/;"	f
runEst	scripts/runEstp2.sh	/^runEst()$/;"	f
runEst	scripts/runSim.sh	/^runEst()$/;"	f
runEst	scripts/runSimM.sh	/^runEst()$/;"	f
runEst	scripts/runSimP.sh	/^runEst()$/;"	f
runEst	scripts/runSimS.sh	/^runEst()$/;"	f
runSolver	scripts/runAllOpt.sh	/^runSolver()$/;"	f
runSolver	scripts/runAll_Mul_Opt.sh	/^runSolver()$/;"	f
runSolver	scripts/runEst.sh	/^runSolver()$/;"	f
runSolver	scripts/runEstp1.sh	/^runSolver()$/;"	f
runSolver	scripts/runEstp2.sh	/^runSolver()$/;"	f
runSolver	scripts/runSim.sh	/^runSolver()$/;"	f
runSolver	scripts/runSimM.sh	/^runSolver()$/;"	f
runSolver	scripts/runSimP.sh	/^runSolver()$/;"	f
runSolver	scripts/runSimS.sh	/^runSolver()$/;"	f
run_cfg	main.c	/^static void run_cfg(char *obj_file) {$/;"	f	file:	signature:(char *obj_file)
run_est	main.c	/^static void run_est(char *obj_file) {$/;"	f	file:	signature:(char *obj_file)
run_opt	ss/my_opt.c	/^char *run_opt; \/\/ EST (estimation) or CFG (generate CFG file)$/;"	v
run_prog	est.sh	/^run_prog()$/;"	f
run_prog	sim.sh	/^run_prog()$/;"	f
run_prog	solve.sh	/^run_prog()$/;"	f
run_prog	solve_time.sh	/^run_prog()$/;"	f
ruu_branch_penalty	ss/my_opt.c	/^int ruu_branch_penalty;$/;"	v
ruu_commit_width	ss/my_opt.c	/^int ruu_commit_width;$/;"	v
ruu_decode_width	ss/my_opt.c	/^int ruu_decode_width;$/;"	v
ruu_ifq_size	ss/my_opt.c	/^int ruu_ifq_size;$/;"	v
ruu_include_spec	ss/my_opt.c	/^int ruu_include_spec = TRUE;$/;"	v
ruu_inorder_issue	ss/my_opt.c	/^int ruu_inorder_issue;$/;"	v
ruu_issue_width	ss/my_opt.c	/^int ruu_issue_width;$/;"	v
s_flags	ss/ecoff.h	/^  int s_flags;$/;"	m	struct:ecoff_scnhdr	access:public
s_lb	cache.h	/^    int		s_lb;	\/\/ set + line bits$/;"	m	struct:__anon26	access:public
s_lnnoptr	ss/ecoff.h	/^  int s_lnnoptr;$/;"	m	struct:ecoff_scnhdr	access:public
s_msk	cache.h	/^    unsigned	s_msk;	\/\/ set mask$/;"	m	struct:__anon26	access:public
s_name	ss/ecoff.h	/^  char s_name[8];$/;"	m	struct:ecoff_scnhdr	access:public
s_nlnno	ss/ecoff.h	/^  unsigned short s_nlnno;$/;"	m	struct:ecoff_scnhdr	access:public
s_nreloc	ss/ecoff.h	/^  unsigned short s_nreloc;$/;"	m	struct:ecoff_scnhdr	access:public
s_paddr	ss/ecoff.h	/^  int s_paddr;$/;"	m	struct:ecoff_scnhdr	access:public
s_relptr	ss/ecoff.h	/^  int s_relptr;$/;"	m	struct:ecoff_scnhdr	access:public
s_scnptr	ss/ecoff.h	/^  int s_scnptr;$/;"	m	struct:ecoff_scnhdr	access:public
s_size	ss/ecoff.h	/^  int s_size;$/;"	m	struct:ecoff_scnhdr	access:public
s_vaddr	ss/ecoff.h	/^  int s_vaddr;$/;"	m	struct:ecoff_scnhdr	access:public
sa	cfg.h	/^    addr_t	sa;		\/\/ block start addr$/;"	m	struct:__anon3	access:public
sa	cfg.h	/^    addr_t	sa;		\/\/ proc start addr$/;"	m	struct:proc_t	access:public
saddr_p	scp_address.h	/^typedef struct scoped_address* saddr_p;$/;"	t	typeref:struct:scoped_address
saddr_s	scp_address.h	/^typedef struct scoped_address  saddr_s;$/;"	t	typeref:struct:scoped_address
saved2Mem	symexec.c	/^int saved2Mem(inf_node_t *node, biv_p biv) {$/;"	f	signature:(inf_node_t *node, biv_p biv)
sblk_p	scp_cache.h	/^typedef struct scope_block* sblk_p;$/;"	t	typeref:struct:scope_block
sblk_s	scp_cache.h	/^typedef struct scope_block sblk_s;$/;"	t	typeref:struct:scope_block
sbyte_t	ss/host.h	/^typedef signed char sbyte_t;$/;"	t
sc	ss/ecoff.h	/^  unsigned sc :5;$/;"	m	struct:ecoff_SYMR	access:public
sc_counter	ss/machine.h	570;"	d
sc_counter	ss/machine.h	574;"	d
scalar_delay	estimate.c	/^scalar_delay(egraph_node_t *v, int new_hi)$/;"	f	file:	signature:(egraph_node_t *v, int new_hi)
scan_blocks	cfg.c	/^scan_blocks(int *bb_ent, proc_t *proc)$/;"	f	file:	signature:(int *bb_ent, proc_t *proc)
scan_coexists	ss/ss_exegraph.c	/^static void scan_coexists() {$/;"	f	file:
scan_pred	ss/ss_exegraph.c	/^static void scan_pred() {$/;"	f	file:
scan_pred_mpred	ss/ss_exegraph.c	/^static void scan_pred_mpred(int curr) {$/;"	f	file:	signature:(int curr)
scan_pred_normal	ss/ss_exegraph.c	/^static void scan_pred_normal(int curr) {$/;"	f	file:	signature:(int curr)
scan_procs	cfg.c	/^scan_procs(int *proc_ent)$/;"	f	file:	signature:(int *proc_ent)
scope_block	scp_cache.h	/^struct scope_block {$/;"	s
scope_block::flag	scp_cache.h	/^	int flag;$/;"	m	struct:scope_block	access:public
scope_block::inst_block	scp_cache.h	/^	mem_blk_set_t* inst_block;\/* address of instruction memory block *\/$/;"	m	struct:scope_block	access:public
scope_block::inst_ys_set	scp_cache.h	/^	worklist_p inst_ys_set;\/* contains instruction memory blocks*\/$/;"	m	struct:scope_block	access:public
scope_block::m	scp_cache.h	/^	saddr_p m; \/*scope address of this scoped block*\/$/;"	m	struct:scope_block	access:public
scope_block::scp_age	scp_cache.h	/^	int scp_age; \/*scp_age = |yes_set| + |inst_ys_set| + 1*\/$/;"	m	struct:scope_block	access:public
scope_block::ys_set	scp_cache.h	/^	worklist_p ys_set; \/* contains temporal-scopes*\/$/;"	m	struct:scope_block	access:public
scoped_address	scp_address.h	/^struct scoped_address {$/;"	s
scoped_address::blkAddr	scp_address.h	/^    int                 blkAddr;    \/*Memory block*\/$/;"	m	struct:scoped_address	access:public
scoped_address::flag	scp_address.h	/^    int                     flag;   \/*0: cannot renew, 1: can renew*\/ $/;"	m	struct:scoped_address	access:public
scoped_address::instAddr	scp_address.h	/^    int                 instAddr;   \/*Inst addr*\/$/;"	m	struct:scoped_address	access:public
scoped_address::psLoop	scp_address.h	/^    worklist_p			psLoop;$/;"	m	struct:scoped_address	access:public
scoped_address::tsList	scp_address.h	/^    worklist_p          tsList;     \/*Defined temporal scope of this memscp*\/ $/;"	m	struct:scoped_address	access:public
scp_acs	scp_cache.h	47;"	d
scp_add2List	scp_cache.c	/^void scp_add2List(worklist_p* head, worklist_p* tail, void* data) {$/;"	f	signature:(worklist_p* head, worklist_p* tail, void* data)
scp_add2YS	scp_cache.c	/^void scp_add2YS(worklist_p* ys, saddr_p address) {$/;"	f	signature:(worklist_p* ys, saddr_p address)
scp_add2instYS	scp_cache.c	/^void scp_add2instYS(worklist_p* inst_ys, unsigned iblock) {$/;"	f	signature:(worklist_p* inst_ys, unsigned iblock)
scp_addrINacs	scp_cache.c	/^int scp_addrINacs(saddr_p maddr, scp_acs acs, loop_t*lp) {$/;"	f	signature:(saddr_p maddr, scp_acs acs, loop_t*lp)
scp_addrINacs	scp_cache.h	/^int scp_addrINacs(saddr_p maddr, scp_acs acs, loop_t*lp);$/;"	p	signature:(saddr_p maddr, scp_acs acs, loop_t*lp)
scp_addrINacs	scp_cache.h	/^int scp_addrINacs(saddr_p maddr, scp_acs acs,loop_t*lp);$/;"	p	signature:(saddr_p maddr, scp_acs acs,loop_t*lp)
scp_address_set_cardinality	scp_cache.c	/^int scp_address_set_cardinality(worklist_p addr_set) {$/;"	f	signature:(worklist_p addr_set)
scp_addrset_l1	scp_cache.c	/^worklist_p*** scp_addrset_l1;$/;"	v
scp_addrset_l2	scp_cache.c	/^worklist_p*** scp_addrset_l2;$/;"	v
scp_age	scp_cache.h	/^	int scp_age; \/*scp_age = |yes_set| + |inst_ys_set| + 1*\/$/;"	m	struct:scope_block	access:public
scp_analyze_loop_ps	scp_cache.c	/^void scp_analyze_loop_ps(loop_t* lp, int analysis) {$/;"	f	signature:(loop_t* lp, int analysis)
scp_aware_analyze_cache_hierarchy	main.c	/^static void scp_aware_analyze_cache_hierarchy(char* bin_fname) {$/;"	f	file:	signature:(char* bin_fname)
scp_cmpLpOrder	loops.c	/^int scp_cmpLpOrder(int lpID1, int lpID2) {$/;"	f	signature:(int lpID1, int lpID2)
scp_cmpLpOrder	loops.h	/^int scp_cmpLpOrder(int lpId1 , int lpId2);$/;"	p	signature:(int lpId1 , int lpId2)
scp_cmp_saddr	scp_cache.c	/^int scp_cmp_saddr(saddr_p dst, saddr_p src, loop_t* lp) {$/;"	f	signature:(saddr_p dst, saddr_p src, loop_t* lp)
scp_cmp_saddr	scp_cache.h	/^int scp_cmp_saddr(saddr_p dst, saddr_p src, loop_t* lp);$/;"	p	signature:(saddr_p dst, saddr_p src, loop_t* lp)
scp_compareACS	scp_cache.c	/^int scp_compareACS(scp_acs acs_a, scp_acs acs_b, loop_t*lp) {$/;"	f	signature:(scp_acs acs_a, scp_acs acs_b, loop_t*lp)
scp_compareACS	scp_cache.h	/^int scp_compareACS(scp_acs acs_a, scp_acs acs_b, loop_t*lp);$/;"	p	signature:(scp_acs acs_a, scp_acs acs_b, loop_t*lp)
scp_compare_sorted_ACSs	scp_cache.h	/^void scp_compare_sorted_ACSs(loop_t*lp);$/;"	p	signature:(loop_t*lp)
scp_const_func	ilp.c	/^void scp_const_func() {$/;"	f
scp_context_cons	ilp.c	/^void scp_context_cons() {$/;"	f
scp_cpyACS	scp_cache.c	/^void scp_cpyACS(scp_acs dst, scp_acs src) {$/;"	f	signature:(scp_acs dst, scp_acs src)
scp_cpySBlk	scp_cache.c	/^sblk_p scp_cpySBlk(sblk_p blk) {$/;"	f	signature:(sblk_p blk)
scp_createEmptyACS	scp_cache.c	/^scp_acs scp_createEmptyACS() {$/;"	f
scp_createSBlk	scp_cache.c	/^sblk_p scp_createSBlk(saddr_p addr) {$/;"	f	signature:(saddr_p addr)
scp_createSBlk_inst	scp_cache.c	/^sblk_p scp_createSBlk_inst(unsigned block) {$/;"	f	signature:(unsigned block)
scp_data_update	scp_cache.c	/^void scp_data_update(scp_acs acs, worklist_p addr_in, loop_t*lp) {$/;"	f	signature:(scp_acs acs, worklist_p addr_in, loop_t*lp)
scp_data_update	scp_cache.h	/^void scp_data_update(scp_acs acs, worklist_p addr_in, loop_t*lp);$/;"	p	signature:(scp_acs acs, worklist_p addr_in, loop_t*lp)
scp_datal2_update	scp_cache.c	/^void scp_datal2_update(scp_acs acs, worklist_p addr_in, loop_t*lp) {$/;"	f	signature:(scp_acs acs, worklist_p addr_in, loop_t*lp)
scp_dcache_cons	ilp.c	/^static void scp_dcache_cons() {$/;"	f	file:
scp_dcache_cost	ilp.c	/^static void scp_dcache_cost() {$/;"	f	file:
scp_dequeue	scp_cache.c	/^void* scp_dequeue(worklist_p* head, worklist_p* tail) {$/;"	f	signature:(worklist_p* head, worklist_p* tail)
scp_discardACS	scp_cache.c	/^void scp_discardACS(scp_acs acs) {$/;"	f	signature:(scp_acs acs)
scp_discardWorkList	scp_cache.c	/^void scp_discardWorkList(worklist_p* wl) {$/;"	f	signature:(worklist_p* wl)
scp_dump_address	scp_cache.c	/^void scp_dump_address() {$/;"	f
scp_dump_instruction	scp_cache.c	/^void scp_dump_instruction() {$/;"	f
scp_empty_queue	scp_cache.c	/^int scp_empty_queue(worklist_p head, worklist_p tail) {$/;"	f	signature:(worklist_p head, worklist_p tail)
scp_enqueue	scp_cache.c	/^void scp_enqueue(void* data, worklist_p* head, worklist_p* tail) {$/;"	f	signature:(void* data, worklist_p* head, worklist_p* tail)
scp_est_ts_size	scp_cache.c	/^int scp_est_ts_size(worklist_p tslist, loop_t* lpPS) {$/;"	f	signature:(worklist_p tslist, loop_t* lpPS)
scp_inner_ps_loop	scp_cache.c	/^loop_t* scp_inner_ps_loop(worklist_p addrset) {$/;"	f	signature:(worklist_p addrset)
scp_inner_ps_loop	scp_cache.h	/^loop_t* scp_inner_ps_loop(worklist_p addrset);$/;"	p	signature:(worklist_p addrset)
scp_instINacs	scp_cache.c	/^int scp_instINacs(mem_blk_set_t* iblock, scp_acs acs) {$/;"	f	signature:(mem_blk_set_t* iblock, scp_acs acs)
scp_instr_set_cardinality	scp_cache.c	/^int scp_instr_set_cardinality(worklist_p instr_set) {$/;"	f	signature:(worklist_p instr_set)
scp_join	scp_cache.c	/^void scp_join(worklist_p* acs_dst, worklist_p* acs_src, loop_t*lp) {$/;"	f	signature:(worklist_p* acs_dst, worklist_p* acs_src, loop_t*lp)
scp_join_search	scp_cache.c	/^sblk_p scp_join_search(saddr_p mblk, worklist_p cacheset, loop_t*lp) {$/;"	f	signature:(saddr_p mblk, worklist_p cacheset, loop_t*lp)
scp_join_search	scp_cache.h	/^sblk_p scp_join_search(saddr_p mblk, worklist_p cacheset, loop_t*lp);$/;"	p	signature:(saddr_p mblk, worklist_p cacheset, loop_t*lp)
scp_join_search_inst	scp_cache.c	/^sblk_p scp_join_search_inst(mem_blk_set_t* iblock, worklist_p cacheset) {$/;"	f	signature:(mem_blk_set_t* iblock, worklist_p cacheset)
scp_join_search_inst	scp_cache.h	/^sblk_p scp_join_search_inst(mem_blk_set_t* iblock, worklist_p cacheset);$/;"	p	signature:(mem_blk_set_t* iblock, worklist_p cacheset)
scp_length	scp_cache.c	/^int scp_length(worklist_p wk) {$/;"	f	signature:(worklist_p wk)
scp_loadstore_index	scp_cache.c	/^int scp_loadstore_index(mas_inst_t* inst) {$/;"	f	signature:(mas_inst_t* inst)
scp_mostOuterLoop	scp_cache.c	/^loop_t* scp_mostOuterLoop(worklist_p lparr) {$/;"	f	signature:(worklist_p lparr)
scp_mostOuterLoop	scp_cache.c	/^loop_t* scp_mostOuterLoop(worklist_p lparr);$/;"	p	file:	signature:(worklist_p lparr)
scp_overlap	scp_cache.c	/^int scp_overlap(saddr_p ma, saddr_p mb, loop_t*lp) {$/;"	f	signature:(saddr_p ma, saddr_p mb, loop_t*lp)
scp_pre_address_analysis	scp_cache.c	/^void scp_pre_address_analysis(char* fName, worklist_p**** input_addrset) {$/;"	f	signature:(char* fName, worklist_p**** input_addrset)
scp_print_ACS	scp_cache.c	/^void scp_print_ACS(scp_acs acs, loop_t*lp) {$/;"	f	signature:(scp_acs acs, loop_t*lp)
scp_print_ts	scp_cache.c	/^void scp_print_ts(worklist_p tslist) {$/;"	f	signature:(worklist_p tslist)
scp_psloop_dl	scp_cache.c	/^loop_t* scp_psloop_dl(mas_inst_t* inst, int level) {$/;"	f	signature:(mas_inst_t* inst, int level)
scp_recalculate_temporal_scope	scp_cache.c	/^void scp_recalculate_temporal_scope(int* unrolled_loop_map, int* old_loop_bound) {$/;"	f	signature:(int* unrolled_loop_map, int* old_loop_bound)
scp_store_address_set	scp_cache.c	/^void scp_store_address_set() {$/;"	f
scp_test_cache_miss	scp_cache.c	/^void scp_test_cache_miss() {$/;"	f
scp_test_cache_miss	scp_cache.h	/^void scp_test_cache_miss();$/;"	p	signature:()
scp_totally_discardACS	scp_cache.c	/^void scp_totally_discardACS(scp_acs* p_acs) {$/;"	f	signature:(scp_acs* p_acs)
scp_ts	scp_cache.c	/^ts_p scp_ts(worklist_p tslst, loop_t*lp) {$/;"	f	signature:(worklist_p tslst, loop_t*lp)
scp_unionYS	scp_cache.c	/^void scp_unionYS(sblk_p dst, sblk_p src) {$/;"	f	signature:(sblk_p dst, sblk_p src)
scp_union_instYS	scp_cache.c	/^void scp_union_instYS(sblk_p dst, sblk_p src) {$/;"	f	signature:(sblk_p dst, sblk_p src)
scp_unrolled_temporal_scope	scp_cache.c	/^worklist_p scp_unrolled_temporal_scope(worklist_p addrset, loop_t*innerLoop,$/;"	f	signature:(worklist_p addrset, loop_t*innerLoop, int* unrolled_loop_map, int* old_loop_bound)
scp_update_Sblk_age	scp_cache.c	/^void scp_update_Sblk_age(sblk_p sblk) {$/;"	f	signature:(sblk_p sblk)
scp_update_Sblk_age	scp_cache.h	/^void scp_update_Sblk_age(sblk_p sblk);$/;"	p	signature:(sblk_p sblk)
sdb_NUM	ss/symbol.h	/^  sdb_NUM$/;"	e	enum:sym_db_t
sdb_any	ss/symbol.h	/^  sdb_any,			\/* search all symbols *\/$/;"	e	enum:sym_db_t
sdb_data	ss/symbol.h	/^  sdb_data,			\/* search data symbols *\/$/;"	e	enum:sym_db_t
sdb_text	ss/symbol.h	/^  sdb_text,			\/* search text symbols *\/$/;"	e	enum:sym_db_t
searchBenchmark	scripts/runEst.sh	/^searchBenchmark()$/;"	f
search_common_ancestor	loops.c	/^static void search_common_ancestor(loop_t *x, loop_t *y) {$/;"	f	file:	signature:(loop_t *x, loop_t *y)
search_tag	cache.c	/^search_tag(int lp_id, unsigned short set, unsigned short tag)$/;"	f	file:	signature:(int lp_id, unsigned short set, unsigned short tag)
seg	ss/symbol.h	/^  enum sym_seg_t seg;		\/* symbol segment *\/$/;"	m	struct:sym_sym_t	typeref:enum:sym_sym_t::sym_seg_t	access:public
set	cache.h	/^    unsigned short  set;    \/\/ cache line$/;"	m	struct:__anon27	access:public
setAddrDebugFile	scp_address.c	/^void setAddrDebugFile(FILE *fp) {$/;"	f	signature:(FILE *fp)
setBAConflict	conflicts.c	/^int setBAConflict( assign_t *assg, branch_t *br, char dir, assign_t **nullifier_list, int num_nullifiers ) {$/;"	f	signature:( assign_t *assg, branch_t *br, char dir, assign_t **nullifier_list, int num_nullifiers )
setBBConflict	conflicts.c	/^int setBBConflict( branch_t *br1, branch_t *br2, char dir, assign_t **nullifier_list, int num_nullifiers ) {$/;"	f	signature:( branch_t *br1, branch_t *br2, char dir, assign_t **nullifier_list, int num_nullifiers )
setCount	infeasible.c	/^int setCount( tcfg_node_t *bbi, int count ) {$/;"	f	signature:( tcfg_node_t *bbi, int count )
setCountRec	infeasible.c	/^int setCountRec( tcfg_node_t *bbi, int count, int return_pid ) {$/;"	f	signature:( tcfg_node_t *bbi, int count, int return_pid )
setDebugFile	reg.c	/^void setDebugFile(char *fName) {$/;"	f	signature:(char *fName)
setExpr	reg.c	/^void setExpr(expr_p expr, reg_t r) {$/;"	f	signature:(expr_p expr, reg_t r)
setExpr	symexec.h	/^void setExpr(expr_p expr, reg_t r);$/;"	p	signature:(expr_p expr, reg_t r)
setInt	reg.c	/^void setInt(reg_t *reg, int k) {$/;"	f	signature:(reg_t *reg, int k)
setInt	symexec.h	/^void setInt(reg_t *reg, int k);$/;"	p	signature:(reg_t *reg, int k)
setLoopID	infeasible.c	/^int setLoopID( tcfg_node_t *bbi, int lpid ) {$/;"	f	signature:( tcfg_node_t *bbi, int lpid )
setLoopIDRec	infeasible.c	/^int setLoopIDRec( tcfg_node_t *bbi, int lpid, int return_pid ) {$/;"	f	signature:( tcfg_node_t *bbi, int lpid, int return_pid )
setNewPara	reg.c	/^void setNewPara(char *para) {$/;"	f	signature:(char *para)
setNewPara	symexec.h	/^void setNewPara(char *para);$/;"	p	signature:(char *para)
setNewPara	symexec_value.c	/^void setNewPara(void *para) {$/;"	f	signature:(void *para)
set_body_data_cache_hitmiss	pipeline.c	/^static void set_body_data_cache_hitmiss(int edge_id, int contextMask) {$/;"	f	file:	signature:(int edge_id, int contextMask)
set_body_hitmiss	pipeline.c	/^static void set_body_hitmiss(int edge_id, int hm_id, int contextMask) {$/;"	f	file:	signature:(int edge_id, int hm_id, int contextMask)
set_cache	cache.c	/^set_cache()$/;"	f
set_cache_basic	cache.c	/^set_cache_basic(int nsets, int assoc, int bsize, int miss_penalty)$/;"	f	signature:(int nsets, int assoc, int bsize, int miss_penalty)
set_cache_basic	cache.h	/^set_cache_basic(int nsets, int assoc, int bsize, int miss_penalty);$/;"	p	signature:(int nsets, int assoc, int bsize, int miss_penalty)
set_cache_l2	cache.c	/^set_cache_l2()$/;"	f
set_epilog_data_cache_hitmiss	pipeline.c	/^static void set_epilog_data_cache_hitmiss(int edge_id, mas_inst_t* code,$/;"	f	file:	signature:(int edge_id, mas_inst_t* code, int num_inst, int contextMask)
set_l2_cache_basic	cache.c	/^set_l2_cache_basic(int nsets_l2, int assoc_l2, int bsize_l2, int miss_penalty)$/;"	f	signature:(int nsets_l2, int assoc_l2, int bsize_l2, int miss_penalty)
set_loop_flags	loops.c	/^void set_loop_flags(int flag) {$/;"	f	signature:(int flag)
set_mlat_bbi	pipeline.c	/^static void set_mlat_bbi() {$/;"	f	file:
set_mpunit_cons	ilp.c	/^static void set_mpunit_cons(int bbi_id, int hm, int lp_id) {$/;"	f	file:	signature:(int bbi_id, int hm, int lp_id)
set_prolog_data_cache_hitmiss	pipeline.c	/^static void set_prolog_data_cache_hitmiss(int edge_id, mas_inst_t* code,$/;"	f	file:	signature:(int edge_id, mas_inst_t* code, int num_inst, int contextMask)
set_topological_tcfg	tcfg.c	/^void set_topological_tcfg() {$/;"	f
set_topological_tcfg_loops	tcfg.c	/^void set_topological_tcfg_loops() {$/;"	f
setjmp	ss/host.h	136;"	d
sfloat_t	ss/host.h	/^typedef float sfloat_t;			\/* single-precision float - 32 bits *\/$/;"	t
shalf_t	ss/host.h	/^typedef signed short shalf_t;$/;"	t
sim_check_options	ss/my_opt.c	/^void sim_check_options(struct opt_odb_t *odb, \/* options database *\/$/;"	f	signature:(struct opt_odb_t *odb, int argc, char **argv)
sim_odb	ss/my_opt.c	/^struct opt_odb_t *sim_odb;$/;"	v	typeref:struct:opt_odb_t
sim_reg_options	ss/my_opt.c	/^void sim_reg_options(struct opt_odb_t *odb) {$/;"	f	signature:(struct opt_odb_t *odb)
size	cfg.h	/^    int		size;		\/\/ size (in bytes)$/;"	m	struct:__anon3	access:public
size	cfg.h	/^    int		size;		\/\/ size (in bytes)$/;"	m	struct:proc_t	access:public
size	cfg.h	/^    int size;$/;"	m	struct:__anon4	access:public
size	isa.h	/^    int	    size;$/;"	m	struct:__anon16	access:public
size	scp_address.h	/^    int  size;$/;"	m	struct:size_cons	access:public
size	ss/symbol.h	/^  int size;			\/* bytes to next symbol *\/$/;"	m	struct:sym_sym_t	access:public
size_cons	scp_address.h	/^struct size_cons {$/;"	s
size_cons::name	scp_address.h	/^    char name[256];$/;"	m	struct:size_cons	access:public
size_cons::next	scp_address.h	/^    struct size_cons *next;$/;"	m	struct:size_cons	typeref:struct:size_cons::size_cons	access:public
size_cons::size	scp_address.h	/^    int  size;$/;"	m	struct:size_cons	access:public
size_cons_p	scp_address.h	/^typedef struct size_cons* size_cons_p;$/;"	t	typeref:struct:size_cons
size_cons_s	scp_address.h	/^typedef struct size_cons size_cons_s;$/;"	t	typeref:struct:size_cons
slargeint_t	ss/misc.c	/^typedef sqword_t slargeint_t;$/;"	t	file:
slargeint_t	ss/misc.c	/^typedef sword_t slargeint_t;$/;"	t	file:
slist	address.h	/^struct slist$/;"	s
slist::dst	address.h	/^	void* dst;$/;"	m	struct:slist	access:public
slist::next	address.h	/^	struct slist* next;$/;"	m	struct:slist	typeref:struct:slist::slist	access:public
slist_p	address.h	/^typedef struct slist* slist_p;$/;"	t	typeref:struct:slist
slist_s	address.h	/^typedef struct slist slist_s;$/;"	t	typeref:struct:slist
sqword_t	ss/host.h	/^typedef signed __int64 sqword_t;$/;"	t
sqword_t	ss/host.h	/^typedef signed long long sqword_t;$/;"	t
sqword_t	ss/host.h	/^typedef signed long sqword_t;$/;"	t
src	bpred.h	/^    bfg_node_t	*src, *dst;	\/\/ block s -> t$/;"	m	struct:bfg_edge_t	access:public
src	bpred.h	/^    bfg_node_t	*src, *dst;$/;"	m	struct:btg_edge_t	access:public
src	cfg.h	/^    cfg_node_t  *src, *dst;	\/\/ src -> dst$/;"	m	struct:cfg_edge_t	access:public
src	exegraph.h	/^    egraph_node_t   *src, *dst;$/;"	m	struct:egraph_edge_t	access:public
src	tcfg.h	/^	tcfg_node_t *src, *dst;$/;"	m	struct:tcfg_edge_t	access:public
ss_NUM	ss/symbol.h	/^  ss_NUM$/;"	e	enum:sym_seg_t
ss_alloc_mem	ss/ss_exegraph.c	/^static void ss_alloc_mem() {$/;"	f	file:
ss_data	ss/symbol.h	/^  ss_data,			\/* data segment symbol *\/$/;"	e	enum:sym_seg_t
ss_inst_fu	ss/ss_isa.c	/^ss_inst_fu(de_inst_t *inst)$/;"	f	signature:(de_inst_t *inst)
ss_max_inst_lat	ss/ss_isa.c	/^ss_max_inst_lat(de_inst_t *inst)$/;"	f	signature:(de_inst_t *inst)
ss_pfu_class	ss/ss_machine.h	/^enum ss_pfu_class {$/;"	g
ss_text	ss/symbol.h	/^  ss_text,			\/* text segment symbol *\/$/;"	e	enum:sym_seg_t
st	ss/ecoff.h	/^  unsigned st :6;$/;"	m	struct:ecoff_SYMR	access:public
stack_empty	common.c	/^stack_empty(Stack *stack)$/;"	f	signature:(Stack *stack)
stack_pop	common.c	/^stack_pop(Stack *stack)$/;"	f	signature:(Stack *stack)
stack_push	common.c	/^stack_push(Stack *stack, void *x)$/;"	f	signature:(Stack *stack, void *x)
stack_t	common.h	/^typedef struct stack_t {$/;"	s
stack_t::base	common.h	/^    void    *base;$/;"	m	struct:stack_t	access:public
stack_t::capt	common.h	/^    int	    capt;	\/* capacity *\/$/;"	m	struct:stack_t	access:public
stack_t::esize	common.h	/^    int	    esize;	\/* element size *\/$/;"	m	struct:stack_t	access:public
stack_t::top	common.h	/^    void    *top;$/;"	m	struct:stack_t	access:public
stage	exegraph.h	/^    short	    inst, stage;   $/;"	m	struct:__anon32	access:public
stage_order_depends	ss/ss_exegraph.c	/^static void stage_order_depends() {$/;"	f	file:
start_addr	cfg.h	/^    addr_t	    start_addr, end_addr, main_addr;$/;"	m	struct:__anon5	access:public
start_body	pipeline.c	/^mas_inst_t **bodies, *start_body;$/;"	v
start_str	ilp.c	/^char start_str[] = "Sta", end_str[] = "End";$/;"	v
start_time	pipeline.c	/^int **cpred_times, **mpred_times, start_time;$/;"	v
stat_reg_addr	ss/machine.h	579;"	d
stat_reg_counter	ss/machine.h	569;"	d
stat_reg_counter	ss/machine.h	573;"	d
step	estimate.c	/^int		step = STEP_SEP;$/;"	v
stestit	ss/misc.c	/^stestit(char *s)$/;"	f	signature:(char *s)
storeMem	symexec.c	/^int     storeMem(worklist_p *memList, addr_t instAddr, $/;"	p	file:	signature:(worklist_p *memList, addr_t instAddr, reg_t writeAddr, reg_t regValue)
storeMem	symexec.c	/^int storeMem (worklist_p *memList, addr_t instAddr,$/;"	f	signature:(worklist_p *memList, addr_t instAddr, reg_t writeAddr, reg_t regValue)
str	exegraph.h	/^    range_t	    rdy, str, fin;	\/\/ ready, start, finish$/;"	m	struct:__anon32	access:public
str	ilp.c	/^char str[32], term[32];$/;"	v
str	ss/machine.h	/^  char *str;			\/* register name *\/$/;"	m	struct:md_reg_names_t	access:public
streq	infeasible.h	39;"	d
stride	address.h	/^	addr_t stride;$/;"	m	struct:ric	access:public
stride	symexec.h	/^	int stride;$/;"	m	struct:BIV	access:public
strtoul	ss/eval.c	62;"	d	file:
strtoul	ss/misc.h	224;"	d
succ	exegraph.h	/^    short   succ;$/;"	m	struct:__anon33	access:public
succ_commit_depends	ss/ss_exegraph.c	/^static void succ_commit_depends(int inst) {$/;"	f	file:	signature:(int inst)
succ_decode_depends	ss/ss_exegraph.c	/^static void succ_decode_depends(int inst) {$/;"	f	file:	signature:(int inst)
succ_fetch_depends	ss/ss_exegraph.c	/^static void succ_fetch_depends(int inst) {$/;"	f	file:	signature:(int inst)
succ_issue_depends	ss/ss_exegraph.c	/^static void succ_issue_depends(int inst) {$/;"	f	file:	signature:(int inst)
sword_t	ss/host.h	/^typedef signed int sword_t;$/;"	t
sym_bind_addr	ss/symbol.c	/^sym_bind_addr(md_addr_t addr,		\/* address of symbol to locate *\/$/;"	f	signature:(md_addr_t addr, int *pindex, int exact, enum sym_db_t db)
sym_bind_addr	ss/symbol.h	/^sym_bind_addr(md_addr_t addr,		\/* address of symbol to locate *\/$/;"	p	signature:(md_addr_t addr, int *pindex, int exact, enum sym_db_t db)
sym_bind_name	ss/symbol.c	/^sym_bind_name(char *name,			\/* symbol name to locate *\/$/;"	f	signature:(char *name, int *pindex, enum sym_db_t db)
sym_bind_name	ss/symbol.h	/^sym_bind_name(char *name,			\/* symbol name to locate *\/$/;"	p	signature:(char *name, int *pindex, enum sym_db_t db)
sym_datasyms	ss/symbol.c	/^struct sym_sym_t **sym_datasyms = NULL;$/;"	v	typeref:struct:sym_sym_t
sym_datasyms_by_name	ss/symbol.c	/^struct sym_sym_t **sym_datasyms_by_name = NULL;$/;"	v	typeref:struct:sym_sym_t
sym_db	ss/symbol.c	/^struct sym_sym_t *sym_db = NULL;$/;"	v	typeref:struct:sym_sym_t
sym_db_t	ss/symbol.h	/^enum sym_db_t {$/;"	g
sym_dumpstate	ss/symbol.c	/^sym_dumpstate(FILE *fd)			\/* output stream *\/$/;"	f	signature:(FILE *fd)
sym_dumpstate	ss/symbol.h	/^sym_dumpstate(FILE *fd);		\/* output stream *\/$/;"	p	signature:(FILE *fd)
sym_dumpsym	ss/symbol.c	/^sym_dumpsym(struct sym_sym_t *sym,	\/* symbol to display *\/$/;"	f	signature:(struct sym_sym_t *sym, FILE *fd)
sym_dumpsym	ss/symbol.h	/^sym_dumpsym(struct sym_sym_t *sym,	\/* symbol to display *\/$/;"	p	signature:(struct sym_sym_t *sym, FILE *fd)
sym_dumpsyms	ss/symbol.c	/^sym_dumpsyms(FILE *fd)			\/* output stream *\/$/;"	f	signature:(FILE *fd)
sym_dumpsyms	ss/symbol.h	/^sym_dumpsyms(FILE *fd);			\/* output stream *\/$/;"	p	signature:(FILE *fd)
sym_dumptextsyms	ss/symbol.c	/^sym_dumptextsyms(FILE *fd)			\/* output stream *\/$/;"	f	signature:(FILE *fd)
sym_loadsyms	ss/symbol.c	/^sym_loadsyms(char *fname,	\/* file name containing symbols *\/$/;"	f	signature:(char *fname, int load_locals)
sym_loadsyms	ss/symbol.h	/^sym_loadsyms(char *fname,		\/* file name containing symbols *\/$/;"	p	signature:(char *fname, int load_locals)
sym_map	ss/eval.c	/^static struct sym_map_t sym_map[] = {$/;"	v	typeref:struct:sym_map_t	file:
sym_map_t	ss/eval.c	/^struct sym_map_t {$/;"	s	file:
sym_map_t::symbol	ss/eval.c	/^  char *symbol;$/;"	m	struct:sym_map_t	file:	access:public
sym_map_t::value	ss/eval.c	/^  struct eval_value_t *value;$/;"	m	struct:sym_map_t	typeref:struct:sym_map_t::eval_value_t	file:	access:public
sym_memory_model	symexec.h	/^struct sym_memory_model {$/;"	s
sym_memory_model::instAddr	symexec.h	/^	long instAddr; \/*inst assigns value for this entry*\/$/;"	m	struct:sym_memory_model	access:public
sym_memory_model::regValue	symexec.h	/^	reg_t regValue; \/*reg. value saved in this entry*\/$/;"	m	struct:sym_memory_model	access:public
sym_memory_model::writeAddr	symexec.h	/^	reg_t writeAddr; \/*addr value of this entry*\/$/;"	m	struct:sym_memory_model	access:public
sym_ndatasyms	ss/symbol.c	/^int sym_ndatasyms = 0;$/;"	v
sym_nsyms	ss/symbol.c	/^int sym_nsyms = 0;$/;"	v
sym_ntextsyms	ss/symbol.c	/^int sym_ntextsyms = 0;$/;"	v
sym_seg_t	ss/symbol.h	/^enum sym_seg_t {$/;"	g
sym_sym_t	ss/symbol.h	/^struct sym_sym_t {$/;"	s
sym_sym_t::addr	ss/symbol.h	/^  md_addr_t addr;		\/* symbol address value *\/$/;"	m	struct:sym_sym_t	access:public
sym_sym_t::initialized	ss/symbol.h	/^  int initialized;		\/* initialized? (if data segment) *\/$/;"	m	struct:sym_sym_t	access:public
sym_sym_t::local	ss/symbol.h	/^  int local;			\/* compiler local symbol? *\/$/;"	m	struct:sym_sym_t	access:public
sym_sym_t::name	ss/symbol.h	/^  char *name;			\/* symbol name *\/$/;"	m	struct:sym_sym_t	access:public
sym_sym_t::pub	ss/symbol.h	/^  int pub;			\/* externally visible? *\/$/;"	m	struct:sym_sym_t	access:public
sym_sym_t::seg	ss/symbol.h	/^  enum sym_seg_t seg;		\/* symbol segment *\/$/;"	m	struct:sym_sym_t	typeref:enum:sym_sym_t::sym_seg_t	access:public
sym_sym_t::size	ss/symbol.h	/^  int size;			\/* bytes to next symbol *\/$/;"	m	struct:sym_sym_t	access:public
sym_syms	ss/symbol.c	/^struct sym_sym_t **sym_syms = NULL;$/;"	v	typeref:struct:sym_sym_t
sym_syms_by_name	ss/symbol.c	/^struct sym_sym_t **sym_syms_by_name = NULL;$/;"	v	typeref:struct:sym_sym_t
sym_textsyms	ss/symbol.c	/^struct sym_sym_t **sym_textsyms = NULL;$/;"	v	typeref:struct:sym_sym_t
sym_textsyms_by_name	ss/symbol.c	/^struct sym_sym_t **sym_textsyms_by_name = NULL;$/;"	v	typeref:struct:sym_sym_t
symbol	ss/eval.c	/^  char *symbol;$/;"	m	struct:sym_map_t	file:	access:public
symbol_i	cfg.h	/^} symbol_i;$/;"	t	typeref:struct:__anon4
syms_loaded	ss/symbol.c	/^static int syms_loaded = FALSE;$/;"	v	file:
t	symexec.h	/^	char t; \/\/ value type: expression, const, induction, parameter$/;"	m	struct:__anon17	access:public
t_msk	cache.h	/^    unsigned	t_msk;	\/\/ tag mask$/;"	m	struct:__anon26	access:public
t_s_msk	cache.h	/^    unsigned	t_s_msk;\/\/ set+tag mask$/;"	m	struct:__anon26	access:public
t_sb	cache.h	/^    int		t_sb;	\/\/ tag + set bits$/;"	m	struct:__anon26	access:public
table	ss/resource.h	/^  struct res_template *table[MAX_RES_CLASSES][MAX_INSTS_PER_CLASS];$/;"	m	struct:res_pool	typeref:struct:res_pool::res_template	access:public
tag	cache.c	/^		  unsigned short  tag;$/;"	m	struct:tag_link_t	file:	access:public
tag	cache.h	/^    unsigned short  tag;    \/\/ memory block tag$/;"	m	struct:__anon28	access:public
tag	cache.h	/^    unsigned short  tag;    \/\/ valid tag$/;"	m	struct:__anon27	access:public
tag_link_t	cache.c	/^struct tag_link_t {$/;"	s	file:
tag_link_t	cache.c	/^typedef struct tag_link_t   tag_link_t;$/;"	t	typeref:struct:tag_link_t	file:
tag_link_t::next	cache.c	/^		  tag_link_t	    *next;$/;"	m	struct:tag_link_t	file:	access:public
tag_link_t::tag	cache.c	/^		  unsigned short  tag;$/;"	m	struct:tag_link_t	file:	access:public
tail	common.h	/^    void    *head, *tail;   \/* head points to oldest element *\/$/;"	m	struct:queue_t	access:public
tail	loops.h	/^    tcfg_node_t	    *tail;$/;"	m	struct:loop_t	access:public
target	isa.h	/^    addr_t  target;				\/* target addr for control transfer inst *\/$/;"	m	struct:__anon16	access:public
tcfg	tcfg.c	/^tcfg_node_t **tcfg;$/;"	v
tcfg_bfg_cons	ilp.c	/^static void tcfg_bfg_cons() {$/;"	f	file:
tcfg_cons	ilp.c	/^static void tcfg_cons() {$/;"	f	file:
tcfg_dinst_str	ilp.c	/^static void tcfg_dinst_str(int d_inst_id, tcfg_node_t *bbi) {$/;"	f	file:	signature:(int d_inst_id, tcfg_node_t *bbi)
tcfg_edge_ctx_term	ilp.c	/^static void tcfg_edge_ctx_term(FILE *fp, tcfg_edge_t *e, int context,$/;"	f	file:	signature:(FILE *fp, tcfg_edge_t *e, int context, int upperBound, int bpred, char *prefix, char *suffix)
tcfg_edge_ctx_term	ilp.c	/^static void tcfg_edge_ctx_term(FILE *fp, tcfg_edge_t *e, int context,$/;"	p	file:	signature:(FILE *fp, tcfg_edge_t *e, int context, int upperBound, int bpred, char *prefix, char *suffix)
tcfg_edge_mp_gen	cache.c	/^tcfg_edge_mp_gen(tcfg_edge_t *e)$/;"	f	file:	signature:(tcfg_edge_t *e)
tcfg_edge_str	ilp.c	/^static void tcfg_edge_str(tcfg_edge_t *e, int bpred) {$/;"	f	file:	signature:(tcfg_edge_t *e, int bpred)
tcfg_edge_t	tcfg.h	/^struct tcfg_edge_t {$/;"	s
tcfg_edge_t	tcfg.h	/^typedef struct tcfg_edge_t tcfg_edge_t;$/;"	t	typeref:struct:tcfg_edge_t
tcfg_edge_t::branch	tcfg.h	/^	int branch; \/\/ TAKEN or NOT_TAKEN$/;"	m	struct:tcfg_edge_t	access:public
tcfg_edge_t::dst	tcfg.h	/^	tcfg_node_t *src, *dst;$/;"	m	struct:tcfg_edge_t	access:public
tcfg_edge_t::flags	tcfg.h	/^	int flags;$/;"	m	struct:tcfg_edge_t	access:public
tcfg_edge_t::id	tcfg.h	/^	int id;$/;"	m	struct:tcfg_edge_t	access:public
tcfg_edge_t::next_in	tcfg.h	/^	tcfg_edge_t *next_in; \/\/ next incoming edge of dst$/;"	m	struct:tcfg_edge_t	access:public
tcfg_edge_t::next_out	tcfg.h	/^	tcfg_edge_t *next_out; \/\/ next outgoing edge of src$/;"	m	struct:tcfg_edge_t	access:public
tcfg_edge_t::src	tcfg.h	/^	tcfg_node_t *src, *dst;$/;"	m	struct:tcfg_edge_t	access:public
tcfg_edge_term	ilp.c	/^static void tcfg_edge_term(FILE *fp, tcfg_edge_t *e, int bpred, char *prefix,$/;"	f	file:	signature:(FILE *fp, tcfg_edge_t *e, int bpred, char *prefix, char *suffix)
tcfg_edges	tcfg.c	/^tcfg_edge_t **tcfg_edges;$/;"	v
tcfg_elink_t	tcfg.h	/^struct tcfg_elink_t {$/;"	s
tcfg_elink_t	tcfg.h	/^typedef struct tcfg_elink_t tcfg_elink_t;$/;"	t	typeref:struct:tcfg_elink_t
tcfg_elink_t::edge	tcfg.h	/^	tcfg_edge_t *edge;$/;"	m	struct:tcfg_elink_t	access:public
tcfg_elink_t::next	tcfg.h	/^	tcfg_elink_t *next;$/;"	m	struct:tcfg_elink_t	access:public
tcfg_estunit_cons	ilp.c	/^static void tcfg_estunit_cons() {$/;"	f	file:
tcfg_estunit_cons_ps	ilp.c	/^static void tcfg_estunit_cons_ps() {$/;"	f	file:
tcfg_is_loop_head	loops.h	/^int tcfg_is_loop_head(tcfg_node_t* bbi);$/;"	p	signature:(tcfg_node_t* bbi)
tcfg_nlink_t	tcfg.h	/^struct tcfg_nlink_t {$/;"	s
tcfg_nlink_t	tcfg.h	/^typedef struct tcfg_nlink_t tcfg_nlink_t;$/;"	t	typeref:struct:tcfg_nlink_t
tcfg_nlink_t::bbi	tcfg.h	/^	tcfg_node_t *bbi;$/;"	m	struct:tcfg_nlink_t	access:public
tcfg_nlink_t::next	tcfg.h	/^	tcfg_nlink_t *next;$/;"	m	struct:tcfg_nlink_t	access:public
tcfg_node_cons	ilp.c	/^static void tcfg_node_cons(tcfg_node_t *bbi) {$/;"	f	file:	signature:(tcfg_node_t *bbi)
tcfg_node_ctx_term	ilp.c	/^static void tcfg_node_ctx_term(FILE* fp, tcfg_node_t* bbi, int context,$/;"	f	file:	signature:(FILE* fp, tcfg_node_t* bbi, int context, int upperBound, int bpred, char* prefix, char* suffix)
tcfg_node_gen	cache.c	/^tcfg_node_gen(tcfg_node_t *bbi)$/;"	f	file:	signature:(tcfg_node_t *bbi)
tcfg_node_hm_term	ilp.c	/^static void tcfg_node_hm_term(FILE *fp, tcfg_node_t *bbi, int hm, char *prefix,$/;"	f	file:	signature:(FILE *fp, tcfg_node_t *bbi, int hm, char *prefix, char *suffix)
tcfg_node_str	ilp.c	/^static void tcfg_node_str(tcfg_node_t *bbi) {$/;"	f	file:	signature:(tcfg_node_t *bbi)
tcfg_node_t	tcfg.h	/^} tcfg_node_t;$/;"	t	typeref:struct:__anon38
tcfg_node_term	ilp.c	/^static void tcfg_node_term(FILE *fp, tcfg_node_t *bbi, char *prefix,$/;"	f	file:	signature:(FILE *fp, tcfg_node_t *bbi, char *prefix, char *suffix)
tcfg_size	tcfg.c	/^int num_tcfg_nodes = 0, tcfg_size = 0;$/;"	v
temporal_scope	scp_address.h	/^struct temporal_scope {$/;"	s
temporal_scope::flag	scp_address.h	/^    int flag;$/;"	m	struct:temporal_scope	access:public
temporal_scope::loop_id	scp_address.h	/^    int loop_id;$/;"	m	struct:temporal_scope	access:public
temporal_scope::lw	scp_address.h	/^    int lw;$/;"	m	struct:temporal_scope	access:public
temporal_scope::up	scp_address.h	/^    int up;$/;"	m	struct:temporal_scope	access:public
term	ilp.c	/^char str[32], term[32];$/;"	v
term	ss/eval.c	/^term(struct eval_state_t *es)		\/* expression evaluator *\/$/;"	f	file:	signature:(struct eval_state_t *es)
testConflict	conflicts.c	/^char testConflict( int a, int rhs_a, int b, int rhs_b ) {$/;"	f	signature:( int a, int rhs_a, int b, int rhs_b )
testReachableNoCancel	conflicts.c	/^int testReachableNoCancel( char *res, assign_t ***nullifier_list, int *num_nullifiers,$/;"	f	signature:( char *res, assign_t ***nullifier_list, int *num_nullifiers, int pid, int srcid, int destid, char *deritree, assign_t *assg, cfg_node_t *bblist, int num_bb )
test_depth	main.c	/^int test_depth(int pid, int depth) {$/;"	f	signature:(int pid, int depth)
test_depth	tcfg.c	/^int test_depth(int pid, int depth);$/;"	p	file:	signature:(int pid, int depth)
testit	ss/misc.c	/^testit(char *s)$/;"	f	signature:(char *s)
text_entry	ss/ss_readfile.c	/^unsigned	text_entry;$/;"	v
text_offset	ss/ss_readfile.c	/^unsigned	text_offset;$/;"	v
text_start	ss/ecoff.h	/^  int text_start;$/;"	m	struct:ecoff_aouthdr	access:public
tick_t	ss/host.h	/^typedef dfloat_t tick_t;$/;"	t
tick_t	ss/host.h	/^typedef sqword_t tick_t;		\/* NOTE: unsigned breaks caches *\/$/;"	t
ticks	common.h	/^typedef unsigned long long ticks;$/;"	t
ticks	test.c	/^typedef unsigned long long ticks;$/;"	t	file:
tlb_miss_lat	ss/my_opt.c	/^int tlb_miss_lat;$/;"	v
tmp_cs	pipeline.c	/^mblk_tag_t *tmp_cs;$/;"	v
tmp_cs_l2	pipeline.c	/^mblk_tag_t *tmp_cs_l2;$/;"	v
tok_buf	ss/eval.h	/^  char tok_buf[512];		\/* text of last token returned *\/$/;"	m	struct:eval_state_t	access:public
tok_const	ss/eval.h	/^  tok_const,		\/* numeric literals *\/$/;"	e	enum:eval_token_t
tok_cparen	ss/eval.h	/^  tok_cparen,		\/* `)' *\/$/;"	e	enum:eval_token_t
tok_div	ss/eval.h	/^  tok_div,		\/* `\/' *\/$/;"	e	enum:eval_token_t
tok_eof	ss/eval.h	/^  tok_eof,		\/* end of file *\/$/;"	e	enum:eval_token_t
tok_ident	ss/eval.h	/^  tok_ident,		\/* user-valued identifiers *\/$/;"	e	enum:eval_token_t
tok_invalid	ss/eval.h	/^  tok_invalid		\/* unrecognized token *\/$/;"	e	enum:eval_token_t
tok_map	ss/eval.c	/^static enum eval_token_t tok_map[256];$/;"	v	typeref:enum:eval_token_t	file:
tok_map_initialized	ss/eval.c	/^static int tok_map_initialized = FALSE;$/;"	v	file:
tok_minus	ss/eval.h	/^  tok_minus,		\/* `-' *\/$/;"	e	enum:eval_token_t
tok_mult	ss/eval.h	/^  tok_mult,		\/* `*' *\/$/;"	e	enum:eval_token_t
tok_oparen	ss/eval.h	/^  tok_oparen,		\/* `(' *\/$/;"	e	enum:eval_token_t
tok_plus	ss/eval.h	/^  tok_plus,		\/* `+' *\/$/;"	e	enum:eval_token_t
tok_whitespace	ss/eval.h	/^  tok_whitespace,	\/* ` ', `\\t', `\\n' *\/$/;"	e	enum:eval_token_t
top	common.h	/^    void    *top;$/;"	m	struct:stack_t	access:public
topo_call	infeasible.c	/^int topo_call( int **callees, int *num_callee ) {$/;"	f	signature:( int **callees, int *num_callee )
topo_tcfg	tcfg.h	/^int* topo_tcfg;$/;"	v
topo_tcfg_loops	tcfg.h	/^int* topo_tcfg_loops;$/;"	v
totalBlk	scp_address.c	/^int totalBlk;$/;"	v
totalBlk	scp_tscope.c	/^int totalBlk;$/;"	v
totalDataExec	scp_cache.c	/^int totalDataExec, totalPersMiss, totalNPersMiss;$/;"	v
totalNPersMiss	scp_cache.c	/^int totalDataExec, totalPersMiss, totalNPersMiss;$/;"	v
totalPersMiss	scp_cache.c	/^int totalDataExec, totalPersMiss, totalNPersMiss;$/;"	v
total_cons	ilp.c	/^int total_cons = 0, total_vars = 0;$/;"	v
total_vars	ilp.c	/^int total_cons = 0, total_vars = 0;$/;"	v
traceInductionFlag	symexec.c	/^int     traceInductionFlag; \/*Global: if trace induction value during sym.exec*\/$/;"	v
traceMemFlag	symexec.c	/^int     traceMemFlag;   \/*Global: if perform memory modeling during sym.exec*\/ $/;"	v
transformAloc	address.c	/^static void transformAloc(tcfg_node_t* bbi, int* change)$/;"	f	file:	signature:(tcfg_node_t* bbi, int* change)
transformInstCacheState	unicache.c	/^static void transformInstCacheState(tcfg_node_t* bbi, int* change_flag,$/;"	f	file:	signature:(tcfg_node_t* bbi, int* change_flag, ANALYSIS_T type, int iteration_count)
transforml2InstCacheState	unicache.c	/^static void transforml2InstCacheState(tcfg_node_t* bbi, int* change_flag,$/;"	f	file:	signature:(tcfg_node_t* bbi, int* change_flag, ANALYSIS_T type, int iteration_count)
trav_backward	pipeline.c	/^static void trav_backward(int log_set, tcfg_edge_t **path, int path_len,$/;"	f	file:	signature:(int log_set, tcfg_edge_t **path, int path_len, int code_len)
trav_forward	pipeline.c	/^static int trav_forward(int log_set, tcfg_edge_t **path, int path_len,$/;"	f	file:	signature:(int log_set, tcfg_edge_t **path, int path_len, int code_len)
trav_tcfg	bpred.c	/^trav_tcfg()$/;"	f	file:
tsList	scp_address.h	/^    worklist_p          tsList;     \/*Defined temporal scope of this memscp*\/ $/;"	m	struct:scoped_address	access:public
ts_p	scp_address.h	/^typedef struct temporal_scope*  ts_p;$/;"	t	typeref:struct:temporal_scope
ts_s	scp_address.h	/^typedef struct temporal_scope   ts_s;$/;"	t	typeref:struct:temporal_scope
tsize	ss/ecoff.h	/^  int tsize;$/;"	m	struct:ecoff_aouthdr	access:public
twolev_config	ss/my_opt.c	/^int twolev_config[4] = { \/* l1size *\/1, \/* l2size *\/128, \/* hist *\/2, \/* xor *\/$/;"	v
twolev_nelt	ss/my_opt.c	/^int twolev_nelt = 4;$/;"	v
type	cfg.h	/^	int type;$/;"	m	struct:col_data	access:public
type	cfg.h	/^	int type;$/;"	m	struct:ovrl_graph	access:public
type	cfg.h	/^    bb_type_t	type;		$/;"	m	struct:__anon3	access:public
type	isa.h	/^    int	    type;	\/\/ inst type$/;"	m	struct:__anon15	access:public
type	ss/eval.h	/^  enum eval_type_t type;		\/* type of expression value *\/$/;"	m	struct:eval_value_t	typeref:enum:eval_value_t::eval_type_t	access:public
type	ss/misc.c	/^  char *type;$/;"	m	struct:__anon21	file:	access:public
u	cfg.h	/^	}u;$/;"	m	struct:col_data	typeref:union:col_data::__anon6	access:public
u	cfg.h	/^	}u;$/;"	m	struct:ovrl_graph	typeref:union:ovrl_graph::__anon7	access:public
u1_d1_ps	unicache.c	/^int u1_d1_ps = 0;$/;"	v
u1_data_access	isa.h	/^	 ACCESS_T u1_data_access;	\/* unified D\/I cache access classification *\/$/;"	m	struct:__anon16	access:public
uni_inst_filter_function	scp_cache.c	/^void uni_inst_filter_function(int bbi_id, scp_acs mpa_acs_out, de_inst_t* inst,$/;"	f	signature:(int bbi_id, scp_acs mpa_acs_out, de_inst_t* inst, int inst_id, loop_t*lp)
uni_join	scp_cache.c	/^void uni_join(worklist_p* acs_dst, worklist_p* acs_src, loop_t*lp) {$/;"	f	signature:(worklist_p* acs_dst, worklist_p* acs_src, loop_t*lp)
uni_print_ACS	scp_cache.c	/^void uni_print_ACS(scp_acs acs, loop_t*lp) {$/;"	f	signature:(scp_acs acs, loop_t*lp)
uni_transform_ul2acs	scp_cache.c	/^void uni_transform_ul2acs(tcfg_node_t* bbi, loop_t*lp) {$/;"	f	signature:(tcfg_node_t* bbi, loop_t*lp)
uni_update_data	scp_cache.c	/^void uni_update_data(scp_acs acs, worklist_p addrset, loop_t*lp) {$/;"	f	signature:(scp_acs acs, worklist_p addrset, loop_t*lp)
uni_update_inst	scp_cache.c	/^void uni_update_inst(scp_acs acs, unsigned inst_block) {$/;"	f	signature:(scp_acs acs, unsigned inst_block)
uni_update_inst	scp_cache.h	/^void uni_update_inst(scp_acs acs, unsigned inst_block);$/;"	p	signature:(scp_acs acs, unsigned inst_block)
unified	unicache.c	/^int unified = 0;$/;"	v
unionYS	scp_cache.h	/^int unionYS(sblk_p dstBlk, sblk_p srcBlk);$/;"	p	signature:(sblk_p dstBlk, sblk_p srcBlk)
up	scp_address.h	/^    int up;$/;"	m	struct:temporal_scope	access:public
updateInitVal	reg.c	/^int updateInitVal(biv_p biVar, reg_t initVal) {$/;"	f	signature:(biv_p biVar, reg_t initVal)
updateInitVal	symexec.h	/^int updateInitVal(biv_p biVar, reg_t initVal);$/;"	p	signature:(biv_p biVar, reg_t initVal)
updateInitVal	symexec_value.c	/^int updateInitVal(biv_p biVar, char* initVal) {$/;"	f	signature:(biv_p biVar, char* initVal)
updateMemoryAloc	address.c	/^static void updateMemoryAloc(ric_s mem, abs_mem_p* abs_mem_st, ric_p value, $/;"	f	file:	signature:(ric_s mem, abs_mem_p* abs_mem_st, ric_p value, int addr)
updateRIC	address.c	/^static void updateRIC(ric_p* dest, ric_p src1)$/;"	f	file:	signature:(ric_p* dest, ric_p src1)
updateRICAdd	address.c	/^static void updateRICAdd(ric_p* dest, ric_p src1, ric_p src2)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, ric_p src2)
updateRICAddImm	address.c	/^static void updateRICAddImm(ric_p* dest, ric_p src1, int imm)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, int imm)
updateRICBool	address.c	/^static void updateRICBool(ric_p* dest, ric_p src1, ric_p src2)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, ric_p src2)
updateRICBoolImm	address.c	/^static void updateRICBoolImm(ric_p* dest, ric_p src1, int imm)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, int imm)
updateRICBoolU	address.c	/^static void updateRICBoolU(ric_p* dest)$/;"	f	file:	signature:(ric_p* dest)
updateRICImm	address.c	/^static void updateRICImm(ric_p* dest, int imm)$/;"	f	file:	signature:(ric_p* dest, int imm)
updateRICJoin	address.c	/^static ric_p updateRICJoin(ric_p src1, ric_p src2)$/;"	f	file:	signature:(ric_p src1, ric_p src2)
updateRICLeftShift	address.c	/^static void updateRICLeftShift(ric_p* dest, ric_p src1, int imm)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, int imm)
updateRICLoad	address.c	/^static void updateRICLoad(ric_p* dest, ric_p src1, int imm, abs_mem_p abs_mem_st,$/;"	f	file:	signature:(ric_p* dest, ric_p src1, int imm, abs_mem_p abs_mem_st, int size)
updateRICLoadIndex	address.c	/^static void updateRICLoadIndex(ric_p* dest, ric_p src1, ric_p src2,$/;"	f	file:	signature:(ric_p* dest, ric_p src1, ric_p src2, abs_mem_p abs_mem_st, int size)
updateRICMul	address.c	/^static void updateRICMul(ric_p* hi, ric_p* lo, ric_p src1, ric_p src2)$/;"	f	file:	signature:(ric_p* hi, ric_p* lo, ric_p src1, ric_p src2)
updateRICRightShift	address.c	/^static void updateRICRightShift(ric_p* dest, ric_p src1, int imm)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, int imm)
updateRICRightShiftV	address.c	/^static void updateRICRightShiftV(ric_p* dest, ric_p src1, ric_p src2)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, ric_p src2)
updateRICStore	address.c	/^static void updateRICStore(ric_p value, ric_p base, int imm, abs_mem_p* abs_mem_st,$/;"	f	file:	signature:(ric_p value, ric_p base, int imm, abs_mem_p* abs_mem_st, int size, int addr)
updateRICStoreIndex	address.c	/^static void updateRICStoreIndex(ric_p value, ric_p base, ric_p index, $/;"	f	file:	signature:(ric_p value, ric_p base, ric_p index, abs_mem_p* abs_mem_st, int size, int addr)
updateRICSub	address.c	/^static void updateRICSub(ric_p* dest, ric_p src1, ric_p src2)$/;"	f	file:	signature:(ric_p* dest, ric_p src1, ric_p src2)
updateSuccessorAloc	address.c	/^static void updateSuccessorAloc(tcfg_node_t* bbi, int* change);$/;"	p	file:	signature:(tcfg_node_t* bbi, int* change)
updateSuccessorAloc	address.c	/^static void updateSuccessorAloc(tcfg_node_t* bbi, int* change_flag)$/;"	f	file:	signature:(tcfg_node_t* bbi, int* change_flag)
updateUnknownAddr	dump.c	/^void updateUnknownAddr() {$/;"	f
update_abs_inst	unicache.c	/^static acs_p** update_abs_inst(acs_p** acs_in, unsigned addr) {$/;"	f	file:	signature:(acs_p** acs_in, unsigned addr)
update_bbi_map	tcfg.c	/^update_bbi_map(tcfg_node_t *bbi)$/;"	f	file:	signature:(tcfg_node_t *bbi)
update_contd	estimate.c	/^update_contd(egraph_node_t *v)$/;"	f	file:	signature:(egraph_node_t *v)
update_singleton	unicache.c	/^static acs_p* update_singleton(acs_p* acs, mem_blk_set_t* mem_blk_set) {$/;"	f	file:	signature:(acs_p* acs, mem_blk_set_t* mem_blk_set)
upper_bound	address.h	/^	addr_t upper_bound;$/;"	m	struct:ric	access:public
user_cons	ilp.c	/^static void user_cons() {$/;"	f	file:
user_cons_context	ilp.c	/^static void user_cons_context() {$/;"	f	file:
user_ptr	ss/eval.h	/^  void *user_ptr;		\/* user-supplied argument pointer *\/$/;"	m	struct:eval_state_t	access:public
v_info	cfg.h	/^    symbol_i    *v_info;    \/\/ global variable symbol info$/;"	m	struct:__anon5	access:public
val	symexec.h	/^	int val;$/;"	m	struct:__anon17	access:public
valid	address.h	/^	int valid;	  $/;"	m	struct:abs_mem	access:public
valid	cache.h	/^    unsigned short  valid;  \/\/ valid == 0 means empty mempry block$/;"	m	struct:__anon28	access:public
value	address.h	/^	ric_p value;$/;"	m	struct:abs_mem	access:public
value	ss/ecoff.h	/^  int value;$/;"	m	struct:ecoff_SYMR	access:public
value	ss/eval.c	/^  struct eval_value_t *value;$/;"	m	struct:sym_map_t	typeref:struct:sym_map_t::eval_value_t	file:	access:public
value	ss/eval.h	/^  } value;$/;"	m	struct:eval_value_t	typeref:union:eval_value_t::__anon19	access:public
value	symexec.h	/^	reg_t value[MAX_EXPR_LEN]; \/\/restrict to CONST \/ INDUCTION \/ PARA$/;"	m	struct:linear_expr	access:public
var	ss/options.h	/^      char **var;		\/* pointer to string pointer option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_string_t	access:public
var	ss/options.h	/^      double *var;		\/* pointer to double option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_double_t	access:public
var	ss/options.h	/^      float *var;		\/* pointer to float option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_float_t	access:public
var	ss/options.h	/^      int *var;			\/* pointer to integer option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_int_t	access:public
var	ss/options.h	/^      int *var;			\/* ptr to *int* enum option, NOTE: AN INT *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_enum_t	access:public
var	ss/options.h	/^      unsigned int *var;	\/* pointer to unsigned integer option *\/$/;"	m	struct:opt_opt_t::opt_variant_t::opt_for_uint_t	access:public
varNum	symexec.h	/^	int varNum;$/;"	m	struct:linear_expr	access:public
var_grps	ilp.c	/^char **var_grps[256];$/;"	v
variant	ss/options.h	/^  } variant;$/;"	m	struct:opt_opt_t	typeref:union:opt_opt_t::opt_variant_t	access:public
vbbb	bpred.c	/^bfg_node_t	    **vbbb;$/;"	v
verbose	ss/misc.c	/^int verbose = FALSE;$/;"	v
virtual_unroll	tcfg.c	/^void virtual_unroll() {$/;"	f
visited	scp_cache.c	/^int *visited; \/\/flag whether this node is visited first time$/;"	v
vstamp	ss/ecoff.h	/^  short vstamp;$/;"	m	struct:ecoff_aouthdr	access:public
vstamp	ss/ecoff.h	/^  short vstamp;$/;"	m	struct:ecoff_symhdr_t	access:public
vstart_cost_term	ilp.c	/^static void vstart_cost_term() {$/;"	f	file:
vu_loop	tcfg.c	/^static void vu_loop(loop_t* lp) {$/;"	f	file:	signature:(loop_t* lp)
warn	ss/misc.h	/^warn(char *fmt, ...);$/;"	p	signature:(char *fmt, ...)
warn	ss/misc.h	132;"	d
word_t	ss/host.h	/^typedef unsigned int word_t;		\/* word - 32 bits *\/$/;"	t
worklist	common.h	/^struct worklist {$/;"	s
worklist::data	common.h	/^	void* data;$/;"	m	struct:worklist	access:public
worklist::next	common.h	/^	struct worklist* next;$/;"	m	struct:worklist	typeref:struct:worklist::worklist	access:public
worklist_p	common.h	/^typedef struct worklist* worklist_p;$/;"	t	typeref:struct:worklist
worklist_s	common.h	/^typedef struct worklist worklist_s;$/;"	t	typeref:struct:worklist
writeAddr	symexec.h	/^	reg_t writeAddr; \/*addr value of this entry*\/$/;"	m	struct:sym_memory_model	access:public
write_vars	ilp.c	/^static void write_vars() {$/;"	f	file:
x	ss/resource.h	/^  } x[MAX_RES_CLASSES];$/;"	m	struct:res_desc	typeref:struct:res_desc::res_template	access:public
xtestit	ss/misc.c	/^xtestit(char *s)$/;"	f	signature:(char *s)
ys_set	scp_cache.h	/^	worklist_p ys_set; \/* contains temporal-scopes*\/$/;"	m	struct:scope_block	access:public
